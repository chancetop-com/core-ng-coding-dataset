{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNg Guide."}, {"role": "assistant", "content": "# 1.1 - Overview\n\nCore-ng services consist of two primary high-level components:\n\n1.  An application class that extends `core.framework.module.App`\n\n2.  One or more module classes that extend\n    `core.framework.module.Module`\n\nThe `App` class itself extends the `Module` class, adding some\nadditional functionality required for starting the app and configuring\nthe `ModuleContext`. Applications are bootstrapped via a `Main.java`\nclass that instantiates the app class and calls its `start()` method.\n\nThe `ModuleContext` (`core.framework.internal.module.ModuleContext`) is\nthe container class that manages a number of core internal components\nfor an application, including the `HTTPServer` class (powered by the\n[Undertow](http://undertow.io/) networking library), a `ServiceRegistry`\nfor user-implemented service classes, a `BeanFactory` for injectable\nsingleton classes, various config classes, server startup and shutdown\nhooks, and a few other pieces. The members of the `ModuleContext` will\nbe discussed in detail later on.\n\nAll of the modules that comprise an application share the same module\ncontext. When an application is started, the app class loads each module\nby providing the module a reference to the application-level module\ncontext and calling the given module\\'s `initialize()` method for\nmodule-specific setup.\n\n### Modules\n\nThe `core.framework.module.Module` class, as the name implies, provides\nmethods for managing and configuring the various features supported by\nthe Core-ng framework in a modularized fashion. As needed, it attaches\nthese configurations and functionalities to the applicaton module\ncontext. The full list of feature configurations, found in\n`core.framework.module.*` are listed below:\n\n-   [LogConfig](#)\n\n-   [HTTPConfig](#)\n\n-   [WebsocketConfig](#)\n\n-   [SiteConfig](#)\n\n-   [CacheConfig](#)\n\n-   [SchedulerConfig](#)\n\n-   [ExecutorConfig](#)\n\n-   [APIConfig](#)\n\n-   [DBConfig](#)\n\n-   [RedisConfig](#)\n\n-   [KafkaConfig](#)"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.2 Getting Started."}, {"role": "assistant", "content": "This section will take you through setting up and running a basic\nCore-ng application on your local machine.\n\n## Prerequisites (OSX)\n\n### Java\n\nAs of writing, Wonder uses the [Eclipse\nTemurin](https://whichjdk.com/#adoptium-eclipse-temurin) OpenJDK for\nJava 21. We recommend installing [SDKMAN!](https://sdkman.io/install)\nfor managing Java versions locally. With SDKMAN!, installing a new\nversion of Java can be done in a single command:\n\n\\> sdk install java 21.0.2-tem\n\n### IntelliJ (Optional)\n\nIt is also highly recommended to install the [IntelliJ\nIdea](https://www.jetbrains.com/idea/) IDE. While it is possible and\nperfectly fine to use a different IDE to set up a Core-ng project,\nIntelliJ provides a lot of convenient project setup and management\nfeatures that will be utilized in this guide. For manual setup, you will\nlikely want to install [Gradle](https://gradle.org/) and take a look at\nthe `gradle init` command.\n\n## Project Setup\n\nTo begin, create a new project in IntelliJ using Gradle as the build\nsystem, Java as the language, and Kotlin as the Gradle DSL. Be sure to\nset the `Project JDK` to Java 21- you can add a JDK to IntelliJ with the\n`Add JDK...` option from the JDK dropdown in the project creation\nwizard. If you installed Eclipse Temurin 21 via SDKMAN!, the home path\nshould be:\n\n/Users/\\<user\\>/.sdkman/candidates/java/21.0.2-tem\n\nName your new project, finish the setup, and IntelliJ will create a\nGradle project with a standard Java directory structure to work with.\nQuickly verify that the proper JDK (Open JDK 21) is set as the project\ndefault and the Gradle JVM by checking `File` -\\> `Project Structure`\n-\\> `Project SDK` as well as `Preferences` -\\>\n`Build, Execution, Deployment` -\\> `Build Tools` -\\> `Gradle` -\\>\n`Gradle JVM`. You will encounter errors running your project if these\nfields are not correctly configured.\n\n### (Java) Module Setup\n\nThe Core-ng [demo\nproject](https://github.com/neowu/core-ng-demo-project) includes useful\nsetup files that we will take advantage of to get our project going\nquickly. Open a terminal and clone the demo repository to a separate\ndirectory:\n\n\\> git clone https://github.com/neowu/core-ng-demo-project.git\n\nNow, copy the `buildSrc` directory from the Core-ng demo project and\npaste it into your new project. This adds a number of gradle tasks that\nwill be useful for our project (TODO: more details on these).\n\nDelete the `src` directory that was generated by IntelliJ, right-click\nthe root directory and use `New` -\\> `Module` to create a module called\n\\\"demo-service\\\", and delete the new module\\'s `build.gradle.kts` file\nonce it\\'s created. Finally, update the root `build.gradle.kts` to the\nfollowing:\n\nkotlinplugins { java } apply(plugin = \\\"project\\\") subprojects { group =\n\\\"core.demo\\\" version = \\\"1.0.0\\\" repositories { maven { url =\nuri(\\\"https://neowu.github.io/maven-repo/\\\") content {\nincludeGroupByRegex(\\\"core\\\\\\\\.framework.\\*\\\") } } maven { url =\nuri(\\\"https://maven.codelibs.org/\\\") content {\nincludeGroup(\\\"org.codelibs.elasticsearch.module\\\") } } } if\n(childProjects.isEmpty()) { sourceSets { create(\\\"dev\\\") {\njava.srcDir(\\\"src/dev/java\\\") compileClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath runtimeClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath } } } } val coreNGVersion =\n\\\"9.0.9\\\" configure(listOf(project(\\\":demo-service\\\"))) { apply(plugin =\n\\\"app\\\") dependencies {\nimplementation(\\\"core.framework:core-ng:\\${coreNGVersion}\\\")\ntestImplementation(\\\"core.framework:core-ng-test:\\${coreNGVersion}\\\") }\n}\n\n### Launching the Application\n\nAs mentioned in the [Overview](#), Core-ng applications generally\ncomprise two main component types: an App class and one or more Module\nclasses. However, it is possible to start a Core-ng application with\nonly an App class.\n\nIn `demo-service/src/main/java/app`, create the following\n`DemoApp.class` file:\n\njavapackage app; import core.framework.module.App; public class DemoApp\nextends App { \\@Override protected void initialize() {\nhttp().listenHTTP(\\\"8080\\\"); } }\n\nThis sets up a basic web app listening on\n[https://localhost:8080.](https://localhost:8080.) To launch the app,\ncreate a `Main.java` class file in `demo-service/src/main/java` that\nimports and starts your app:\n\njavaimport app.DemoApp; public class Main { public static void\nmain(String\\[\\] args) { new DemoApp().start(); } }\n\nThat\\'s it! From the Gradle menu in IntelliJ (right side bar), use the\ntask under `demo-service` -\\> `Tasks` -\\> `application` -\\> `run` to run\nyour app. Be sure to refresh Gradle if you don\\'t see these options.\nVisit <http://localhost:8080/_sys/property> to see a dump of the system\nproperties. Core-ng provides a number of `_sys` endpoints out of the box\nthat provide diagnostic data for your application (// TODO see more\n[here](#)). In the next section, we\\'ll add a basic REST endpoint to our\napp."}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.3 - A Basic Web Service Module."}, {"role": "assistant", "content": "This section will walk through creating a basic web service with the\nCore-ng framework. It assumes you\\'ve already completed the [Getting\nStarted](#) section.\n\n### Defining the Service Interface\n\nAll web services in Core-ng should be defined via a service interface.\nThe framework provides annotations (see\n`core.framework.api.web.service.*`) for defining routes (`@Path`), route\nparameters (`@PathParam`), query parameters (`@QueryParam`), response\nstatuses (`@ResponseStatus`), and standard HTTP verbs:\n\n-   `@GET`\n\n-   `@POST`\n\n-   `@PUT`\n\n-   `@PATCH`\n\n-   `@DELETE`\n\nIn addition to defining the service REST interface, it is expected that\nall request and response objects be defined as classes.\n\nTo get started, right click the root directory and use `New` -\\>\n`Module` to create a new `demo-service-interface` module in our project.\nDelete the new module\\'s auto-generated `build.gradle` file and add the\ninterface as a project dependency for our `demo-service` in the root\n`build.gradle` (as well as the interface module\\'s Core-ng dependency):\n\nkotlinplugins { java } apply(plugin = \\\"project\\\") subprojects { group =\n\\\"core.demo\\\" version = \\\"1.0.0\\\" repositories { maven { url =\nuri(\\\"https://neowu.github.io/maven-repo/\\\") content {\nincludeGroupByRegex(\\\"core\\\\\\\\.framework.\\*\\\") } } maven { url =\nuri(\\\"https://maven.codelibs.org/\\\") content {\nincludeGroup(\\\"org.codelibs.elasticsearch.module\\\") } } } if\n(childProjects.isEmpty()) { sourceSets { create(\\\"dev\\\") {\njava.srcDir(\\\"src/dev/java\\\") compileClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath runtimeClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath } } } } val coreNGVersion =\n\\\"9.0.9\\\" configure(listOf(project(\\\":demo-service\\\"))) { apply(plugin =\n\\\"app\\\") dependencies {\nimplementation(project(\\\":demo-service-interface\\\"))\nimplementation(\\\"core.framework:core-ng:\\${coreNGVersion}\\\")\ntestImplementation(\\\"core.framework:core-ng-test:\\${coreNGVersion}\\\") }\n} configure(listOf(project(\\\":demo-service-interface\\\"))) { dependencies\n{ implementation(\\\"core.framework:core-ng-api:\\${coreNGVersion}\\\") } }\n\nNext, in `demo-service-interface/src/main/java`, create a new package\n`app.demo.api` and a new directory `customer` in that package. For now,\nwe\\'ll create two simple customer endpoints that mock creating and\nretreiving a customer resource. In the new `customer` directory, let\\'s\ndefine a `CreateCustomerRequest.class` request object:\n\njavapackage app.demo.api.customer; import\ncore.framework.api.json.Property; import\ncore.framework.api.validate.NotBlank; import\ncore.framework.api.validate.NotNull; public class CreateCustomerRequest\n{ \\@NotNull \\@NotBlank \\@Property(name = \\\"email\\\") public String email;\n\\@NotNull \\@NotBlank \\@Property(name = \\\"first_name\\\") public String\nfirstName; \\@NotBlank \\@Property(name = \\\"last_name\\\") public String\nlastName; }\n\nCore-ng provides yet more annotations here to define JSON properties and\nbasic JSON validation (TODO: link to docs for more). We\\'ll also need a\n`CustomerView.class` response object:\n\njavapackage app.demo.api.customer; import\ncore.framework.api.json.Property; import\ncore.framework.api.validate.NotBlank; import\ncore.framework.api.validate.NotNull; import java.time.LocalDateTime;\npublic class CustomerView { \\@NotNull \\@Property(name = \\\"id\\\") public\nLong id; \\@NotNull \\@NotBlank \\@Property(name = \\\"email\\\") public String\nemail; \\@NotNull \\@NotBlank \\@Property(name = \\\"first_name\\\") public\nString firstName; \\@NotBlank \\@Property(name = \\\"last_name\\\") public\nString lastName; \\@NotNull \\@Property(name = \\\"updated_time\\\") public\nLocalDateTime updatedTime; }\n\nNow, in `demo-service-interface/src/main/java/app/demo/api`, we can\ndefine our REST interface with POST and GET endpoints:\n\njavapackage app.demo.api; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import\ncore.framework.api.http.HTTPStatus; import\ncore.framework.api.web.service.GET; import\ncore.framework.api.web.service.POST; import\ncore.framework.api.web.service.Path; import\ncore.framework.api.web.service.PathParam; import\ncore.framework.api.web.service.ResponseStatus; public interface\nCustomerWebService { \\@POST \\@Path(\\\"/customer\\\")\n\\@ResponseStatus(HTTPStatus.CREATED) CustomerView\ncreate(CreateCustomerRequest request); \\@GET \\@Path(\\\"/customer/:id\\\")\nCustomerView get(@PathParam(\\\"id\\\") Long id); }\n\nThis interface defines two different routes:\n\n-   A POST route at `/customer` that will return a HTTP 201 status if\n    the resource is successfully created\n\n-   A GET route at `/customer/:id`, where `:id` is a path parameter that\n    will automatically be parsed from the route and cast to a `Long`\n    when the request is processed\n\n### Implementing the Service Interface\n\nPer Core-ng conventions, for each resource with a defined interface in\n`${some-name}-service-interface`, the corresponding\n`${some-name}-service` module should impement that service interface. In\ngeneral, this is separated into three sub-packages with different\nresponsibilities:\n\n-   the `domain` package defines data access objects (DAOs) for the\n    backing repository (MySQL, Mongo, etc)\n\n-   the `service` package contains classes that implement the business\n    logic for out services, injecting Respository (more on these later)\n    classes for accessing our domain objects as needed\n\n-   the `web` package contains the implementations of web service\n    interfaces, injecting and calling the service classes as needed\n\nSo for our demo application, in `demo-service/src/main/java` we would\nhave the following packages:\n\n-   `app.demo.customer.domain`\n\n-   `app.demo.customer.service`\n\n-   `app.demo.customer.web`\n\nBecause our mock service is not backed by a data store yet (we will\ndiscuss repositories in the [next section](#)), let\\'s just implement a\nsimple `CustomerService.class` in `app.demo.customer.service`:\n\njavapackage app.demo.customer.service; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import java.time.LocalDateTime;\npublic class CustomerService { public CustomerView\ncreate(CreateCustomerRequest request) { return mockCustomer(1L); }\npublic CustomerView get(Long id) { return mockCustomer(id); } private\nCustomerView mockCustomer(Long id) { CustomerView customer = new\nCustomerView(); customer.id = id; customer.firstName = \\\"Charlie\\\";\ncustomer.lastName = \\\"Fox\\\"; customer.email =\n\\\"charlie@remarkablefoods.com\\\"; customer.updatedTime =\nLocalDateTime.now(); return customer; } }\n\nNext, let\\'s implement the the interface we defined earlier with a new\n`CustomerWebServiceImpl` in `app.demo.customer.web`:\n\njavapackage app.demo.customer.web; import\napp.demo.api.CustomerWebService; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import\napp.demo.customer.service.CustomerService; import\ncore.framework.inject.Inject; public class CustomerWebServiceImpl\nimplements CustomerWebService { \\@Inject CustomerService\ncustomerService; \\@Override public CustomerView\ncreate(CreateCustomerRequest request) { return\ncustomerService.create(request); } \\@Override public CustomerView\nget(Long id) { return customerService.get(id); } }\n\nOur service interface and implementations are in place! Notice the\n`@Inject` annotation- this annotation prompts the application context to\nprovide an instance of our `CustomerService.class` to the\n`CustomerWebServiceImpl.class` via dependency injection. For this to\nsucceed, we must *bind* our `CustomerService.class` to the module\ncontext, which we will complete next.\n\n### Creating and Loading a Web Module\n\nAs a final step, we need to create a customer module, register our web\ninterface with the module, and load the module in our application.\nDefine the `CustomerModule.class` in `demo-service/src/main/java/app`:\n\njavapackage app; import app.demo.api.CustomerWebService; import\napp.demo.customer.service.CustomerService; import\napp.demo.customer.web.CustomerWebServiceImpl; import\ncore.framework.module.Module; public class CustomerModule extends Module\n{ \\@Override protected void initialize() { bind(CustomerService.class);\napi().service(CustomerWebService.class,\nbind(CustomerWebServiceImpl.class)); } }\n\nA few things are happening here:\n\n-   we bind our `CustomerService.class` service and the\n    `CustomerWebServiceImpl.class` implementation to the application\n    module context so they can be injected and used as needed.\n\n-   we use the [APIConfig](#) feature to define a service on our module\n    context, which sets up handlers on the internal Core-ng\n    [HTTPServer](#) in the context and maps our route definitions in the\n    interface to their proper service method implementations\n\nDuring this process, Core-ng also verifies that all route definitions\nare valid (for example, that `@PathParams` expect supported [types](#))\nand have corresponding service implementations, throwing Errors as\nneeded.\n\nAt last, let\\'s load our new `CustomerModule.class` in our application\n`DemoApp.class`:\n\njavapackage app; import core.framework.module.App; public class DemoApp\nextends App { \\@Override protected void initialize() {\nhttp().listenHTTP(\\\"8080\\\"); load(new CustomerModule()); } }\n\nOur basic web service module is complete!\n\n### Manually Test the Web Service Module\n\nRun the app via the gradle menu by launching the task `demo-service` -\\>\n`Tasks` -\\> `application` -\\> `run`. A curl request to our webs service\nshould then return our mock customer object with the id provided in the\nroute:\n\nbash\\> curl localhost:8080/customer/1 \\| json_ppjson{ \\\"id\\\": 1,\n\\\"email\\\": \\\"charlie@remarkablefoods.com\\\", \\\"first_name\\\": \\\"Charlie\\\",\n\\\"last_name\\\": \\\"Fox\\\", \\\"updated_time\\\": \\\"2020-04-14T12:56:32.661839\\\"\n}\n\nIf you want, try testing our POST endpoint as well. In the next section,\nwe\\'ll take a look at using Core-ng with a database!"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.4 - Using Core-ng Repositories."}, {"role": "assistant", "content": "This section will walk through using Core-ng repositories to access a\ndatabase in your application. It continues developing the app started in\nsections [1.2](#) and [1.3](#).\n\n## Prerequisites\n\nIn order to take advantage of the Core-ng repository utilities, we\\'ll\nfirst need to setup a backing database service. [Docker\nCompose](https://docs.docker.com/compose/) makes it easy to spin up\nvarious services for local development and can be installed via the\nDocker website [here](https://docs.docker.com/get-docker/).\n\nNext, download the\n[local_environment](https://github.com/food-truck/local-environment)\nproject from git, which provides a baseline `docker-compose.yaml` that\nsets up many of the common backing services used by Core-ng for local\ndevelopment:\n\nbash\\> git clone https://github.com/food-truck/local-environment.git\n\nRun just the MySQL service by entering the root `local_env` directory of\nthe cloned repo in a terminal and running:\n\n\\> docker-compose up mysql\n\nYou may also want to install software such as\n[DBeaver](https://dbeaver.io/) or [MySQL\nWorkbench](https://dev.mysql.com/downloads/workbench/) so that it is\neasier to modify the MySQL instance and add databases when needed. The\nroot password for your local MySQL instance can be found in the\n`local_env/docker-compose.yaml` file under the `mysql` service\ndefinition (username: *root*, password: *root*).\n\n## Project Setup\n\nTo setup Core-ng repositories for MySQL in your project, first add the\nMySQL driver to your project via the `build.gradle.kts` project as a\n`runtimeOnly` dependency:\n\nkotlinplugins { java } apply(plugin = \\\"project\\\") subprojects { group =\n\\\"core.demo\\\" version = \\\"1.0.0\\\" repositories { maven { url =\nuri(\\\"https://neowu.github.io/maven-repo/\\\") content {\nincludeGroupByRegex(\\\"core\\\\\\\\.framework.\\*\\\") } } maven { url =\nuri(\\\"https://maven.codelibs.org/\\\") content {\nincludeGroup(\\\"org.codelibs.elasticsearch.module\\\") } } } if\n(childProjects.isEmpty()) { sourceSets { create(\\\"dev\\\") {\njava.srcDir(\\\"src/dev/java\\\") compileClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath runtimeClasspath +=\nsourceSets\\[\\\"main\\\"\\].runtimeClasspath } } } } val coreNGVersion =\n\\\"9.0.9\\\" configure(listOf(project(\\\":demo-service\\\"))) { apply(plugin =\n\\\"app\\\") dependencies {\nimplementation(project(\\\":demo-service-interface\\\"))\nimplementation(\\\"core.framework:core-ng:\\${coreNGVersion}\\\")\nruntimeOnly(\\\"core.framework.mysql:mysql-connector-j:8.4.0-r2\\\")\ntestImplementation(\\\"core.framework:core-ng-test:\\${coreNGVersion}\\\") }\n} configure(listOf(project(\\\":demo-service-interface\\\"))) { dependencies\n{ implementation(\\\"core.framework:core-ng-api:\\${coreNGVersion}\\\") } }\n\n### The System Module\n\nAs a final setup step, we must provide our application with the proper\nURL and credentials to access the local MySQL instance running via\nDocker. A special Core-ng module, the [SystemModule](#)\n(`core.framework.module.SystemModule`), provides a number of methods for\nconfiguring backing services. To use the `SystemsModule`, let\\'s define\na system properties file in\n`/demo-service/src/main/resources/sys.properties`:\n\nsys.jdbc.password=root\nsys.jdbc.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=utf-8\nsys.jdbc.user=root\n\nThis file defines the URL and credentials for our local MySQL instance\nto be used by the application.\n\n> Note: You will need to connect to the MySQL instance using MySQL\n> Workbench or a similar tool and create a `demo` database or the\n> connection to `jdbc:mysql://127.0.0.1:3306/demo` defined above will\n> error. Use `utf8mb4` as the character encoding when creating the new\n> database. Addtionally, you should add a new `customers` table to the\n> database with the correct columns present:\n\nsqlCREATE TABLE \\`customers\\` ( \\`id\\` int NOT NULL AUTO_INCREMENT,\n\\`email\\` varchar(50) NOT NULL, \\`first_name\\` varchar(50) NOT NULL,\n\\`last_name\\` varchar(50) DEFAULT NULL, \\`updated_time\\` datetime NOT\nNULL, PRIMARY KEY (\\`id\\`), UNIQUE KEY \\`email\\` (\\`email\\`) )\n\nFinally, in our `DemoApp.class` application class, create and load a new\n`SystemModule`, pointing it to our new `sys.properties` file:\n\njavapackage app; import core.framework.module.App; import\ncore.framework.module.SystemModule; public class DemoApp extends App {\n\\@Override protected void initialize() { http().listenHTTP(\\\"8080\\\");\nload(new SystemModule(\\\"sys.properties\\\")); load(new CustomerModule());\n} }\n\nOur local MySQL instance should now be properly configured.\n\n### Defining a Domain Object\n\nDomain objects are our data access objects (DAOs) that map directly to a\nrecord in a database table. Let\\'s define a `Customer.class` domain\nobject in a new `demo-service/src/main/java/app/demo/customer/domain`\npackage:\n\njavapackage app.demo.customer.domain; import\ncore.framework.api.validate.NotBlank; import\ncore.framework.api.validate.NotNull; import core.framework.db.Column;\nimport core.framework.db.PrimaryKey; import core.framework.db.Table;\nimport java.time.LocalDateTime; \\@Table(name = \\\"customers\\\") public\nclass Customer { \\@PrimaryKey(autoIncrement = true) \\@Column(name =\n\\\"id\\\") public Long id; \\@NotNull \\@NotBlank \\@Column(name = \\\"email\\\")\npublic String email; \\@NotNull \\@NotBlank \\@Column(name =\n\\\"first_name\\\") public String firstName; \\@NotBlank \\@Column(name =\n\\\"last_name\\\") public String lastName; \\@NotNull \\@Column(name =\n\\\"updated_time\\\") public LocalDateTime updatedTime; }\n\nNotice a few things here:\n\n-   The `@Table` annotation marks this class as a SQL domain object,\n    with the name parameter corresponding to the table name in the\n    database. Per Core-ng conventions, the table name is plural\n    (`customers`), while the class name is singular (`Customer`), as an\n    instance of this object most commonly represents a single customer\n    record in the customers table.\n\n-   Table columns are marked via the the `@Column` annotation. Per\n    Core-ng conventions, column names are lowercase underscore-separated\n    labels, while the corresponding java member variable is the\n    identical name with camelCase labeling (ex `last_name` and\n    `lastName`).\n\n-   Every domain object must have a `@PrimaryKey` column, which can be\n    configured to use an `autoIncrement` key generated by the database\n    or an application-generated UUID. Per conventions, the primary key\n    column is always called `id`.\n\n-   The classes in `core.framework.api.validate.*` provide a number of\n    annotations for validating columns in a domain object, including\n    `@NotBlank`, `@NotNull`, `@Min`, `@Max`, and others. See the\n    validate [documentation](#) (//TODO) for more details.\n\n### Using the Domain Object\n\nIt\\'s finally time to use our domain object! Let\\'s replace the mock\nservice implementations from section [1.3](#) in `CustomerService.class`\nwith real database calls using the utilities provided by Core-ng:\n\njavapackage app.demo.customer.service; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import\napp.demo.customer.domain.Customer; import core.framework.db.Repository;\nimport core.framework.inject.Inject; import core.framework.util.Strings;\nimport core.framework.web.exception.ConflictException; import\ncore.framework.web.exception.NotFoundException; import\njava.time.LocalDateTime; import java.util.Optional; public class\nCustomerService { \\@Inject Repository\\<Customer\\> customerRepository;\npublic CustomerView create(CreateCustomerRequest request) {\nOptional\\<Customer\\> existingCustomer =\ncustomerRepository.selectOne(\\\"email = ?\\\", request.email); if\n(existingCustomer.isPresent()) { throw new\nConflictException(Strings.format(\\\"customer already exists, email={}\\\",\nrequest.email)); } Customer customer = new Customer(); customer.email =\nrequest.email; customer.firstName = request.firstName; customer.lastName\n= request.lastName; customer.updatedTime = LocalDateTime.now();\ncustomer.id = customerRepository.insert(customer).orElseThrow(); return\nview(customer); } public CustomerView get(Long id) { Customer customer =\ncustomerRepository.get(id).orElseThrow(() -\\> new\nNotFoundException(Strings.format(\\\"customer not found, id={}\\\", id)));\nreturn view(customer); } private CustomerView view(Customer customer) {\nCustomerView result = new CustomerView(); result.id = customer.id;\nresult.email = customer.email; result.firstName = customer.firstName;\nresult.lastName = customer.lastName; result.updatedTime =\ncustomer.updatedTime; return result; } }\n\nOnce again, we use the `@Inject` annotation, this time to add a\nrepository class that wraps our `Customer.class` domain object, allowing\nus to take advantage of a number of convienence methods for making\nsimple CRUD queries to the \\\"customers\\\" table that backs our domain\nclass. See the [Querying Repositories](#) (//TODO) section to read more\nabout querying with the Core-ng `Repository` and other ways to query\ndatabases with Core-ng.\n\nAlso, notice the use of `Strings.format()` to format out error messages.\nCore-ng\\'s `core.framework.util.*` provides a number of utilitiy classes\nthat you can read about [here](#).\n\n### Wiring Up the Repository Class\n\nAs a final step, we\\'ll use the `DBConfig` on out `CustomerModule.class`\nmodule to register our domain object:\n\njavapackage app; import app.demo.api.CustomerWebService; import\napp.demo.customer.domain.Customer; import\napp.demo.customer.service.CustomerService; import\napp.demo.customer.web.CustomerWebServiceImpl; import\ncore.framework.module.Module; public class CustomerModule extends Module\n{ \\@Override protected void initialize() {\ndb().repository(Customer.class); bind(CustomerService.class);\napi().service(CustomerWebService.class,\nbind(CustomerWebServiceImpl.class)); } }\n\nThis binds a `Repository<Customer>` repository to our application module\ncontext, which we injected in the `CustomerService.class` service to\nquery our database.\n\n### Manually Testing the Repository\n\nRun the app via the gradle menu by launching the task `demo-service` -\\>\n`Tasks` -\\> `application` -\\> `run`. Be sure your local MySQL instance\nis running by entering the `local-env` repo in a terminal and using:\n\n\\> docker-compose start mysql\n\n> Note: By using `docker-compose start` here instead of\n> `docker-compose up`, you prevent docker from re-creating your mysql\n> container, which may wipe the contents of your database between\n> starts.\n\nNow test creating a customer resource via our POST endpoint:\n\nbash\\> curl \\--header \\\"Content-Type: application/json\\\" \\\\ \\--request\nPOST \\\\ \\--data \\'{\\\"first_name\\\": \\\"Charlie\\\", \\\"last_name\\\": \\\"Fox\\\",\n\\\"email\\\": \\\"charlie@remarkablefoods.com\\\"}\\' \\\\\nhttp://localhost:8080/customer \\| json_ppjson{ \\\"id\\\" : 1, \\\"last_name\\\"\n: \\\"Fox\\\", \\\"first_name\\\" : \\\"Charlie\\\", \\\"updated_time\\\" :\n\\\"2020-04-20T12:47:56.53133\\\", \\\"email\\\" :\n\\\"charlie@remarkablefoods.com\\\", }\n\nFinally, GET the resource you just created by id:\n\nbash\\> curl localhost:8080/customer/1 \\| json_ppjson{ \\\"id\\\" : 1,\n\\\"first_name\\\" : \\\"Charlie\\\", \\\"email\\\" :\n\\\"charlie@remarkablefoods.com\\\", \\\"last_name\\\" : \\\"Fox\\\",\n\\\"updated_time\\\" : \\\"2020-04-20T12:47:57.000\\\" }\n\nOur app is now backed by a live database!"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.5 - Core-ng Async."}, {"role": "assistant", "content": "This section will walk through Core-ng\\'s async APIs including:\n\n-   the Executor\n\n-   the Scheduler\n\n-   Kafka support\n\nIt assumes you have completed the previous [Getting Started](#) sections\n1.2-1.4\n\n## The Executor\n\nFor long-running tasks initiated by requests that threaten to cause HTTP\ntimeouts, Core-ng provides the Executor API so that these otherwise\nblocking tasks may be run asychronously, allowing the request to return\nimmediately. Since Core-ng version 9, executors have been powered by\nJava virtual threads. Core-ng\\'s executor implementation in\n`core.framework.internal.async.ExecutorImpl` uses\n`java.util.concurrent.ExecutorService` and\n`java.util.concurrent.ScheduledExecutorService` under the hood, wrapping\nthese classes with additional logging and functionality.\n\n### Injecting and Using the Executor\n\nTo use the executor, it can be injected into a service and fed `Tasks`\nas Java lambda functions via the `submit()` method:\n\njavapackage app.demo.customer.service; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import\napp.demo.customer.domain.Customer; import core.framework.async.Executor;\nimport core.framework.db.Repository; import\ncore.framework.inject.Inject; import core.framework.util.Strings; import\ncore.framework.web.exception.ConflictException; import\ncore.framework.web.exception.NotFoundException; import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory; import java.time.Duration; import\njava.time.LocalDateTime; import java.util.Optional; public class\nCustomerService { private final Logger logger =\nLoggerFactory.getLogger(CustomerService.class); \\@Inject\nRepository\\<Customer\\> customerRepository; \\@Inject Executor executor;\npublic CustomerView create(CreateCustomerRequest request) {\nOptional\\<Customer\\> existingCustomer =\ncustomerRepository.selectOne(\\\"email = ?\\\", request.email); if\n(existingCustomer.isPresent()) { throw new\nConflictException(Strings.format(\\\"customer already exists, email={}\\\",\nrequest.email)); } Customer customer = new Customer(); customer.email =\nrequest.email; customer.firstName = request.firstName; customer.lastName\n= request.lastName; customer.updatedTime = LocalDateTime.now();\ncustomer.id = customerRepository.insert(customer).orElseThrow();\nexecutor.submit(\\\"normal-task\\\", () -\\> { logger.info(\\\"Customer\ncreated!\\\"); }); executor.submit(\\\"delayed-task\\\", () -\\> {\nlogger.info(\\\"Customer created about 10s ago!\\\"); },\nDuration.ofSeconds(10)); return view(customer); } public CustomerView\nget(Long id) { Customer customer =\ncustomerRepository.get(id).orElseThrow(() -\\> new\nNotFoundException(Strings.format(\\\"customer not found, id={}\\\", id)));\nreturn view(customer); } private CustomerView view(Customer customer) {\nCustomerView result = new CustomerView(); result.id = customer.id;\nresult.email = customer.email; result.firstName = customer.firstName;\nresult.lastName = customer.lastName; result.updatedTime =\ncustomer.updatedTime; return result; } }\n\nThe Executor `submit()` method takes a task name for logging as the\nfirst argument, followed by the `Task` itself. An optional delay\nduration may be added as well, shown above in the \\\"delayed-task\\\". For\nthis example, the tasks simply log simple messages, though in practice\nthese would do more work. The `core.framework.async.Task` functional\ninterface itself is very similar `java.lang.Runnable` except it allows\nfor exceptions to be thrown:\n\njavapackage core.framework.async; /\\*\\* \\* \\@author neo \\*/\n\\@FunctionalInterface public interface Task { void execute() throws\nException; // not using Runnable to allow throw exception }\n\nCore-ng\\'s executor implementation in\n`core.framework.internal.async.ExecutorImpl` uses\n`java.util.concurrent.ExecutorService` and\n`java.util.concurrent.ScheduledExecutorService` under the hood, wrapping\nthese classes with additional logging and functionality.\n\n### Testing Our Async Tasks\n\nThe async tasks we created were added to the `CustomerService.create()`\nmethod. To test them out, run the app and create a new customer via our\n`POST /customer` endpoint. See section [1.4](#) if you need a reminder\nhow to do this with curl.\n\nAfter a customer is created, we should see our first async task execute\nand log a message:\n\n2020-04-28T16:19:47.836727Z \\[local\\] \\[executor-0\\] INFO\na.d.c.service.CustomerService - Customer created!\n\nFollowed by our delayed task 10 seconds later:\n\n2020-04-28T16:19:57.840055Z \\[local\\] \\[executor-1\\] INFO\na.d.c.service.CustomerService - Customer created about 10s ago!\n\n## The Scheduler\n\nThe scheduler provides various APIs for scheduling asynchronous jobs to\nrun on a service periodically.\n\n### The Job Interface\n\nTo configure a job, we must first implement the\n`core.framework.scheduler.Job` interface. Let\\'s add a simple job to our\nproject alongside the domain, web, and service packages as\n`app.demo.customer.job.SimpleJob`:\n\njavapackage app.demo.customer.job; import core.framework.scheduler.Job;\nimport core.framework.scheduler.JobContext; import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory; public class SimpleJob implements Job {\nprivate final Logger logger = LoggerFactory.getLogger(SimpleJob.class);\n\\@Override public void execute(JobContext context) throws Exception {\nlogger.info(\\\"Running the simple job!\\\"); } }\n\nClasses that implement `core.framework.scheduler.Job` must override the\n`execute` method. For now, we will simply log a message to the console.\n\n### Scheduling the Job\n\nBack in our `CustomerModule`, we can now schedule the job using the\nvarious APIs provided by the scheduler. Let\\'s schedule this job to run\nevery minute, as well as once a day at noon:\n\njavapackage app; import app.demo.api.CustomerWebService; import\napp.demo.customer.domain.Customer; import\napp.demo.customer.job.SimpleJob; import\napp.demo.customer.service.CustomerService; import\napp.demo.customer.web.CustomerWebServiceImpl; import\ncore.framework.module.Module; import core.framework.scheduler.Job;\nimport java.time.Duration; import java.time.LocalTime; public class\nCustomerModule extends Module { \\@Override protected void initialize() {\ndb().repository(Customer.class); bind(CustomerService.class);\napi().service(CustomerWebService.class,\nbind(CustomerWebServiceImpl.class)); Job simpleJob =\nbind(SimpleJob.class); schedule().fixedRate(\\\"simple-fixed\\\", simpleJob,\nDuration.ofMinutes(1)); schedule().dailyAt(\\\"simple-daily\\\", simpleJob,\nLocalTime.NOON); } }\n\nThat\\'s it, our fixed-rate and daily jobs are scheduled! For more\nscheduling options, see `core.framework.module.SchedulerConfig`.\n\n### Testing our Scheduled Jobs\n\nTo test if our scheduled jobs are running, start the app via the gradle\nmenu by launching the task `demo-service` -\\> `Tasks` -\\> `application`\n-\\> `run`. If you wait around a few minues, you should see the logs from\nour fixed-rate task running as scheduled:\n\n2020-05-28T20:28:56.541990Z \\[Charlies-MBP\\] \\[scheduler-1\\] INFO\nc.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed,\nrate=PT1M,\nscheduled=2020-05-28T16:28:56.539630-04:00\\[America/New_York\\],\nnext=2020-05-28T16:29:56.539630-04:00\\[America/New_York\\]\n2020-05-28T20:28:56.545649Z \\[Charlies-MBP\\] \\[scheduler-job-1\\] INFO\na.d.c.job.SimpleJob - Running the simple job!\n2020-05-28T20:29:04.398671Z \\[Charlies-MBP\\] \\[background-task-1\\] INFO\nc.f.i.resource.Pool - refresh resource pool, pool=db\n2020-05-28T20:29:56.545280Z \\[Charlies-MBP\\] \\[scheduler-1\\] INFO\nc.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed,\nrate=PT1M,\nscheduled=2020-05-28T16:29:56.539630-04:00\\[America/New_York\\],\nnext=2020-05-28T16:30:56.539630-04:00\\[America/New_York\\]\n2020-05-28T20:29:56.545783Z \\[Charlies-MBP\\] \\[scheduler-job-2\\] INFO\na.d.c.job.SimpleJob - Running the simple job!\n2020-05-28T20:30:56.543935Z \\[Charlies-MBP\\] \\[scheduler-1\\] INFO\nc.f.i.scheduler.Scheduler - execute scheduled job, job=simple-fixed,\nrate=PT1M,\nscheduled=2020-05-28T16:30:56.539630-04:00\\[America/New_York\\],\nnext=2020-05-28T16:31:56.539630-04:00\\[America/New_York\\]\n2020-05-28T20:30:56.544640Z \\[Charlies-MBP\\] \\[scheduler-job-3\\] INFO\na.d.c.job.SimpleJob - Running the simple job!\n\nIf you wait until noon (not recommended unless it\\'s currently 11:59AM),\nyou should see our daily task too!\n\n## Core-ng Kafka\n\n### Defining the Message\n\nCore-ng provides support for Kafka out of the box. In order to allow for\neasy consumption of Kafka messages between services, the message domain\nobjects should be defined as part of the service interface. Let\\'s\ndefine a very simple Kafka message under the `demo-service-interface` as\n`app.demo.api.customer.kafka.CustomerCreatedMessage`:\n\njavapackage app.demo.api.customer.kafka; import\ncore.framework.api.json.Property; import\ncore.framework.api.validate.NotBlank; import\ncore.framework.api.validate.NotNull; public class CustomerCreatedMessage\n{ \\@NotNull \\@NotBlank \\@Property(name = \\\"email\\\") public String email;\n}\n\n### Publishing the Message\n\nIn order to have the ability to publish the message, we can use the\nKafka config on our `CustomerModule` in the `demo-service`, which has\nthe `demo-service-interface` as a dependency in gradle:\n\njavapackage app; import app.demo.api.CustomerWebService; import\napp.demo.api.customer.kafka.CustomerCreatedMessage; import\napp.demo.customer.domain.Customer; import\napp.demo.customer.job.SimpleJob; import\napp.demo.customer.service.CustomerService; import\napp.demo.customer.web.CustomerWebServiceImpl; import\ncore.framework.module.Module; import core.framework.scheduler.Job;\nimport java.time.Duration; import java.time.LocalTime; public class\nCustomerModule extends Module { \\@Override protected void initialize() {\nkafka().publish(\\\"customer-created\\\", CustomerCreatedMessage.class);\ndb().repository(Customer.class); bind(CustomerService.class);\napi().service(CustomerWebService.class,\nbind(CustomerWebServiceImpl.class)); Job simpleJob =\nbind(SimpleJob.class); schedule().fixedRate(\\\"simple-fixed\\\", simpleJob,\nDuration.ofMinutes(1)); schedule().dailyAt(\\\"simple-daily\\\", simpleJob,\nLocalTime.NOON); } }\n\nNotice we specify the Kafka topic name when we set up the publisher\nconfig. Before we publish a message, let\\'s also add the local docker\nKafka uri to our `sys.properties` file so the Kafka config knows where\nto reach the service:\n\nsys.jdbc.password=root\nsys.jdbc.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=utf-8\nsys.jdbc.user=root sys.kafka.uri=localhost:9092\n\nWe can now inject a `MessagePublisher` from\n`core.framework.kafka.MessagePublisher` into one of our services which\nwill allow us to publish a message to the \\'customer-created\\' topic.\nLet\\'s publish a message when a customer is created in our\n`CustomerService`:\n\njavapackage app.demo.customer.service; import\napp.demo.api.customer.CreateCustomerRequest; import\napp.demo.api.customer.CustomerView; import\napp.demo.api.customer.kafka.CustomerCreatedMessage; import\napp.demo.customer.domain.Customer; import core.framework.async.Executor;\nimport core.framework.db.Repository; import\ncore.framework.inject.Inject; import\ncore.framework.kafka.MessagePublisher; import\ncore.framework.util.Strings; import\ncore.framework.web.exception.ConflictException; import\ncore.framework.web.exception.NotFoundException; import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory; import java.time.Duration; import\njava.time.LocalDateTime; import java.util.Optional; public class\nCustomerService { private final Logger logger =\nLoggerFactory.getLogger(CustomerService.class); \\@Inject\nRepository\\<Customer\\> customerRepository; \\@Inject Executor executor;\n\\@Inject MessagePublisher\\<CustomerCreatedMessage\\>\ncustomerCreatedMessagePublisher; public CustomerView\ncreate(CreateCustomerRequest request) { Optional\\<Customer\\>\nexistingCustomer = customerRepository.selectOne(\\\"email = ?\\\",\nrequest.email); if (existingCustomer.isPresent()) { throw new\nConflictException(Strings.format(\\\"customer already exists, email={}\\\",\nrequest.email)); } Customer customer = new Customer(); customer.email =\nrequest.email; customer.firstName = request.firstName; customer.lastName\n= request.lastName; customer.updatedTime = LocalDateTime.now();\ncustomer.id = customerRepository.insert(customer).orElseThrow();\nexecutor.submit(\\\"normal-task\\\", () -\\> { logger.info(\\\"Customer\ncreated!\\\"); }); executor.submit(\\\"delayed-task\\\", () -\\> {\nlogger.info(\\\"Customer created about 10s ago!\\\"); },\nDuration.ofSeconds(10)); CustomerCreatedMessage createdMessage = new\nCustomerCreatedMessage(); createdMessage.email = customer.email;\ncustomerCreatedMessagePublisher.publish(createdMessage); return\nview(customer); } public CustomerView get(Long id) { Customer customer =\ncustomerRepository.get(id).orElseThrow(() -\\> new\nNotFoundException(Strings.format(\\\"customer not found, id={}\\\", id)));\nreturn view(customer); } private CustomerView view(Customer customer) {\nCustomerView result = new CustomerView(); result.id = customer.id;\nresult.email = customer.email; result.firstName = customer.firstName;\nresult.lastName = customer.lastName; result.updatedTime =\ncustomer.updatedTime; return result; } }\n\n### Subscribing to the Message\n\nIn addition to setting up the message publishing, we also use the Kafka\nconfig to subscribe to messages. Before we can subscribe to a message,\nhowever, we must define a message handler. In our `demo-service` let\\'s\ncreate a message handler as\n`app.demo.customer.kafka.CustomerMessageHandler`:\n\njavapackage app.demo.customer.kafka; import\napp.demo.api.customer.kafka.CustomerCreatedMessage; import\ncore.framework.kafka.MessageHandler; import core.framework.util.Strings;\nimport org.slf4j.Logger; import org.slf4j.LoggerFactory; public class\nCustomerCreatedMessageHandler implements\nMessageHandler\\<CustomerCreatedMessage\\> { private final Logger logger =\nLoggerFactory.getLogger(CustomerCreatedMessageHandler.class); \\@Override\npublic void handle(String key, CustomerCreatedMessage value) {\nlogger.info(Strings.format(\\\"Customer created, email={}\\\",\nvalue.email)); } }\n\nA proper handler must implement the\n`core.framework.kafka.MessageHandler` class for a given message and\noverride that class\\'s `handle` method.\n\nFor now, our handler will just log the email of the created customer\npublished on the `CustomerCreatedMessage`. With our handler setup, we\ncan now subscribe to the message in our `CustomerModule`:\n\njavapackage app; import app.demo.api.CustomerWebService; import\napp.demo.api.customer.kafka.CustomerCreatedMessage; import\napp.demo.customer.domain.Customer; import\napp.demo.customer.job.SimpleJob; import\napp.demo.customer.kafka.CustomerCreatedMessageHandler; import\napp.demo.customer.service.CustomerService; import\napp.demo.customer.web.CustomerWebServiceImpl; import\ncore.framework.module.Module; import core.framework.scheduler.Job;\nimport java.time.Duration; import java.time.LocalTime; public class\nCustomerModule extends Module { \\@Override protected void initialize() {\nkafka().publish(\\\"customer-created\\\", CustomerCreatedMessage.class);\nkafka().subscribe(\\\"customer-created\\\", CustomerCreatedMessage.class,\nbind(CustomerCreatedMessageHandler.class));\ndb().repository(Customer.class); bind(CustomerService.class);\napi().service(CustomerWebService.class,\nbind(CustomerWebServiceImpl.class)); Job simpleJob =\nbind(SimpleJob.class); schedule().fixedRate(\\\"simple-fixed\\\", simpleJob,\nDuration.ofMinutes(1)); schedule().dailyAt(\\\"simple-daily\\\", simpleJob,\nLocalTime.NOON); } }\n\nTo complete our subscription we have done the following:\n\n-   specified the topic that the message is published to (by convention\n    this is the dash-separated version of the message class name,\n    without \\\"message\\\". So, the `CustomerCreatedMessage` is published\n    to the \\'customer-created\\' topic)\n\n-   specified the message class `CustomerCreatedMessage`\n\n-   bound and specified our message handler class\n    `CustomerCreatedMessageHandler`\n\nBy default, Core-ng will setup a subscription to the\n\\'customer-created\\' topic with a consumer group id equal to the app\nname. Optionally, a consumer group Id can be manually specified via the\n`kafka().groupId(\"some-group-id\")` api. See\n`core.framework.module.KafkaConfig.java` for more detail.\n\nAnother detail worth noting is that in this particular case, because we\nhave only defined one service in our project, the `demo-service` is both\nthe publisher and a consumer of our `CustomerCreatedMessage`. Often, we\nwill want a different service to subscribe to our message, which in this\ncase is as simple as including the `demo-service-interface` as a\ndependency for that service and setting up a message handler as\ndescribed above.\n\n### Testing our Kafka Setup.\n\nStart the app via the gradle menu by launching the task `demo-service`\n-\\> `Tasks` -\\> `application` -\\> `run`. Now let\\'s create a customer:\n\nbash\\> curl \\--header \\\"Content-Type: application/json\\\" \\\\ \\--request\nPOST \\\\ \\--data \\'{\\\"first_name\\\": \\\"Charlie\\\", \\\"last_name\\\": \\\"Fox\\\",\n\\\"email\\\": \\\"charlie@remarkablefoods.com\\\"}\\' \\\\\n\\<http://localhost:8080/customer\\> \\| json_pp\n\nYou should then see our subscribed handler log the the email of the\ncreated customer:\n\n2020-08-05T16:28:57.847513Z \\[Charlies-MacBook-Pro.local\\]\n\\[kafka-listener-0\\] INFO a.d.c.kafka.CustomerCreatedMessageHandler -\nCustomer created, email=charlie@remarkablefoods.com\n2020-08-05T16:28:57.849877Z \\[Charlies-MacBook-Pro.local\\]\n\\[kafka-listener\\] INFO c.f.i.kafka.MessageListenerThread - process\nkafka records, count=1, size=39, elapsed=4235882\n\nWe\\'ve successfully published and subscribed to a Kafka message/topic\nwith Core-ng!"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.6 - Running Core-NG projects locally."}, {"role": "assistant", "content": "**Introduction**\n\nThis guide will show how to run `core-ng` projects locally so that you\ncan debug, put breakpoints and **step through your code** to test your\nchanges by hitting the endpoint locally and stepping through the code to\nensure changes made function as intended. This example has been made\nusing `foodtruck-chef-app`.\n\nOne of the biggest pain points to running the `foodtruck-chef-app`\nlocally is the authentication. In the `foodtruck-chef-app` there is a a\nlogin interceptor that calls the `SessionsV2` service-class that calls\nthe `identity-service` to return a `LoginUserV2` object. That object is\ninjected into the context to provide details on the currently logged in\nuser and is used to allow the passage of protected REST API endpoints.\n\nTo solve the issue of having to mock `identity-service` we will be using\na hack-y trick where we return our own `LoginUserV2` object so we can\nhave access to API endpoints.\n\n**Pre-requisites**\n\n-   Docker Compose\n\n-   In your `/etc/hosts` file add the following:\n\n    -   127.0.0.1 test.foodtruck-qa.com 127.0.0.1 test.foodtruck-uat.com\n        127.0.0.1 kafka-0.kafka.dev.svc.cluster.local\n        kafka-v2-0.kafka-v2.uat.svc.cluster.local\n        kafka-v2-0.kafka-v2.staging.svc.cluster.local\n        kafka-0.kafka.prod.svc.cluster.local 127.0.0.1 kafka\n        elasticsearch\n\n-   **Running Locally**\n\n-   Load the `foodtruck-chef-app` project\n\n-   In the terminal type `make up`\n\n    1.  This should spin up the whole infrastructure required by\n        `foodtruck-chef-app`\n\n    2.  Use `docker ps` to verify all containers are running and re-run\n        the make if some containers fail to run.\n\n-   In the\n    `chef-site/src/main/java/app/chefsite/web/interceptor/LoginInterceptor.java`\n    replace the `intercept` method with the following method:\\\n\n    \\@Override public Response intercept(Invocation invocation) throws\n    Exception { if (invocation.annotation(LoginRequired.class) != null)\n    { LoginUserV2.UserPermission permissions = new\n    LoginUserV2.UserPermission(); permissions.isSuperAdmin = true;\n    LoginUserV2.UserPermission.Role role = new\n    LoginUserV2.UserPermission.Role(); role.roleId = \\\"1\\\"; role.appCode\n    = \\\"RANDOM_APP_CODE\\\"; role.roleName = \\\"role-user\\\"; role.appName =\n    \\\"role-app\\\"; List\\<LoginUserV2.UserPermission.Role\\> roleList = new\n    ArrayList\\<\\>(); roleList.add(role); permissions.roles = roleList;\n    LoginUserV2 loginUser = new LoginUserV2(); loginUser.id = \\\"1\\\";\n    loginUser.userPermission = permissions; loginUser.email =\n    \\\"YOUR@EMAIL\\\"; loginUser.fullName = \\\"YOUR_NAME\\\";\n    invocation.context().put(Contexts.CURRENT_USER, loginUser); } return\n    invocation.proceed(); }\n\n    This\n\n-   In the\n    `chef-site/src/main/java/app/chefsite/web/interceptor/AuthenticationInterceptor.java`\n    replace the `intercept` method with the following method:\\\n\n    \\@Override public Response intercept(Invocation invocation) throws\n    Exception { return invocation.proceed(); }\n\n-   Then in the `Main.java` you can run the main method in debug mode,\n    add breakpoints and hit the API\n\nDon't forget to port forward to any services your API endpoint calls.\n\nAfter doing this, check the `helmfile.yaml` and locate the `targetPort`.\nThe target port will be needed for the API call. In the case of the\n`foodtruck-chef-app` the `targetPort` is `8443`.\n\nNow you can make HTTP calls to the server. The following URL is an\nexample I hit using Postman:\n\n`https://test.foodtruck-qa.com:8443/ajax/user/current`\n\nThis the returns the payload for that endpoint and from there you should\nbe good to go."}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: 1.7 - API Rate Limiting."}, {"role": "assistant", "content": "### how to use\n\n`background: use the @LimitRate`\n\njava@Target({TYPE, METHOD}) \\@Retention(RUNTIME) public \\@interface\nLimitRate { String value(); }\n\njava// first step: config limit rate in module\nhttp().limitRate().add(\\\"group-name\\\", 5, 20, TimeUnit.MINUTES);\n\njava// second: API declaration public class ServiceImpl implements\nWebService { \\@LimitRate(\\\"group-name\\\") \\@Override public Response\nmethodName(Request request) { return null; } }\n\n### what it happens\n\n-   when it config\n\njavapublic final class HTTPConfig extends Config { \\... public\nLimitRateConfig limitRate() { return\ncontext.config(LimitRateConfig.class, null); } \\... }\n\njavapublic final class LimitRateConfig extends Config { private boolean\nrateControlGroupAdded; private RateControl rateControl; \\@Override\nprotected void initialize(ModuleContext context, String name) {\nrateControl = context.httpServer.handler.rateControl; // new object when\ncreate HttpHandler // save at max 5K group/ip combination per pod, about\n800K memory, to adapt with more ips/cc attack, better defense with cloud\ninfra based solution together maxEntries(5000);\ncontext.httpServerConfig.interceptors.add(new\nLimitRateInterceptor(rateControl)); // use Interceptor to do the rate\nlimit } \\@Override protected void validate() { if\n(!rateControlGroupAdded) { throw new Error(\\\"limitRate is configured but\nno group added, please remove unnecessary config\\\"); } } // how many\ngroup/ip combinations to keep, 5000 is about 800K, 10K is about 1.8M\npublic void maxEntries(int entries) { rateControl.maxEntries(entries); }\n// maintain maxPermits at most, fill permits by fillRate per interval //\ne.g. add(\\\"group\\\", 10, 5, Duration.ofSeconds(1)) keeps 10 permits at\nmost, fills 5 permits every second // e.g. add(\\\"group\\\", 20, 10,\nDuration.ofMinutes(5)) keeps 20 permits at most, fills 10 permits every\n5 minutes public void add(String group, int maxPermits, int fillRate,\nDuration interval) { rateControl.config(group, maxPermits, fillRate,\ninterval); rateControlGroupAdded = true; } }\n\n-   how it works\n\njavapublic class LimitRateInterceptor implements Interceptor { private\nfinal RateControl rateControl; public LimitRateInterceptor(RateControl\nrateControl) { this.rateControl = rateControl; } \\@Override public\nResponse intercept(Invocation invocation) throws Exception { LimitRate\nlimitRate = invocation.annotation(LimitRate.class); if (limitRate !=\nnull) { String group = limitRate.value(); String clientIP =\ninvocation.context().request().clientIP();\nrateControl.validateRate(group, clientIP); } return\ninvocation.proceed(); } }\n\njavapublic class RateControl { private final Logger logger =\nLoggerFactory.getLogger(RateControl.class); public Map\\<String,\nRateConfig\\> config; private Map\\<String, Rate\\> rates; public void\nmaxEntries(int entries) { synchronized (this) { rates = new\nLRUMap\\<\\>(entries); // memory consideration } } public void\nconfig(String group, int maxPermits, int fillRate, Duration interval) {\nif (config == null) config = Maps.newHashMap(); double fillRatePerNano =\nratePerNano(fillRate, interval); RateConfig previous = config.put(group,\nnew RateConfig(maxPermits, fillRatePerNano)); if (previous != null)\nthrow new Error(\\\"found duplicate group, group=\\\" + group); } public\nvoid validateRate(String group, String clientIP) {\nlogger.debug(\\\"acquire, group={}, clientIP={}\\\", group, clientIP);\nboolean acquired = acquire(group, clientIP); if (!acquired) { throw new\nTooManyRequestsException(\\\"rate exceeded\\\"); } } double ratePerNano(int\nrate, Duration interval) { return rate / (double) interval.toNanos(); }\nboolean acquire(String group, String clientIP) { RateConfig config =\nthis.config.get(group); if (config == null) { logger.warn(\\\"can not find\ngroup, group={}\\\", group); return true; // skip if group is not defined\n} String key = group + \\\"/\\\" + clientIP; Rate rate; synchronized (this)\n{ rate = rates.computeIfAbsent(key, k -\\> new Rate(config.maxPermits));\n} long currentTime = System.nanoTime(); return rate.acquire(currentTime,\nconfig.maxPermits, config.fillRatePerNano); } record RateConfig(int\nmaxPermits, double fillRatePerNano) { } static final class Rate {\nvolatile double currentPermits; volatile long lastUpdateTime; Rate(int\ncurrentPermits) { this.currentPermits = currentPermits;\nthis.lastUpdateTime = System.nanoTime(); } // under multi-thread\ncondition, the order of acquires are not determined, currentTime can be\nearlier than lastUpdateTime (e.g. lastUpdateTime was updated by a later\nacquire first) boolean acquire(long currentTime, int maxPermits, double\nfillRatePerNano) { synchronized (this) { long timeElapsed = Math.max(0,\ncurrentTime - lastUpdateTime); currentPermits = Math.min(maxPermits,\ncurrentPermits + fillRatePerNano \\* timeElapsed); lastUpdateTime =\nlastUpdateTime + timeElapsed; if (currentPermits \\>= 1) { currentPermits\n-= 1; return true; } else { return false; } } } } }\n\n### Summary\n\n-   The rate limiting implemented by the token bucket algorithm.And only\n    applies to single instance, if there are multiple instances, other\n    methods are needed.\n\n-   Due to the use of LRUMap, the least recently accessed Rate object in\n    rates will be deleted. The rate limit may be inaccurate if removed\n    and re-added frequently, but the probability is low. The default\n    maximum length is now 5000, which is generally sufficient.\n\n-   The key of rate object is group/clientIP,that is, maximum number of\n    requests for a service api within 1s = number of clients x maximum\n    number of requests configured."}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example build a new module named example."}, {"role": "assistant", "content": "Assume that we have a project named example-project, and the work tree\nlike this:\n\n. ├── backend │   ├── example-service │   │   ├── conf │   │   ├──\ndocker │   │   └── src │   │   ├── main │   │   │   ├── java │   │   │  \n│   └── app │   │   │   │   └── example │   │   │   │ └──\nExampleApp.java │   │   │   ├── Main.java\n\nStep1. Create ExampleModule.java in the directory\n` ./backend/example-service/src/main/java/app/example`, the code is as\nbelow:\n\npackage app.example; import core.framework.module.Module; /\\*\\* \\*\n\\@author AI full stack engineer - Cter \\*/ public class ExampleModule\nextends Module { \\@Override protected void initialize() { } }\n\nYou can load other module, bind service, bind api service or bind kafka\nhandler in the override method initialize.\n\nStep2. Load this module in the ExampleApp.java method initialize\n\npublic class ExampleApp extends App { \\... \\@Override protected void\ninitialize() { \\... load(new ExampleModule()); \\... } \\... }\n\nDone"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example setup a scheduler job in individual scheduler-service."}, {"role": "assistant", "content": "For example, we want to inactive HDR every day at 06:00.\n\nFirst, we need to trigger a message in scheduler-service at every day\n06:00, to do these:\n\nStep1. define a Kafka message like this:\n\npackage app.kms.kafka; /\\*\\* \\* \\@author Jun \\*/ public class\nAutoInactiveTestingHDRMessage { }\n\nStep2. add schedule job in the scheduler module like this:\n\npackage app.scheduler; import\napp.scheduler.kitchenmanagement.AutoInactiveTestingHDRJob; import\ncore.framework.async.Executor; import core.framework.module.Module;\nimport java.time.Duration; import java.time.LocalDateTime; import\njava.time.LocalTime; import java.time.ZonedDateTime; /\\*\\* \\* \\@author\neden \\*/ public class KitchenManagementSchedulerModule extends Module {\n\\@Override protected void initialize() { \\...\nkafka().publish(HDRTopic.AUTO_INACTIVE_TESTING_HDR_EVENT,\nAutoInactiveTestingHDRMessage.class);\nschedule().dailyAt(\\\"auto-inactive-testing-hdr-job\\\",\nbind(AutoInactiveTestingHDRJob.class), LocalTime.of(6, 0)); \\...\n\nSecond, add jobs like this:\n\npackage app.scheduler.kitchenmanagement; import\napp.kms.kafka.AutoInactiveTestingHDRMessage; import\ncore.framework.inject.Inject; import\ncore.framework.kafka.MessagePublisher; import\ncore.framework.scheduler.Job; import\ncore.framework.scheduler.JobContext; /\\*\\* \\* \\@author Jun \\*/ public\nclass AutoInactiveTestingHDRJob implements Job { \\@Inject\nMessagePublisher\\<AutoInactiveTestingHDRMessage\\> publisher; \\@Override\npublic void execute(JobContext context) throws Exception {\npublisher.publish(new AutoInactiveTestingHDRMessage()); } }\n\nLast, consume this message and handle it like this:\n\npackage app.kms.hdr.kafka; import app.kms.hdr.service.BOHDRServiceV3;\nimport app.kms.kafka.AutoInactiveTestingHDRMessage; import\ncore.framework.inject.Inject; import\ncore.framework.internal.log.LogManager; import\ncore.framework.kafka.MessageHandler; import\ncore.framework.log.ActionLogContext; import javax.annotation.Nullable;\n/\\*\\* \\* \\@author Jun \\*/ public class\nAutoInactiveTestingHDRMessageHandler implements\nMessageHandler\\<AutoInactiveTestingHDRMessage\\> { \\@Inject\nBOHDRServiceV3 bohdrServiceV3; \\@Override public void handle(@Nullable\nString key, AutoInactiveTestingHDRMessage value) {\nActionLogContext.put(\\\"operator\\\", \\\"System\\\");\nbohdrServiceV3.autoInactiveTestingHDR(\\\"System\\\", LogManager.APP_NAME);\n} }"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example register an API client and call an endpoint in it."}, {"role": "assistant", "content": "For example, Assume we want to call TagWebService#getTag in ExampleApp,\nwe need to:\n\nFirst, add package dependency in gradle if required.\n\nSecond, register in the module's `intialize` method like this:\n\n\\... api().client(TagWebService.class,\nrequiredProperty(\\\"app.recipeV2.serviceURL\\\")); \\...\n\nLast, inject in service and call like this:\n\n\\... //inject web client public class CookingGroupValidationService {\n\\@Inject TagWebService tagWebService; public Map\\<String, String\\>\ngetCooking(String tagId) { \\... // call endpoint var tag =\ntagWebService.getTag(tagId); // other logic \\... }\n\nDone"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example define a mysql domain."}, {"role": "assistant", "content": "In the CoreNG framework, use annotation \\@Column to define a column, use\nannotation \\@PrimaryKey to define the primary column, and use annotation\n\\@Table to define a MySQL table.\n\nHere is an example:\n\npackage app.kos.domain; import core.framework.api.validate.NotNull;\nimport core.framework.db.Column; import core.framework.db.PrimaryKey;\nimport core.framework.db.Table; import java.time.ZonedDateTime; /\\*\\* \\*\n\\@author harry \\*/ \\@Table(name = \\\"cash_payments\\\") public class\nCashPayment { \\@PrimaryKey \\@Column(name = \\\"id\\\") public String id;\n\\@NotNull \\@Column(name = \\\"order_id\\\") public String orderId; \\@NotNull\n\\@Column(name = \\\"cash_amount\\\") public Double cashAmount; \\@NotNull\n\\@Column(name = \\\"created_by\\\") public String createdBy; \\@NotNull\n\\@Column(name = \\\"created_time\\\") public ZonedDateTime createdTime;\n\\@NotNull \\@Column(name = \\\"updated_by\\\") public String updatedBy;\n\\@NotNull \\@Column(name = \\\"updated_time\\\") public ZonedDateTime\nupdatedTime; }\n\nThe corresponding flyway SQL script is:\n\nCREATE TABLE IF NOT EXISTS \\`cash_payments\\` ( \\`id\\` VARCHAR(50) NOT\nNULL, \\`order_id\\` VARCHAR(50) NOT NULL, \\`cash_amount\\` DECIMAL(10, 2)\nNOT NULL, \\`created_time\\` TIMESTAMP(6) NOT NULL DEFAULT\nCURRENT_TIMESTAMP(6), \\`created_by\\` VARCHAR(50) NOT NULL,\n\\`updated_time\\` TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),\n\\`updated_by\\` VARCHAR(50) NOT NULL, PRIMARY KEY (\\`id\\`), INDEX\n\\`cash_payment_order_id\\` (\\`order_id\\` ASC) ) ENGINE = InnoDB;"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example define a mongo domain."}, {"role": "assistant", "content": "In CoreNG, using annotation \\@Field to define a field of a collection,\nusing annotation \\@Id to define the primary field, using annotation\n\\@Collection with name value to define the collection name, using\nannotation MongoEnumValue to define an enum value.\n\nExample:\n\npackage app.kms.exceptionoperationhour.collection; import\ncore.framework.api.validate.NotNull; import\ncore.framework.mongo.Collection; import core.framework.mongo.Field;\nimport core.framework.mongo.Id; import\ncore.framework.mongo.MongoEnumValue; import java.time.ZonedDateTime;\n/\\*\\* \\* \\@author stephen \\*/ \\@Collection(name =\n\\\"exception_operation_hours\\\") public class ExceptionOperationHour {\n\\@Id \\@Field(name = \\\"\\_id\\\") public String id; \\@NotNull \\@Field(name =\n\\\"resource_id\\\") public String resourceId; \\@NotNull \\@Field(name =\n\\\"resource_type\\\") public ResourceType resourceType; \\@NotNull\n\\@Field(name = \\\"operate_type\\\") public OperateType operateType;\n\\@NotNull \\@Field(name = \\\"duration_type\\\") public DurationType\ndurationType; \\@NotNull \\@Field(name = \\\"start_time\\\") public\nZonedDateTime startTime; \\@NotNull \\@Field(name = \\\"end_time\\\") public\nZonedDateTime endTime; \\@NotNull \\@Field(name = \\\"expiration_time\\\")\npublic ZonedDateTime expirationTime; \\@Field(name = \\\"reason\\\") public\nString reason; \\@Field(name = \\\"operator\\\") public String operator;\n\\@NotNull \\@Field(name = \\\"created_by\\\") public String createdBy;\n\\@NotNull \\@Field(name = \\\"created_time\\\") public ZonedDateTime\ncreatedTime; \\@NotNull \\@Field(name = \\\"updated_by\\\") public String\nupdatedBy; \\@NotNull \\@Field(name = \\\"updated_time\\\") public\nZonedDateTime updatedTime; public enum DurationType {\n\\@MongoEnumValue(\\\"TIME_RANGE\\\") TIME_RANGE,\n\\@MongoEnumValue(\\\"REST_OF_THE_DATE\\\") REST_OF_THE_DATE } public enum\nResourceType { \\@MongoEnumValue(\\\"HDR\\\") HDR,\n\\@MongoEnumValue(\\\"HDR_RESTAURANT\\\") HDR_RESTAURANT } public enum\nOperateType { \\@MongoEnumValue(\\\"CLOSE\\\") CLOSE,\n\\@MongoEnumValue(\\\"PAUSE\\\") PAUSE, \\@MongoEnumValue(\\\"POSTPONE\\\")\nPOSTPONE } }"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example add cache for a domain."}, {"role": "assistant", "content": "To add cache for a domain, for example, let's build OrderChargeCache for\ndomain OrderCharge:\n\npackage app.kos.domain; import core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull; import\ncore.framework.db.Column; import core.framework.db.PrimaryKey; import\ncore.framework.db.Table; import java.time.ZonedDateTime; /\\*\\* \\*\n\\@author Victor \\*/ \\@Table(name = \\\"order_charges\\\") public class\nOrderCharge { \\@PrimaryKey \\@Column(name = \\\"id\\\") public String id;\n\\@NotNull \\@NotBlank \\@Column(name = \\\"order_id\\\") public String\norderId; \\@NotNull \\@Column(name = \\\"subtotal\\\") public Double subtotal;\n\\@Column(name = \\\"bundle_discount\\\") public Double bundleDiscount;\n\\@Column(name = \\\"tax\\\") public Double tax; \\@Column(name = \\\"tip\\\")\npublic Double tip; \\@Column(name = \\\"service_fee\\\") public Double\nserviceFee; \\@Column(name = \\\"delivery_fee\\\") public Double deliveryFee;\n\\@Column(name = \\\"fast_pass_fee\\\") public Double fastPassFee;\n\\@Column(name = \\\"small_order_fee\\\") public Double smallOrderFee;\n\\@Column(name = \\\"hospitality_fee\\\") public Double hospitalityFee;\n\\@NotNull \\@Column(name = \\\"created_time\\\") public ZonedDateTime\ncreatedTime; \\@NotNull \\@Column(name = \\\"created_by\\\") public String\ncreatedBy; \\@NotNull \\@Column(name = \\\"updated_time\\\") public\nZonedDateTime updatedTime; \\@NotNull \\@Column(name = \\\"updated_by\\\")\npublic String updatedBy; }\n\nFirst, we must define a cache class in the cache directory, and the\nproperties are what we need:\n\npackage app.kos.cache; import core.framework.api.json.Property; import\ncore.framework.api.validate.NotBlank; import\ncore.framework.api.validate.NotNull; /\\*\\* \\* \\@author Yanni \\*/ public\nclass OrderChargeCache { \\@NotNull \\@NotBlank \\@Property(name = \\\"id\\\")\npublic String id; \\@NotNull \\@NotBlank \\@Property(name = \\\"order_id\\\")\npublic String orderId; \\@NotNull \\@Property(name = \\\"sub_total\\\") public\nDouble subTotal; \\@Property(name = \\\"bundle_discount\\\") public Double\nbundleDiscount; \\@Property(name = \\\"tax\\\") public Double tax;\n\\@Property(name = \\\"tip\\\") public Double tip; \\@Property(name =\n\\\"service_fee\\\") public Double serviceFee; \\@Property(name =\n\\\"delivery_fee\\\") public Double deliveryFee; \\@Property(name =\n\\\"fast_pass_fee\\\") public Double fastPassFee; }\n\nSecond, create OrderChargeCacheService to load the domain instance to\nRedis through Cache\\<OrderChargeCache\\>:\n\npackage app.kos.cache; import app.kos.domain.OrderCharge; import\ncore.ext.db.RetryRepository; import core.framework.cache.Cache; import\ncore.framework.inject.Inject; import java.util.List; import\njava.util.Map; import java.util.function.Function; import\njava.util.stream.Collectors; /\\*\\* \\* \\@author Yanni \\*/ public class\nOrderChargeCacheService { \\@Inject Cache\\<OrderChargeCache\\>\norderChargeCache; \\@Inject RetryRepository\\<OrderCharge\\>\norderChargeRetryRepository; public Map\\<String, OrderChargeCache\\>\nbulkGet(List\\<String\\> orderIds) { if (orderIds == null \\|\\|\norderIds.isEmpty()) return Map.of(); return\norderChargeCache.getAll(orderIds, this::load).values().stream()\n.collect(Collectors.toMap(o -\\> o.orderId, Function.identity(), (v1, v2)\n-\\> v2)); } public void evict(String orderId) {\norderChargeCache.evict(orderId); } private OrderChargeCache load(String\norderId) { var optional =\norderChargeRetryRepository.selectOne(\\\"order_id = ?\\\", orderId); if\n(optional.isEmpty()) { return new OrderChargeCache(); } var cache = new\nOrderChargeCache(); OrderCharge orderCharge = optional.get(); cache.id =\norderCharge.id; cache.orderId = orderCharge.orderId; cache.subTotal =\norderCharge.subtotal; cache.bundleDiscount = orderCharge.bundleDiscount;\ncache.tax = orderCharge.tax; cache.tip = orderCharge.tip;\ncache.serviceFee = orderCharge.serviceFee; cache.deliveryFee =\norderCharge.deliveryFee; cache.fastPassFee = orderCharge.fastPassFee;\nreturn cache; } }\n\nThen, register it and define cache duration in the App initialize method\nlike this:\n\ncache().add(OrderChargeCache.class, Duration.ofMinutes(10));\n\nLast, use the get or bulkGet method when needed like this:\n\nvar chargeMap = orderChargeCacheService.bulkGet(orderIds);"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example publish kafka message."}, {"role": "assistant", "content": "To publish a Kafka message for example when the hdr configuration is\nupdated in CoreNG you need to:\n\nFirst, define a message in the API package like:\n\npackage app.kms.kafka; import core.framework.api.json.Property; import\ncore.framework.api.validate.NotNull; /\\*\\* \\* \\@author stephen \\*/\npublic class HDRConfigurationUpdatedMessage { \\@NotNull \\@Property(name\n= \\\"event_type\\\") public EventType eventType = EventType.UPDATED; public\nenum EventType { \\@Property(name = \\\"UPDATED\\\") UPDATED } }\n\nSecond, register in the module's initialize method like this:\n\n\\... kafka().publish(HDRTopic.HDR_CONFIGURATION_UPDATED_EVENT,\nHDRConfigurationUpdatedMessage.class); \\...\n\nLast, publish when the HDR configuration updated message like this:\n\n\\... private void updateHDRConfiguration(String hdrId, SuperPodBuilder\nbuilder, BOApplyLayoutRequest request) { \\...\nhdrConfigurationCollection.replace(hdrConfiguration);\nhdrConfigurationUpdatedMessagePublisher.publish(hdrId, new\nHDRConfigurationUpdatedMessage()); } \\...\n\nDone."}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example subscribe and handle a Kafka message."}, {"role": "assistant", "content": "To subscribe to a Kafka message for example\nHDRConfigurationUpdatedMessage we need:\n\nFirst, add package dependency in `build.gradle.kts` if needed\n\nSecond, subscribe it in the module's initialize method like this:\n\n\\... kafka().subscribe(HDRTopic.HDR_CONFIGURATION_UPDATED_EVENT,\nHDRConfigurationUpdatedMessage.class,\nbind(HDRConfigurationUpdatedMessageHandler.class)); \\...\n\nLast, implement handler like this:\n\npackage app.kos.kafka; import\napp.kms.kafka.HDRConfigurationUpdatedMessage; import\napp.kos.cache.HDRConfigurationCacheService; import\ncore.framework.inject.Inject; import\ncore.framework.kafka.MessageHandler; import\ncore.framework.log.ActionLogContext; import javax.annotation.Nullable;\n/\\*\\* \\* \\@author Yanni \\*/ public class\nHDRConfigurationUpdatedMessageHandler implements\nMessageHandler\\<HDRConfigurationUpdatedMessage\\> { \\@Inject\nHDRConfigurationCacheService hdrConfigurationCacheService; \\@Override\npublic void handle(@Nullable String hdrId,\nHDRConfigurationUpdatedMessage value) throws Exception {\nActionLogContext.put(\\\"hdr_id\\\", hdrId); if (value.eventType ==\nHDRConfigurationUpdatedMessage.EventType.UPDATED) {\nhdrConfigurationCacheService.evict(hdrId); } } }"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example add and load self-defined properties."}, {"role": "assistant", "content": "Assuming we have properties that need to be defined and it does not\nbelong to any other existing properties , we need to add a file named\nexample.properties in `/path/to/servier/conf/qa/example.properties` ,\ncontent like this:\n\nexample.property.key=value\n\nwe also need to add this file in `/path/to/servier/conf/uat` and\n`/path/to/servier/conf/prod` and `/path/to/service/src/main/resources` ,\ncore-ng will check the property existed in the all env property file,\nand we must keep the properties in the files are all order the same.\n\nThen, load and use it like this:\n\n\\... // load property file loadProperties(\\\"app.properties\\\"); \\... \\...\n// use property using key requiredProperty(\\\"example.property.key\\\")\n\\...\n\nDone"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "CoreNG article: CoreNG Example define post release controller."}, {"role": "assistant", "content": "To set up a post-release controller we need to add a file named\nExampleController.java in\n`/path/to/service/src/main/java/app/controller/ExampleController.java`,\nwith content like this:\n\npackage app.kms.datasync.controller; import\ncore.framework.web.Controller; import core.framework.web.Request; import\ncore.framework.web.Response; /\\*\\* \\* \\@author Stephen \\*/ public class\nExampleController implements Controller { \\@Override public Response\nexecute(Request request) throws Exception { //do post release logic\nreturn Response.text(\\\"OK\\\"); } }"}]}
