{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "In the CoreNG framework, how is an interface defined by CoreAPI?"}, {"role": "assistant", "content": "Example: \napi class example:\n```java\npackage app.kos.service.api;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.DELETE;\nimport core.framework.api.web.service.GET;\nimport core.framework.api.web.service.POST;\nimport core.framework.api.web.service.PUT;\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.api.web.service.ResponseStatus;\n\n/**  \n* @author stephen  \n*/ \npublic interface RunnerScannerWebService {\n    @POST\n    @ResponseStatus(HTTPStatus.CREATED)\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    void create(@PathParam(\"hdrId\") String hdrId, CreateScannerRequest request);\n    \n    @DELETE\n    @Path(\"/runner-scanner/scanner/:id\")\n    void delete(@PathParam(\"id\") String id);\n    \n    @PUT\n    @Path(\"/runner-scanner/scanner/:id\")\n    void update(@PathParam(\"id\") String id, UpdateScannerRequest request);\n\n    @GET\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    ListScannerResponse list(@PathParam(\"hdrId\") String hdrId);\n} \n```\nrequest class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class UpdateScannerRequest {\n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n\n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n\n    @NotNull\n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n``` \nresponse class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotNull;\nimport java.util.List;\n\n/**  \n* @author stephen  \n*/ \npublic class ListScannerResponse {\n    @NotNull\n    @Property(name = \"scanners\")\n    public List<ScannerView> scanners = List.of();\n} \n``` \nview class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class ScannerView { \n    @NotBlank\n    @Property(name = \"id\")\n    public String id;\n       \n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n \n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n     \n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n```\n"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-api."}, {"role": "assistant", "content": "Here is the source code of package core-ng-api:\ntree /mnt/d/wonder-core-ng-project/core-ng-api/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-api/src/main/java\n├── core\n│   └── framework\n│       └── api\n│           ├── http\n│           │   └── HTTPStatus.java\n│           ├── json\n│           │   └── Property.java\n│           ├── validate\n│           │   ├── Digits.java\n│           │   ├── Max.java\n│           │   ├── Min.java\n│           │   ├── NotBlank.java\n│           │   ├── NotNull.java\n│           │   ├── Pattern.java\n│           │   └── Size.java\n│           └── web\n│               └── service\n│                   ├── DELETE.java\n│                   ├── GET.java\n│                   ├── PATCH.java\n│                   ├── POST.java\n│                   ├── PUT.java\n│                   ├── Path.java\n│                   ├── PathParam.java\n│                   ├── QueryParam.java\n│                   └── ResponseStatus.java\n└── module-info.java\n\n9 directories, 19 files\n\nHTTPStatus.java\n```java\npackage core.framework.api.http;\n\n/**\n * @author neo\n */\npublic enum HTTPStatus {\n    OK(200),\n    CREATED(201),\n    ACCEPTED(202),\n    NO_CONTENT(204),\n    MOVED_PERMANENTLY(301),\n    FOUND(302),     // 302 Moved Temporarily, sometimes Found\n    SEE_OTHER(303),\n    NOT_MODIFIED(304),\n    TEMPORARY_REDIRECT(307),\n    PERMANENT_REDIRECT(308),\n    BAD_REQUEST(400),\n    UNAUTHORIZED(401),\n    FORBIDDEN(403),\n    NOT_FOUND(404),\n    METHOD_NOT_ALLOWED(405),\n    NOT_ACCEPTABLE(406),\n    CONFLICT(409),\n    GONE(410),\n    PRECONDITION_FAILED(412),\n    UNPROCESSABLE_ENTITY(422),\n    UPGRADE_REQUIRED(426),\n    TOO_MANY_REQUESTS(429),\n    INTERNAL_SERVER_ERROR(500),\n    BAD_GATEWAY(502),\n    SERVICE_UNAVAILABLE(503),\n    GATEWAY_TIMEOUT(504);\n\n    public final int code;\n\n    HTTPStatus(int code) {\n        this.code = code;\n    }\n}\n```\n\nProperty.java\n```java\npackage core.framework.api.json;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Property {\n    String name();\n}\n```\n\nDigits.java\n```java\npackage core.framework.api.validate;\n\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Digits can be used on numeric fields.\n *\n * @author chris\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Digits {\n    int integer() default -1; // maximum number of integral digits accepted for this number\n\n    int fraction() default -1; // maximum number of fractional digits accepted for this number\n\n    String message() default \"field out of bounds (<{integer} digits>.<{fraction} digits> expected), value={value}\";\n}\n```\n\nMax.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Max {\n    double value();\n\n    String message() default \"field must not be greater than {max}, value={value}\";\n}\n```\n\nMin.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Min {\n    double value();\n\n    String message() default \"field must not be less than {min}, value={value}\";\n}\n```\n\nNotBlank.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * used for String field, to check string is not blank, be aware of null is not treated as blank,\n * this is to validate if the value presents, it must not be blank string\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotBlank {\n    String message() default \"field must not be blank\";\n}\n```\n\nNotNull.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotNull {\n    String message() default \"field must not be null\";\n}\n```\n\nPattern.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Pattern {\n    String value();\n\n    String message() default \"field must match /{pattern}/, value={value}\";\n}\n```\n\nSize.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Size is used on String, List and Map.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Size {\n    int min() default -1;\n\n    int max() default -1;\n\n    String message() default \"size must be between {min} and {max}, size={value}\";\n}\n```\n\nDELETE.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface DELETE {\n}\n```\n\nGET.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface GET {\n}\n```\n\nPATCH.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PATCH {\n}\n```\n\nPath.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface Path {\n    String value();\n}\n```\n\nPathParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(PARAMETER)\n@Retention(RUNTIME)\npublic @interface PathParam {\n    String value();\n}\n```\n\nPOST.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface POST {\n}\n```\n\nPUT.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PUT {\n}\n```\n\nQueryParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface QueryParam {\n    String name();\n}\n```\n\nResponseStatus.java\n```java\npackage core.framework.api.web.service;\n\nimport core.framework.api.http.HTTPStatus;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target({TYPE, METHOD})\n@Retention(RUNTIME)\npublic @interface ResponseStatus {\n    HTTPStatus value() default HTTPStatus.OK;\n}\n```\n\nmodule-info.java\n```java\nmodule core.framework.api {\n    exports core.framework.api.web.service;\n    exports core.framework.api.http;\n    exports core.framework.api.json;\n    exports core.framework.api.validate;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-json."}, {"role": "assistant", "content": "Here is the source code of package core-ng-json:\ntree /mnt/d/wonder-core-ng-project/core-ng-json/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-json/src/main/java\n└── core\n    └── framework\n        ├── internal\n        │   └── json\n        │       ├── JSONAnnotationIntrospector.java\n        │       ├── JSONMapper.java\n        │       ├── JSONReader.java\n        │       └── JSONWriter.java\n        └── json\n            └── JSON.java\n\n6 directories, 5 files\n\nJSONAnnotationIntrospector.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedClass;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport core.framework.api.json.Property;\n\nimport java.io.Serial;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class JSONAnnotationIntrospector extends AnnotationIntrospector {\n    @Serial\n    private static final long serialVersionUID = 3638140740110527623L;\n\n    @Override\n    public Version version() {\n        return Version.unknownVersion();\n    }\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    @Override\n    public String[] findEnumValues(MapperConfig<?> config, AnnotatedClass annotatedClass, Enum<?>[] enumValues, String[] names) {\n        Map<String, String> mappings = null;\n        for (AnnotatedField field : annotatedClass.fields()) {\n            if (!field.getAnnotated().isEnumConstant()) continue;\n\n            Property enumValue = field.getAnnotation(Property.class);\n            if (enumValue == null) continue;\n\n            String value = enumValue.name();\n            if (value.isEmpty()) continue;\n\n            if (mappings == null) mappings = new HashMap<>();\n            mappings.put(field.getName(), value);\n        }\n\n        if (mappings != null) {\n            int length = enumValues.length;\n            for (int i = 0; i < length; i++) {\n                String name = enumValues[i].name();\n                String value = mappings.get(name);\n                if (value != null) names[i] = value;\n            }\n        }\n        return names;\n    }\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    private PropertyName propertyName(Annotated annotated) {\n        Property element = annotated.getAnnotation(Property.class);\n        if (element != null) {\n            return new PropertyName(element.name(), null);\n        }\n        return null;\n    }\n}\n```\n\nJSONMapper.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.StreamReadFeature;\nimport com.fasterxml.jackson.core.StreamWriteFeature;\nimport com.fasterxml.jackson.core.util.JsonRecyclerPools;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.MapperFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.json.JsonMapper;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.ZonedDateTimeSerializer;\nimport com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeFormatterBuilder;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.PUBLIC_ONLY;\nimport static java.time.format.DateTimeFormatter.ISO_INSTANT;\nimport static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\n\n/**\n * @author neo\n */\npublic class JSONMapper {\n    public static final ObjectMapper OBJECT_MAPPER = builder().build();\n    private static Map<Class<?>, JSONReader<?>> readers = new HashMap<>();\n    private static Map<Class<?>, JSONWriter<?>> writers = new HashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONReader<T> reader(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONReader<T>) readers.computeIfAbsent(beanClass, JSONReader::new);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONWriter<T> writer(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONWriter<T>) writers.computeIfAbsent(beanClass, JSONWriter::new);\n    }\n\n    public static void cleanup() {\n        readers = null;\n        writers = null;\n    }\n\n    // expose builder, to allow app build its own JSON mapper to parse external json, e.g. can be less strict\n    public static JsonMapper.Builder builder() {\n        JsonFactory jsonFactory = JsonFactory.builder()\n            .recyclerPool(JsonRecyclerPools.sharedLockFreePool())\n            .build();\n\n        // refer to com.fasterxml.jackson.databind.ObjectMapper.DEFAULT_BASE for default settings, e.g. cacheProvider\n        return JsonMapper.builder(jsonFactory)\n            .addModule(timeModule())\n            .defaultDateFormat(new StdDateFormat())\n            // disable value class loader to avoid jdk illegal reflection warning, requires JSON class/fields must be public\n            .addModule(new AfterburnerModule().setUseValueClassLoader(false))\n            // only detect public fields, refer to com.fasterxml.jackson.databind.introspect.VisibilityChecker.Std\n            .visibility(new VisibilityChecker.Std(NONE, NONE, NONE, NONE, PUBLIC_ONLY))\n            .enable(StreamReadFeature.USE_FAST_DOUBLE_PARSER)\n            .enable(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER)\n            .enable(StreamWriteFeature.USE_FAST_DOUBLE_WRITER)\n            .enable(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)\n            .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)\n            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n            // e.g. disable convert empty string to Integer null\n            .disable(MapperFeature.ALLOW_COERCION_OF_SCALARS)\n            .annotationIntrospector(new JSONAnnotationIntrospector())\n            .deactivateDefaultTyping();\n    }\n\n    private static JavaTimeModule timeModule() {\n        var module = new JavaTimeModule();\n\n        // redefine date time formatter to output nano seconds in at least 3 digits, which inline with ISO standard and ES standard\n        DateTimeFormatter localTimeFormatter = new DateTimeFormatterBuilder()\n            .parseStrict()\n            .appendValue(HOUR_OF_DAY, 2)\n            .appendLiteral(':')\n            .appendValue(MINUTE_OF_HOUR, 2)\n            .appendLiteral(':')\n            .appendValue(SECOND_OF_MINUTE, 2)\n            .appendFraction(NANO_OF_SECOND, 3, 9, true) // always output 3 digits of nano seconds (iso date format doesn't specify how many digits it should present, here always keep 3)\n            .toFormatter();\n\n        module.addSerializer(ZonedDateTime.class, new ZonedDateTimeSerializer(ISO_INSTANT));\n        module.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(ISO_LOCAL_DATE)\n            .appendLiteral('T')\n            .append(localTimeFormatter)\n            .toFormatter()));\n        module.addSerializer(LocalTime.class, new LocalTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(localTimeFormatter)\n            .toFormatter()));\n        return module;\n    }\n}\n```\n\nJSONReader.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.databind.ObjectReader;\n\nimport java.io.IOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONReader<T> {\n    // used internally, performance is top priority in design, reader is about 3~6% faster than mapper since type is pre determined\n    // refer to https://github.com/FasterXML/jackson-docs/wiki/Presentation:-Jackson-Performance\n    private final ObjectReader reader;\n\n    public JSONReader(Class<T> instanceClass) {\n        this.reader = JSONMapper.OBJECT_MAPPER.readerFor(instanceClass);\n    }\n\n    public T fromJSON(byte[] json) throws IOException {\n        return reader.readValue(json);\n    }\n\n    public T fromJSON(String json) throws IOException {\n        return reader.readValue(json);\n    }\n}\n```\n\nJSONWriter.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport core.framework.util.Strings;\n\nimport java.io.UncheckedIOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONWriter<T> {\n    private final ObjectWriter writer;\n\n    public JSONWriter(Class<T> instanceClass) {\n        this.writer = JSONMapper.OBJECT_MAPPER.writerFor(instanceClass);\n    }\n\n    // with jdk 11, write to String then covert to byte[] is faster than write to byte[]\n    // toJSON won't throw exception especially instance class will be validated before\n    public byte[] toJSON(T instance) {\n        try {\n            return Strings.bytes(writer.writeValueAsString(instance));\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public String toJSONString(T instance) {\n        try {\n            return writer.writeValueAsString(instance);\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nJSON.java\n```java\npackage core.framework.json;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Type;\n\nimport static core.framework.internal.json.JSONMapper.OBJECT_MAPPER;\n\n/**\n * @author neo\n */\npublic final class JSON {\n    public static <T> T fromJSON(Type instanceType, String json) {\n        try {\n            JavaType javaType = OBJECT_MAPPER.getTypeFactory().constructType(instanceType);\n            T result = OBJECT_MAPPER.readValue(json, javaType);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T> T fromJSON(Class<T> instanceClass, String json) {\n        try {\n            T result = OBJECT_MAPPER.readValue(json, instanceClass);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static String toJSON(Object instance) {\n        if (instance == null) throw new Error(\"instance must not be null\");\n        try {\n            return OBJECT_MAPPER.writeValueAsString(instance);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T extends Enum<?>> T fromEnumValue(Class<T> valueClass, String jsonValue) {\n        return OBJECT_MAPPER.convertValue(jsonValue, valueClass);\n    }\n\n    public static <T extends Enum<?>> String toEnumValue(T value) {\n        return OBJECT_MAPPER.convertValue(value, String.class);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-common."}, {"role": "assistant", "content": "Here is the source code of package core-ng-common:\ntree /mnt/d/wonder-core-ng-project/core-ng-common/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-common/src/main/java\n├── core\n│   └── framework\n│       └── util\n│           ├── ASCII.java\n│           ├── ClasspathResources.java\n│           ├── Encodings.java\n│           ├── Exceptions.java\n│           ├── Files.java\n│           ├── Lists.java\n│           ├── Maps.java\n│           ├── Network.java\n│           ├── Properties.java\n│           ├── Randoms.java\n│           ├── Sets.java\n│           ├── StopWatch.java\n│           ├── Strings.java\n│           ├── Threads.java\n│           └── Types.java\n└── javax\n    └── annotation\n        └── Nullable.java\n\n6 directories, 16 files\n\nASCII.java\n```java\npackage core.framework.util;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic final class ASCII {\n    // only convert ascii chars, faster than JDK String.toUpperCase due to JDK needs to handle UTF and locale\n    // refers to https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Ascii.java\n    public static String toUpperCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isLowerCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isLowerCase(ch)) {\n                        chars[j] = (char) (ch & 0x5F);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toUpperCase(char ch) {\n        if (isLowerCase(ch)) return (char) (ch & 0x5F);\n        return ch;\n    }\n\n    public static String toLowerCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isUpperCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isUpperCase(ch)) {\n                        chars[j] = (char) (ch ^ 0x20);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toLowerCase(char ch) {\n        if (isUpperCase(ch)) return (char) (ch ^ 0x20);\n        return ch;\n    }\n\n    public static boolean isLowerCase(char ch) {\n        return ch >= 'a' && ch <= 'z';\n    }\n\n    public static boolean isUpperCase(char ch) {\n        return ch >= 'A' && ch <= 'Z';\n    }\n\n    public static boolean isDigit(char ch) {\n        return ch >= '0' && ch <= '9';\n    }\n\n    public static boolean isLetter(char ch) {\n        return isLowerCase(ch) || isUpperCase(ch);\n    }\n}\n```\n\nClasspathResources.java\n```java\npackage core.framework.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.util.Iterator;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class ClasspathResources {\n    public static String text(String path) {\n        return new String(bytes(path), UTF_8);\n    }\n\n    public static byte[] bytes(String path) {\n        try (InputStream stream = stream(path)) {\n            return stream.readAllBytes();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static InputStream stream(String path) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Iterator<URL> urls = loader.getResources(path).asIterator();\n            return openStream(urls, path);\n        } catch (IOException e) {\n            throw new Error(\"can not load resource, path=\" + path, e);\n        }\n    }\n\n    static InputStream openStream(Iterator<URL> urls, String path) throws IOException {\n        if (urls.hasNext()) {\n            URL url = urls.next();\n            // to avoid have same resource name within different jars, as the order of loading jar is not determined on different env/os, we'd better avoid potential unexpected behavior\n            if (urls.hasNext()) throw new Error(\"found duplicate resources with same name, path=\" + path);\n            return url.openStream();\n        }\n        throw new Error(\"can not load resource, path=\" + path);\n    }\n}\n\n```\n\nEncodings.java\n```java\npackage core.framework.util;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.BitSet;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\n/**\n * @author neo\n */\npublic final class Encodings {\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    // refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent,\n    // refer to http://tools.ietf.org/html/rfc3986\n    private static final BitSet URI_UNESCAPED = new BitSet(128);\n\n    static {\n        for (int i = 'a'; i <= 'z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = '0'; i <= '9'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        URI_UNESCAPED.set('-');\n        URI_UNESCAPED.set('_');\n        URI_UNESCAPED.set('.');\n        URI_UNESCAPED.set('!');\n        URI_UNESCAPED.set('~');\n        URI_UNESCAPED.set('*');\n        URI_UNESCAPED.set('\'');\n        URI_UNESCAPED.set('(');\n        URI_UNESCAPED.set(')');\n    }\n\n    // refer to impl from org.springframework.web.util.HierarchicalUriComponents#encodeUriComponent\n    public static String uriComponent(String value) {\n        byte[] bytes = Strings.bytes(value);\n        int length = bytes.length;\n\n        for (int i = 0; i < length; i++) {\n            byte b1 = bytes[i];\n            if (b1 < 0 || !URI_UNESCAPED.get(b1)) {   // the bytes java returned is signed, but we only need to check ascii (0-127)\n                StringBuilder builder = new StringBuilder(length * 2);\n                if (i > 0) builder.append(value, 0, i); // unescaped bytes must be single byte char\n                for (int j = i; j < length; j++) {\n                    byte b2 = bytes[j];\n                    if (b2 >= 0 && URI_UNESCAPED.get(b2)) {\n                        builder.append((char) b2);\n                    } else {\n                        builder.append('%')\n                            .append(HEX_CHARS[(b2 >> 4) & 0xF])\n                            .append(HEX_CHARS[b2 & 0xF]);\n                    }\n                }\n                return builder.toString();\n            }\n        }\n        return value;\n    }\n\n    // refer to impl from org.springframework.web.util.UriUtils#decode\n    public static String decodeURIComponent(String value) {\n        int length = value.length();\n        int index = 0;\n        for (; index < length; index++) {\n            int ch = value.charAt(index);\n            if (ch == '%') break;\n        }\n        if (index == length) return value;\n\n        byte[] buffer = new byte[length];\n        for (int i = 0; i < index; i++) buffer[i] = (byte) value.charAt(i);\n        int position = index;\n\n        for (; index < length; index++) {\n            char ch = value.charAt(index);\n            if (ch == '%') {\n                if ((index + 2) >= length) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                char hex1 = value.charAt(index + 1);\n                char hex2 = value.charAt(index + 2);\n                int u = Character.digit(hex1, 16);\n                int l = Character.digit(hex2, 16);\n                if (u == -1 || l == -1) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                buffer[position] = (byte) ((u << 4) + l);\n                index += 2;\n            } else {\n                buffer[position] = (byte) ch;   // here assume value is valid uri encoded string, if it contains multi-bytes (which should be encoded), here will not give right result\n            }\n            position++;\n        }\n        return new String(buffer, 0, position, StandardCharsets.UTF_8);\n    }\n\n    public static String base64(String value) {\n        return base64(Strings.bytes(value));\n    }\n\n    public static String base64(byte[] value) {\n        return Base64.getEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64(String value) {\n        return Base64.getDecoder().decode(value);\n    }\n\n    public static String base64URLSafe(byte[] value) {\n        return Base64.getUrlEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64URLSafe(String value) {\n        return Base64.getUrlDecoder().decode(value);\n    }\n\n    public static String hex(byte[] bytes) {\n        var values = new byte[bytes.length * 2];\n        int i = 0;\n        for (byte value : bytes) {\n            values[i++] = (byte) HEX_CHARS[value >> 4 & 0xF];\n            values[i++] = (byte) HEX_CHARS[value & 0xF];\n        }\n        return new String(values, US_ASCII);\n    }\n}\n```\n\nExceptions.java\n```java\npackage core.framework.util;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n/**\n * @author neo\n */\npublic final class Exceptions {\n    public static String stackTrace(Throwable e) {\n        var writer = new StringWriter();\n        e.printStackTrace(new PrintWriter(writer));\n        return writer.toString();\n    }\n}\n```\n\nFiles.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.time.Instant;\nimport java.util.UUID;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.createDirectories;\nimport static java.nio.file.Files.getLastModifiedTime;\nimport static java.nio.file.Files.readAllBytes;\nimport static java.nio.file.Files.walkFileTree;\n\n/**\n * @author neo\n */\npublic final class Files {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Files.class);\n\n    public static String text(Path file) {\n        return new String(bytes(file), UTF_8);\n    }\n\n    public static byte[] bytes(Path file) {\n        var watch = new StopWatch();\n        try {\n            return readAllBytes(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"bytes, file={}, elapsed={}\", file, watch.elapsed());\n        }\n    }\n\n    public static void createDir(Path directory) {\n        try {\n            createDirectories(directory);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static void deleteDir(Path directory) {\n        var watch = new StopWatch();\n        try {\n            walkFileTree(directory, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\n                    delete(file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException e) {\n                    delete(dir);\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"deleteDir, directory={}, elapsed={}\", directory, watch.elapsed());\n        }\n    }\n\n    public static Path tempFile() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        return Paths.get(tempDir + \"/\" + UUID.randomUUID().toString() + \".tmp\");\n    }\n\n    public static Path tempDir() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        Path path = Paths.get(tempDir + \"/\" + UUID.randomUUID().toString());\n        createDir(path);\n        return path;\n    }\n\n    public static void delete(Path file) {\n        try {\n            java.nio.file.Files.delete(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static long size(Path file) {\n        try {\n            return java.nio.file.Files.size(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static Instant lastModified(Path file) {\n        try {\n            return getLastModifiedTime(file).toInstant();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nLists.java\n```java\npackage core.framework.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class Lists {\n    public static <T> List<T> newArrayList() {\n        return new ArrayList<>();\n    }\n}\n```\n\nMaps.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * @author neo\n */\npublic final class Maps {\n    public static <T, V> Map<T, V> newHashMap() {\n        return new HashMap<>();\n    }\n\n    public static <T, V> ConcurrentMap<T, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMap() {\n        return new LinkedHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMapWithExpectedSize(int size) {\n        return new LinkedHashMap<>(capacity(size));\n    }\n\n    public static <T, V> Map<T, V> newHashMapWithExpectedSize(int size) {\n        return new HashMap<>(capacity(size));\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    private static int capacity(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return capacity;\n    }\n\n    public static <T extends Enum<T>, V> Map<T, V> newEnumMap(Class<T> enumClass) {\n        return new EnumMap<>(enumClass);\n    }\n}\n```\n\nNetwork.java\n```java\npackage core.framework.util;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author neo\n */\npublic final class Network {    // in cloud env, the application vm or container stick with same host ip / name during entire lifecycle\n    public static final String LOCAL_HOST_ADDRESS;\n    public static final String LOCAL_HOST_NAME;\n\n    static {\n        try {\n            InetAddress address = InetAddress.getLocalHost();\n            LOCAL_HOST_ADDRESS = address.getHostAddress();\n            LOCAL_HOST_NAME = address.getHostName();\n        } catch (UnknownHostException e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\nProperties.java\n```java\npackage core.framework.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Properties {\n    final Map<String, String> properties = Maps.newHashMap();\n\n    public void load(String classpath) {\n        try (InputStream stream = ClasspathResources.stream(classpath);\n             var reader = new BufferedReader(new InputStreamReader(stream, UTF_8))) {\n            var properties = new java.util.Properties();\n            properties.load(reader);\n            properties.forEach((key, value) -> set((String) key, (String) value));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public Optional<String> get(String key) {\n        String value = properties.get(key);\n        if (!Strings.isBlank(value)) return Optional.of(value);\n        return Optional.empty();\n    }\n\n    public void set(String key, String value) {\n        String previous = this.properties.putIfAbsent(key, value);\n        if (previous != null) throw new Error(format(\"property already exists, key={}, previous={}, current={}\", key, previous, value));\n    }\n\n    public Set<String> keys() {\n        return properties.keySet();\n    }\n\n    public boolean containsKey(String key) {\n        return properties.containsKey(key);\n    }\n}\n```\n\nRandoms.java\n```java\npackage core.framework.util;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\n/**\n * @author neo\n */\npublic final class Randoms {\n    private static final String ALPHA_NUMERIC = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n    public static String alphaNumeric(int length) {\n        StringBuilder builder = new StringBuilder(length);\n        for (int i = 0; i < length; i++)\n            builder.append(ALPHA_NUMERIC.charAt(ThreadLocalRandom.current().nextInt(ALPHA_NUMERIC.length())));\n        return builder.toString();\n    }\n\n    // return next double, ranges in [min, max)\n    public static double nextDouble(double min, double max) {\n        return (max - min) * ThreadLocalRandom.current().nextDouble() + min;\n    }\n\n    // return next int, ranges in [min, max)\n    public static int nextInt(int min, int max) {\n        return min + ThreadLocalRandom.current().nextInt(max - min);\n    }\n}\n```\n\nSets.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author neo\n */\npublic final class Sets {\n    public static <T> Set<T> newHashSet() {\n        return new HashSet<>();\n    }\n\n    public static <T> Set<T> newConcurrentHashSet() {\n        return ConcurrentHashMap.newKeySet();\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    public static <T> Set<T> newHashSetWithExpectedSize(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return new HashSet<>(capacity);\n    }\n\n    // EnumSet provides EnumSet.of(values...) methods, use it directly when apply\n    public static <T extends Enum<T>> Set<T> newEnumSet(Class<T> enumClass) {\n        return EnumSet.noneOf(enumClass);\n    }\n}\n```\n\nStopWatch.java\n```java\npackage core.framework.util;\n\n/**\n * @author neo\n */\npublic final class StopWatch {\n    private long start;\n\n    public StopWatch() {\n        reset();\n    }\n\n    public void reset() {\n        start = System.nanoTime();\n    }\n\n    public long elapsed() {\n        long end = System.nanoTime();\n        return end - start;\n    }\n}\n```\n\nStrings.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.helpers.MessageFormatter;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Strings {\n    public static byte[] bytes(String text) {\n        return text.getBytes(UTF_8);\n    }\n\n    public static String format(String pattern, Object... params) {\n        return MessageFormatter.arrayFormat(pattern, params).getMessage();\n    }\n\n    public static int compare(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null && text2 == null) return 0;\n        if (text1 != null && text2 == null) return 1;\n        if (text1 == null) return -1;\n        return text1.compareTo(text2);\n    }\n\n    public static boolean isBlank(@Nullable String text) {\n        return text == null || text.isBlank();\n    }\n\n    public static boolean equals(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null) return text2 == null;\n        return text1.equals(text2);\n    }\n\n    @Nullable\n    public static String truncate(@Nullable String text, int maxLength) {\n        if (text == null) return null;\n        if (text.length() <= maxLength) return text;\n        return text.substring(0, maxLength);\n    }\n\n    @Nullable\n    public static String strip(@Nullable String text) {\n        if (text == null) return null;\n        return text.strip();\n    }\n\n    public static boolean startsWith(String text, char prefix) {\n        if (text.isEmpty()) return false;\n        return text.charAt(0) == prefix;\n    }\n\n    public static String[] split(String text, char delimiter) {\n        List<String> tokens = Lists.newArrayList();\n        int start = 0;\n        while (true) {\n            int next = text.indexOf(delimiter, start);\n            if (next == -1) break;\n            tokens.add(text.substring(start, next));\n            start = next + 1;\n        }\n        if (start == 0) return new String[]{text};\n        else tokens.add(text.substring(start));\n        return tokens.toArray(new String[0]);\n    }\n}\n```\n\nThreads.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class Threads {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Threads.class);\n\n    public static void sleepRoughly(Duration duration) {\n        long sleepTime = sleepTime(duration);\n        LOGGER.debug(\"sleep {} ms\", sleepTime);\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            LOGGER.debug(\"sleep is interrupted\", e);\n        }\n    }\n\n    static long sleepTime(Duration duration) {\n        long milliseconds = duration.toMillis();\n        double times = Randoms.nextDouble(0.8, 1.2); // +/-20% random\n        return (long) (milliseconds * times);\n    }\n}\n```\n\nTypes.java\n```java\npackage core.framework.util;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Supplier;\n\n/**\n * @author neo\n */\npublic final class Types {\n    public static Type generic(Class<?> rawType, Type... arguments) {\n        return new ParameterizedTypeImpl(rawType, arguments);\n    }\n\n    public static Type optional(Type valueType) {\n        return generic(Optional.class, valueType);\n    }\n\n    public static Type list(Type valueType) {\n        return generic(List.class, valueType);\n    }\n\n    public static Type map(Type keyType, Type valueType) {\n        return generic(Map.class, keyType, valueType);\n    }\n\n    public static Type supplier(Type valueType) {\n        return generic(Supplier.class, valueType);\n    }\n\n    static final class ParameterizedTypeImpl implements ParameterizedType {\n        private final Type rawType;\n        private final Type[] arguments;\n\n        ParameterizedTypeImpl(Class<?> rawType, Type... arguments) {\n            this.rawType = rawType;\n            this.arguments = arguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return arguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n\n        // refer to sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.hashCode, must return same hashcode as builtin type\n        @Override\n        public int hashCode() {\n            return Arrays.hashCode(arguments) ^ rawType.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (!(other instanceof ParameterizedType that)) return false;\n\n            return Objects.equals(rawType, that.getRawType())\n                   && that.getOwnerType() == null\n                   && Arrays.equals(arguments, that.getActualTypeArguments());\n        }\n\n        @Override\n        public String toString() {\n            var builder = new StringBuilder(rawType.getTypeName()).append('<');\n\n            for (int i = 0; i < arguments.length; i++) {\n                if (i > 0) builder.append(\", \");\n                builder.append(arguments[i].getTypeName());\n            }\n\n            builder.append('>');\n            return builder.toString();\n        }\n    }\n}\n```\n\nNullable.java\n```java\npackage javax.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * help IDE (Intellij) to do nullability analysis﻿\n * <p>\n * refer to https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html#nullable\n *\n * @author neo\n */\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\npublic @interface Nullable {\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package async."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.async:\n\nExecutor.java\n```java\npackage core.framework.async;\n\nimport java.time.Duration;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\n\n/**\n * @author neo\n */\npublic interface Executor {\n    <T> Future<T> submit(String action, Callable<T> task);\n\n    Future<Void> submit(String action, Task task);\n\n    void submit(String action, Task task, Duration delay);\n}\n```\n\nTask.java\n```java\npackage core.framework.async;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Task {\n    void execute() throws Exception;    // not using Runnable to allow throw exception\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package cache."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.cache:\n\nCache.java\n```java\npackage core.framework.cache;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.function.Function;\n\n/**\n * @author neo\n */\npublic interface Cache<T> {\n    // loader must not return null, use wrapper class if it is necessary to cache null value\n    // for performance reason, it does not copy the object returned by local cache, so it must not modify local cache object unless to put it back\n    T get(String key, Function<String, T> loader);\n\n    Map<String, T> getAll(Collection<String> keys, Function<String, T> loader);\n\n    void put(String key, T value);\n\n    void putAll(Map<String, T> values);\n\n    void evict(String key);\n\n    void evictAll(Collection<String> keys);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package crypto."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.crypto:\n\nHash.java\n```java\npackage core.framework.crypto;\n\nimport core.framework.util.Strings;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * @author neo\n */\npublic final class Hash {\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    // md5 are not considered as secure algorithm, only used on legacy or security insensitive cases, like checksum or masking\n    public static String md5Hex(byte[] value) {\n        return hash(value, \"MD5\");\n    }\n\n    public static String md5Hex(String value) {\n        return md5Hex(Strings.bytes(value));\n    }\n\n    public static String sha256Hex(byte[] value) {\n        return hash(value, \"SHA-256\");\n    }\n\n    public static String sha256Hex(String value) {\n        return sha256Hex(Strings.bytes(value));\n    }\n\n    public static String sha512Hex(byte[] value) {\n        return hash(value, \"SHA-512\");\n    }\n\n    public static String sha512Hex(String value) {\n        return sha512Hex(Strings.bytes(value));\n    }\n\n    private static String hash(byte[] value, String algorithm) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(algorithm);    // lgtm[java/weak-cryptographic-algorithm]\n            byte[] digest = md.digest(value);\n            return hex(digest);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    private static String hex(byte[] bytes) {\n        char[] chars = new char[bytes.length << 1];\n        int index = 0;\n        for (byte b : bytes) {  // two characters form the hex value.\n            chars[index++] = HEX_CHARS[(b >> 4) & 0xF];\n            chars[index++] = HEX_CHARS[b & 0xF];\n        }\n        return new String(chars);\n    }\n}\n```\n\nHMAC.java\n```java\npackage core.framework.crypto;\n\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.Mac;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * http://en.wikipedia.org/wiki/Message_authentication_code\n *\n * @author neo\n */\npublic final class HMAC {\n    public static byte[] generateKey(Hash hash) {\n        try {\n            KeyGenerator generator = KeyGenerator.getInstance(hash.algorithm);\n            generator.init(128);\n            return generator.generateKey().getEncoded();\n        } catch (NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    private final byte[] key;\n    private final Hash hash;\n\n    public HMAC(byte[] key, Hash hash) {\n        this.key = key;\n        this.hash = hash;\n    }\n\n    public byte[] digest(byte[] message) {\n        if (key == null) throw new Error(\"key must not be null\");\n        try {\n            Mac mac = Mac.getInstance(hash.algorithm);\n            SecretKey secretKey = new SecretKeySpec(key, hash.algorithm);\n            mac.init(secretKey);\n            return mac.doFinal(message);\n        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n            throw new Error(e);\n        }\n    }\n\n    public enum Hash {\n        SHA256(\"HmacSHA256\"), SHA512(\"HmacSHA512\");\n        final String algorithm;\n\n        Hash(String algorithm) {\n            this.algorithm = algorithm;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package db."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.db:\n\nCloudAuthProvider.java\n```java\npackage core.framework.db;\n\n/**\n * @author neo\n */\npublic interface CloudAuthProvider {\n    String user();\n\n    String accessToken();\n\n    class Provider {\n        // used by driver to determine if current connection requires cloud auth, for multiple connections with different auth\n        public static final String CLOUD_AUTH = \"core.framework.db.cloudAuth\";\n        // in cloud env, only need one global auth provider\n        private static CloudAuthProvider provider;\n\n        public static void set(CloudAuthProvider provider) {\n            if (Provider.provider != null) throw new Error(\"provider is set, provider=\" + Provider.provider);\n            Provider.provider = provider;\n        }\n\n        public static CloudAuthProvider get() {\n            return provider;\n        }\n    }\n}\n```\n\nColumn.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Column {\n    String name();\n\n    boolean json() default false;\n}\n```\n\nDatabase.java\n```java\npackage core.framework.db;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Database {\n    /**\n     * for expected slow sql, such as query with small table or db chooses different query plan,\n     * disable warning then enable after<p>\n     * e.g.\n     * <blockquote><pre>\n     * Database.suppressSlowSQLWarning(false);\n     * database.select(...);\n     * Database.suppressSlowSQLWarning(true);\n     * </pre></blockquote>\n     *\n     * @param suppress whether suppress slow sql warning\n     */\n    static void suppressSlowSQLWarning(boolean suppress) {\n        // pass flag thru thread local to MySQLQueryInterceptor, and put in action log to reset for every action\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.warningContext.suppressSlowSQLWarning = suppress;\n        }\n    }\n\n    <T> List<T> select(String sql, Class<T> viewClass, Object... params);\n\n    <T> Optional<T> selectOne(String sql, Class<T> viewClass, Object... params);\n\n    int execute(String sql, Object... params);\n\n    // for bulk update operations, you may want to enclose it with Transaction to improve performance\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executePreparedBatchAsMultiStatement, mysql driver simply sends multiple queries with ';' as one statement,\n    // so it will reduce cost of creating transaction for each statement\n    int[] batchExecute(String sql, List<Object[]> params);\n\n    Transaction beginTransaction();\n}\n```\n\nDBEnumValue.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface DBEnumValue {\n    String value();\n}\n```\n\nIsolationLevel.java\n```java\npackage core.framework.db;\n\nimport java.sql.Connection;\n\n/**\n * @author neo\n */\npublic enum IsolationLevel {\n    READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED), READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED);\n\n    public final int level;\n\n    IsolationLevel(int level) {\n        this.level = level;\n    }\n}\n```\n\nPrimaryKey.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface PrimaryKey {\n    // only allow auto increment on primary key, not regular column\n    boolean autoIncrement() default false;\n}\n```\n\nQuery.java\n```java\npackage core.framework.db;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Query<T> {\n    void where(String condition, Object... params);\n\n    void orderBy(String sort);\n\n    void groupBy(String groupBy);\n\n    void skip(Integer skip);    // pass null to reset skip\n\n    void limit(Integer limit);  // pass null to reset limit\n\n    List<T> fetch();\n\n    Optional<T> fetchOne();\n\n    <P> List<P> project(String projection, Class<P> viewClass);\n\n    <P> Optional<P> projectOne(String projection, Class<P> viewClass);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count, count function return BIGINT\n    default long count() {\n        return projectOne(\"count(1)\", Long.class).orElseThrow();\n    }\n\n    // syntax sugar, to help to build \"where in clause\" with dynamic params\n    default <V> void in(String field, List<V> params) {\n        if (field == null) throw new Error(\"field must not be null\");\n        if (params == null || params.isEmpty()) throw new Error(\"params must not be empty\");\n        // efficient version of: where(Strings.format(\"{} IN ({})\", field, params.stream().map(param -> \"?\").collect(Collectors.joining(\", \"))), params.toArray());\n        int size = params.size();\n        var builder = new StringBuilder(field.length() + size * 3 + 6);    // e.g. field in (?, ?, ?)\n        builder.append(field).append(\" IN (\");\n        for (int i = 0; i < size; i++) {\n            if (i > 0) builder.append(\", \");\n            builder.append('?');\n        }\n        builder.append(')');\n        where(builder.toString(), params.toArray());\n    }\n}\n```\n\nQueryDiagnostic.java\n```java\npackage core.framework.db;\n\npublic interface QueryDiagnostic {\n    String sql();\n\n    boolean noGoodIndexUsed();\n\n    boolean noIndexUsed();\n}\n```\n\nRepository.java\n```java\npackage core.framework.db;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\n\n/**\n * @author neo\n */\npublic interface Repository<T> {\n    Query<T> select();\n\n    default List<T> select(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.fetch();\n    }\n\n    default long count(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.count();\n    }\n\n    default Optional<T> selectOne(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.fetchOne();\n    }\n\n    Optional<T> get(Object... primaryKeys);\n\n    OptionalLong insert(T entity);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/insert.html\n    // ignore if there is duplicate row, return true if inserted successfully\n    // BE CAUTION, it uses PK or unique index to determine duplication !!! read mysql doc carefully to avoid unexpected side effect\n    // BE CAUTION, With IGNORE, invalid values are adjusted to the closest values and inserted; warnings are produced but the statement does not abort.\n    // e.g. if you pass to out of range timestamp value, insert ignore will save it as 0 in db, which is terrible design of MySQL\n    boolean insertIgnore(T entity);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\n    // use insert on duplicate key sql, generally used by data sync\n    // BE CAUTION, it uses PK or unique index to determine duplication !!! read mysql doc carefully to avoid unexpected side effect\n    // return true if the new row inserted\n    boolean upsert(T entity);\n\n    // use update carefully, it will update all the columns according to the entity fields, includes null fields\n    // generally it's recommended to use partialUpdate if only few columns need to be updated and with optimistic lock\n    // return true if the row actually changed\n    boolean update(T entity);\n\n    // only update non-null fields, return true if the row actually changed\n    // if returned false, it CAN NOT distinguish if id not found, or all columns updated to its current values\n    boolean partialUpdate(T entity);\n\n    // partial update with additional condition, usually applied as optimistic lock pattern, return true if the row actually changed\n    boolean partialUpdate(T entity, String where, Object... params);\n\n    // return true if the row actually deleted\n    boolean delete(Object... primaryKeys);\n\n    Optional<long[]> batchInsert(List<T> entities);\n\n    // return true if any row inserted\n    // this is drawback of MySQL thin driver, though expected behavior\n    // with batch insert ignore (or insert on duplicate key), MySQL thin driver fills entire affectedRows array with same value, java.sql.Statement.SUCCESS_NO_INFO if updated count > 0\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executeBatchWithMultiValuesClause Line 612\n    boolean batchInsertIgnore(List<T> entities);\n\n    // return true if any row changed (inserted or updated)\n    // with batch, mysql treats both 1 (inserted) or 2 (updated) as java.sql.Statement.SUCCESS_NO_INFO\n    // batch performance is significantly better than single call, try to do batch if possible on data sync\n    boolean batchUpsert(List<T> entities);\n\n    // return true if any row deleted\n    // use Transaction if size of primaryKeys is too large, to avoid mysql create transaction for each statement\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executePreparedBatchAsMultiStatement, mysql driver simply sends multiple queries with ';' as one statement\n    boolean batchDelete(List<?> primaryKeys);\n}\n```\n\nTable.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(TYPE)\n@Retention(RUNTIME)\npublic @interface Table {\n    String name();\n}\n```\n\nTransaction.java\n```java\npackage core.framework.db;\n\n\n/**\n * @author neo\n */\npublic interface Transaction extends AutoCloseable {\n    void rollback();\n\n    void commit();\n\n    @Override\n    void close();\n}\n```\n\nUncheckedSQLException.java\n```java\npackage core.framework.db;\n\nimport java.io.Serial;\nimport java.sql.SQLException;\n\n/**\n * @author neo\n */\npublic final class UncheckedSQLException extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = 5857178985477320780L;\n\n    public final ErrorType errorType;\n\n    // expose original sqlState to support handle errors not covered by errorType\n    public final String sqlSate;\n\n    public UncheckedSQLException(SQLException e) {\n        super(e.getMessage() + \", sqlState=\" + e.getSQLState() + \", errorCode=\" + e.getErrorCode(), e);\n        sqlSate = e.getSQLState();\n        errorType = errorType(e);\n    }\n\n    // different jdbc driver translates sqlState to exception differently, but with common set\n    // hsqldb: org.hsqldb.jdbc.JDBCUtil,\n    // mysql: com.mysql.cj.jdbc.exceptions.SQLError\n    private ErrorType errorType(SQLException e) {\n        String state = e.getSQLState();\n        if (state == null) return null;\n        // in batchExecute, driver throws BatchUpdateException and may not have SQLIntegrityConstraintViolationException as cause, so here use sql state as contract\n        if (state.startsWith(\"23\")) return ErrorType.INTEGRITY_CONSTRAINT_VIOLATION;\n        if (state.startsWith(\"08\") || \"S1009\".equals(state)) return ErrorType.CONNECTION_ERROR;\n        return null;\n    }\n\n    // currently only valid use case to catch UncheckedSQLException is for duplicate key / constraint violation , e.g. register with duplicate name,\n    // it should not catch UncheckedSQLException for rest use cases\n    public enum ErrorType {\n        CONNECTION_ERROR,   // error type used to retry db operation potentially for top critical system, in cloud env / webapp, there are only limited use cases where retry db query makes sense\n        INTEGRITY_CONSTRAINT_VIOLATION\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package http."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.http:\n\nContentType.java\n```java\npackage core.framework.http;\n\nimport core.framework.util.ASCII;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport static core.framework.log.Markers.errorCode;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class ContentType {\n    public static final ContentType TEXT_HTML = create(\"text/html\", UTF_8);\n    public static final ContentType TEXT_CSS = create(\"text/css\", UTF_8);\n    public static final ContentType TEXT_PLAIN = create(\"text/plain\", UTF_8);\n    public static final ContentType TEXT_XML = create(\"text/xml\", UTF_8);\n    // refer to https://www.iana.org/assignments/media-types/application/json, No \"charset\" parameter is defined for application/json\n    // https://tools.ietf.org/html/rfc7159#section-8.1, UTF-8 as default encoding for JSON\n    // https://chromium-review.googlesource.com/c/chromium/src/+/587829\n    public static final ContentType APPLICATION_JSON = create(\"application/json\", null);\n    public static final ContentType APPLICATION_JAVASCRIPT = create(\"application/javascript\", UTF_8);\n    // form body content type doesn't use charset normally, refer to https://www.w3.org/TR/html5/sec-forms.html#urlencoded-form-data\n    public static final ContentType APPLICATION_FORM_URLENCODED = create(\"application/x-www-form-urlencoded\", null);\n    public static final ContentType APPLICATION_OCTET_STREAM = create(\"application/octet-stream\", null);\n    public static final ContentType IMAGE_PNG = create(\"image/png\", null);\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ContentType.class);\n    // cache most used ones to save paring time\n    private static final Map<String, ContentType> CACHE = Map.of(\n            APPLICATION_JSON.contentType, APPLICATION_JSON,\n            TEXT_HTML.contentType, TEXT_HTML\n    );\n\n    // only cover common case, assume pattern is \"media-type; charset=\" or \"multipart/form-data; boundary=\"\n    // according to https://www.w3.org/Protocols/rfc1341/4_Content-Type.html, content type value is case insensitive\n    public static ContentType parse(String contentType) {\n        String normalizedContentType = ASCII.toLowerCase(contentType);\n        ContentType type = CACHE.get(normalizedContentType);\n        if (type != null) return type;\n\n        return parseContentType(normalizedContentType);\n    }\n\n    public static ContentType create(String mediaType, Charset charset) {\n        String contentType = charset == null ? mediaType : mediaType + \"; charset=\" + ASCII.toLowerCase(charset.name());\n        return new ContentType(contentType, mediaType, charset);\n    }\n\n    private static ContentType parseContentType(String contentType) {\n        String mediaType = contentType;\n        Charset charset = null;\n\n        int firstSemicolon = contentType.indexOf(';');\n        if (firstSemicolon > 0) {\n            mediaType = contentType.substring(0, firstSemicolon);\n\n            int charsetStartIndex = contentType.indexOf(\"charset=\", firstSemicolon + 1);\n            if (charsetStartIndex > 0) {\n                int charsetEndIndex = contentType.indexOf(';', charsetStartIndex + 8);\n                charset = parseCharset(contentType.substring(charsetStartIndex + 8, charsetEndIndex == -1 ? contentType.length() : charsetEndIndex));\n            }\n        }\n\n        return new ContentType(contentType, mediaType, charset);\n    }\n\n    private static Charset parseCharset(String charset) {\n        try {\n            return Charset.forName(charset);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException e) {\n            LOGGER.warn(errorCode(\"INVALID_CONTENT_TYPE\"), \"ignore unsupported charset, charset={}\", charset, e);\n            return null;\n        }\n    }\n\n    public final String mediaType;\n    private final String contentType;\n    private final Charset charset;\n\n    private ContentType(String contentType, String mediaType, Charset charset) {\n        this.contentType = contentType;\n        this.mediaType = mediaType;\n        this.charset = charset;\n    }\n\n    public Optional<Charset> charset() {\n        return Optional.ofNullable(charset);\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || ContentType.class != object.getClass()) return false;\n        ContentType that = (ContentType) object;\n        return contentType.equals(that.contentType);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(contentType);\n    }\n\n    @Override\n    public String toString() {\n        return contentType;\n    }\n}\n```\n\nHTTPClient.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic interface HTTPClient {\n    static HTTPClientBuilder builder() {\n        return new HTTPClientBuilder();\n    }\n\n    HTTPResponse execute(HTTPRequest request);\n}\n```\n\nHTTPClientBuilder.java\n```java\npackage core.framework.http;\n\nimport core.framework.internal.http.CookieManager;\nimport core.framework.internal.http.DefaultTrustManager;\nimport core.framework.internal.http.FallbackDNSCache;\nimport core.framework.internal.http.HTTPClientImpl;\nimport core.framework.internal.http.HTTPEventListenerFactory;\nimport core.framework.internal.http.PEM;\nimport core.framework.internal.http.RetryInterceptor;\nimport core.framework.internal.http.ServiceUnavailableInterceptor;\nimport core.framework.internal.http.TimeoutInterceptor;\nimport core.framework.util.StopWatch;\nimport okhttp3.ConnectionPool;\nimport okhttp3.OkHttpClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.Security;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author neo\n */\npublic final class HTTPClientBuilder {\n    static {\n        // the system property must be set before loading jdk http client class, JDK uses static field to initialize those values\n\n        // allow server ssl cert change during renegotiation\n        // http client uses pooled connection, multiple requests to same host may hit different server behind LB\n        // refer to sun.security.ssl.ClientHandshakeContext, allowUnsafeServerCertChange = Utilities.getBooleanProperty(\"jdk.tls.allowUnsafeServerCertChange\", false);\n        System.setProperty(\"jdk.tls.allowUnsafeServerCertChange\", \"true\");\n\n        // refer to jdk InetAddressCachePolicy.class, it reads value from Security properties\n        // for application to override, one way is to put Security.setProperty() in Main before starting app\n        // override default to 300\n        if (Security.getProperty(\"networkaddress.cache.ttl\") == null) {\n            Security.setProperty(\"networkaddress.cache.ttl\", \"300\");\n        }\n        // override negative default from 10 to 0, not cache failure when http client retry dns resolving\n        if (\"10\".equals(Security.getProperty(\"networkaddress.cache.negative.ttl\"))) {\n            Security.setProperty(\"networkaddress.cache.negative.ttl\", \"0\");\n        }\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(HTTPClientBuilder.class);\n\n    private Duration connectTimeout = Duration.ofSeconds(25);\n    private Duration timeout = Duration.ofSeconds(60);\n    private Duration keepAlive = Duration.ofSeconds(30);    // conservative setting, as http connection to internet/external can be cut off by NAT/firewall if idle too long\n    private Duration slowOperationThreshold = Duration.ofSeconds(30);   // slow threshold should be longer than connect timeout\n    private boolean enableCookie = false;\n    // there is already networkaddress.cache.ttl=300s, this is to mitigate dns failure further,\n    // like external domain can be under DDos attack constantly (DNS hijacking) or unstable DNS query between countries\n    // this is trying to use previous success resolution to reduce intermittent dns resolve failures\n    private boolean enableFallbackDNSCache = false;\n    private String userAgent = \"HTTPClient\";\n    private boolean trustAll = false;\n    private KeyStore trustStore;\n    private KeyManager[] keyManagers;   // for client auth\n    private Integer maxRetries;\n    private Duration retryWaitTime = Duration.ofMillis(500);\n\n    // force to use HTTPClient.builder()\n    HTTPClientBuilder() {\n    }\n\n    public HTTPClient build() {\n        var watch = new StopWatch();\n        try {\n            OkHttpClient.Builder builder = new OkHttpClient.Builder()\n                .connectTimeout(connectTimeout)\n                .readTimeout(timeout)\n                .writeTimeout(timeout)\n                .callTimeout(callTimeout()) // call timeout is only used as last defense, timeout for complete call includes connect/retry/etc\n                .connectionPool(new ConnectionPool(100, keepAlive.toSeconds(), TimeUnit.SECONDS))\n                .eventListenerFactory(new HTTPEventListenerFactory())\n                .retryOnConnectionFailure(false)    // disable all okHTTP builtin retry and followups, those should be handled on application level for traces\n                .followRedirects(false)\n                .followSslRedirects(false);\n\n            configureHTTPS(builder);\n\n            builder.addInterceptor(new TimeoutInterceptor());\n            if (maxRetries != null) {\n                builder.addNetworkInterceptor(new ServiceUnavailableInterceptor());\n                builder.addInterceptor(new RetryInterceptor(maxRetries, retryWaitTime));\n            }\n            if (enableCookie) builder.cookieJar(new CookieManager());\n            if (enableFallbackDNSCache) builder.dns(new FallbackDNSCache());\n\n            return new HTTPClientImpl(builder.build(), userAgent, slowOperationThreshold, timeout);\n        } finally {\n            logger.info(\"create http client, elapsed={}\", watch.elapsed());\n        }\n    }\n\n    private void configureHTTPS(OkHttpClient.Builder builder) {\n        if (!trustAll && trustStore == null && keyManagers == null) return;\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManager[] trustManagers;\n            if (trustAll) {\n                trustManagers = new TrustManager[]{new DefaultTrustManager()};\n                builder.hostnameVerifier((hostname, sslSession) -> true);\n            } else {\n                var trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                trustManagerFactory.init(trustStore);\n                trustManagers = trustManagerFactory.getTrustManagers();\n            }\n            sslContext.init(keyManagers, trustManagers, null);  // lgtm [java/insecure-trustmanager]\n            builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0]);\n        } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {\n            throw new Error(e);\n        }\n    }\n\n    // client level connect timeout, request level timeout can be specified in HTTPRequest\n    public HTTPClientBuilder connectTimeout(Duration connectTimeout) {\n        this.connectTimeout = connectTimeout;\n        return this;\n    }\n\n    // client level read/write timeout, request level timeout can be specified in HTTPRequest\n    public HTTPClientBuilder timeout(Duration timeout) {\n        this.timeout = timeout;\n        return this;\n    }\n\n    public HTTPClientBuilder keepAlive(Duration keepAlive) {\n        this.keepAlive = keepAlive;\n        return this;\n    }\n\n    public HTTPClientBuilder slowOperationThreshold(Duration slowOperationThreshold) {\n        this.slowOperationThreshold = slowOperationThreshold;\n        return this;\n    }\n\n    public HTTPClientBuilder userAgent(String userAgent) {\n        this.userAgent = userAgent;\n        return this;\n    }\n\n    public HTTPClientBuilder maxRetries(int maxRetries) {\n        this.maxRetries = maxRetries;\n        return this;\n    }\n\n    public HTTPClientBuilder retryWaitTime(Duration waitTime) {\n        retryWaitTime = waitTime;\n        return this;\n    }\n\n    public HTTPClientBuilder enableCookie() {\n        enableCookie = true;\n        return this;\n    }\n\n    public HTTPClientBuilder enableFallbackDNSCache() {\n        enableFallbackDNSCache = true;\n        return this;\n    }\n\n    public HTTPClientBuilder trustAll() {\n        trustAll = true;\n        return this;\n    }\n\n    public HTTPClientBuilder trust(String cert) {\n        try {\n            if (trustStore == null) {\n                trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null, null);  // must be init first\n\n                // add all system issuers to trust store to accept all authorized http certs\n                TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                factory.init((KeyStore) null);\n                for (TrustManager trustManager : factory.getTrustManagers()) {\n                    if (trustManager instanceof final X509TrustManager manager) {\n                        for (X509Certificate issuer : manager.getAcceptedIssuers()) {\n                            trustStore.setCertificateEntry(issuer.getSubjectX500Principal().getName(), issuer);\n                        }\n                    }\n                }\n            }\n            CertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\n            Certificate certificate = factory.generateCertificate(new ByteArrayInputStream(PEM.decode(cert)));\n            trustStore.setCertificateEntry(String.valueOf(trustStore.size() + 1), certificate);\n            return this;\n        } catch (CertificateException | KeyStoreException | IOException | NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    public HTTPClientBuilder clientAuth(String privateKey, String cert) {\n        try {\n            PrivateKey clientPrivateKey = KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(PEM.decode(privateKey)));\n            Certificate clientCertificate = CertificateFactory.getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(PEM.decode(cert)));\n\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, null);\n            keyStore.setKeyEntry(\"default\", clientPrivateKey, new char[0], new Certificate[]{clientCertificate});\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, new char[0]);\n            keyManagers = keyManagerFactory.getKeyManagers();\n            return this;\n        } catch (UnrecoverableKeyException | CertificateException | InvalidKeySpecException | NoSuchAlgorithmException | KeyStoreException | IOException e) {\n            throw new Error(e);\n        }\n    }\n\n    // this is rough estimate, like read timeout doesn't mean fetching full response will complete within duration of timeout\n    Duration callTimeout() {\n        int attempts = maxRetries == null ? 1 : maxRetries;\n        long callTimeout = connectTimeout.toMillis() + timeout.toMillis() * attempts;\n        for (int i = 1; i < attempts; i++) {\n            callTimeout += retryWaitTime.toMillis() << i - 1;\n        }\n        callTimeout += 2000;  // add 2 seconds as extra buffer\n        return Duration.ofMillis(callTimeout);\n    }\n}\n```\n\nHTTPClientException.java\n```java\npackage core.framework.http;\n\nimport core.framework.log.ErrorCode;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\npublic final class HTTPClientException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = -7577571026619549539L;\n\n    private final String errorCode;\n\n    public HTTPClientException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nHTTPHeaders.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic final class HTTPHeaders {\n    public static final String ACCEPT = \"Accept\";\n    public static final String AUTHORIZATION = \"Authorization\";\n    public static final String CACHE_CONTROL = \"Cache-Control\";\n    public static final String CONTENT_TYPE = \"Content-Type\";\n    public static final String LOCATION = \"Location\";\n    public static final String USER_AGENT = \"User-Agent\";\n}\n```\n\nHTTPMethod.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic enum HTTPMethod {\n    HEAD, GET, POST, PUT, DELETE, OPTIONS, TRACE, CONNECT, PATCH\n}\n```\n\nHTTPRequest.java\n```java\npackage core.framework.http;\n\nimport core.framework.internal.http.HTTPRequestHelper;\nimport core.framework.util.Encodings;\nimport core.framework.util.Maps;\nimport core.framework.util.Strings;\n\nimport java.time.Duration;\nimport java.util.Map;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class HTTPRequest {\n    public final HTTPMethod method;\n    public final Map<String, String> params = Maps.newLinkedHashMap();\n    public final Map<String, String> headers = Maps.newLinkedHashMap();    // make headers/params order deterministic\n    public String uri;\n    public byte[] body;\n    public ContentType contentType;\n    public Map<String, String> form;    // shortcut view only, doesn't impact final request\n\n    public Duration connectTimeout;\n    public Duration timeout;            // read and write timeout\n    public Duration slowOperationThreshold;\n\n    public HTTPRequest(HTTPMethod method, String uri) {\n        this.method = method;\n        this.uri = uri;\n    }\n\n    public void accept(ContentType contentType) {\n        headers.put(HTTPHeaders.ACCEPT, contentType.toString());\n    }\n\n    public void basicAuth(String user, String password) {\n        headers.put(HTTPHeaders.AUTHORIZATION, \"Basic \" + Encodings.base64(user + ':' + password));\n    }\n\n    public void bearerAuth(String token) {\n        headers.put(HTTPHeaders.AUTHORIZATION, \"Bearer \" + token);\n    }\n\n    public void body(byte[] body, ContentType contentType) {\n        this.body = body;\n        this.contentType = contentType;\n        headers.put(HTTPHeaders.CONTENT_TYPE, contentType.toString());\n    }\n\n    public void body(String body, ContentType contentType) {\n        byte[] bytes = body.getBytes(contentType.charset().orElse(UTF_8));\n        body(bytes, contentType);\n    }\n\n    public void form(Map<String, String> form) {\n        if (method != HTTPMethod.POST) throw new Error(\"form must be used with POST, method=\" + method);\n        this.form = form;\n        var builder = new StringBuilder(256);\n        HTTPRequestHelper.urlEncoding(builder, form);\n        body(Strings.bytes(builder.toString()), ContentType.APPLICATION_FORM_URLENCODED);\n    }\n\n    public String requestURI() {\n        if (params.isEmpty()) return uri;\n\n        var builder = new StringBuilder(256).append(uri).append(uri.indexOf('?') > -1 ? '&' : '?');\n        HTTPRequestHelper.urlEncoding(builder, params);\n        return builder.toString();\n    }\n}\n```\n\nHTTPResponse.java\n```java\npackage core.framework.http;\n\nimport java.nio.charset.Charset;\nimport java.util.Map;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class HTTPResponse {\n    public final int statusCode;\n    public final byte[] body;\n    public final Map<String, String> headers;   // headers key is case insensitive\n    public final ContentType contentType;\n\n    public HTTPResponse(int statusCode, Map<String, String> headers, byte[] body) {\n        this.statusCode = statusCode;\n        this.headers = headers;\n        this.body = body;\n\n        String contentType = headers.get(HTTPHeaders.CONTENT_TYPE);\n        this.contentType = contentType == null ? null : ContentType.parse(contentType);\n    }\n\n    public String text() {\n        Charset charset = UTF_8;\n        if (contentType != null) charset = contentType.charset().orElse(UTF_8);\n        return new String(body, charset);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package inject."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.inject:\n\nInject.java\n```java\npackage core.framework.inject;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Inject {\n}\n```\n\nNamed.java\n```java\npackage core.framework.inject;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Named {\n    String value();\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package json."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.json:\n\nBean.java\n```java\npackage core.framework.json;\n\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.Validator;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class Bean {\n    private static final Map<Class<?>, Context<?>> CONTEXT = new HashMap<>(); // always requires register beanClass during startup, so not be thread safe\n\n    public static void register(Class<?> beanClass) {\n        CONTEXT.compute(beanClass, (key, value) -> {\n            if (value != null) throw new Error(\"bean class is already registered, beanClass=\" + key.getCanonicalName());\n            new JSONClassValidator(key).validate();\n            return new Context<>(beanClass);\n        });\n    }\n\n    public static <T> T fromJSON(Class<T> beanClass, String json) {\n        Context<T> context = context(beanClass);\n        try {\n            T instance = context.reader.fromJSON(json);\n            context.validator.validate(instance, false);\n            return instance;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T> String toJSON(T bean) {\n        Context<T> context = context(bean.getClass());\n\n        context.validator.validate(bean, false);\n        return context.writer.toJSONString(bean);\n    }\n\n    private static <T> Context<T> context(Class<?> beanClass) {\n        @SuppressWarnings(\"unchecked\")\n        Context<T> context = (Context<T>) CONTEXT.get(beanClass);\n        if (context == null) throw new Error(\"bean class is not registered, beanClass=\" + beanClass.getCanonicalName());\n        return context;\n    }\n\n    private static class Context<T> {\n        final JSONReader<T> reader;\n        final JSONWriter<T> writer;\n        final Validator<T> validator;\n\n        Context(Class<T> beanClass) {\n            reader = JSONMapper.reader(beanClass);\n            writer = JSONMapper.writer(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package kafka."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.kafka:\n\nBulkMessageHandler.java\n```java\npackage core.framework.kafka;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface BulkMessageHandler<T> {\n    void handle(List<Message<T>> messages) throws Exception;\n}\n```\n\nKafkaException.java\n```java\npackage core.framework.kafka;\n\n/**\n * @author neo\n */\npublic class KafkaException extends RuntimeException {\n    private static final long serialVersionUID = -3982633342908753686L;\n\n    public KafkaException(String message) {\n        super(message);\n    }\n}\n```\n\nMessage.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic final class Message<T> {\n    @Nullable\n    public final String key;\n    public final T value;\n\n    public Message(@Nullable String key, T value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```\n\nMessageHandler.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface MessageHandler<T> {\n    void handle(@Nullable String key, T value) throws Exception;\n}\n```\n\nMessagePublisher.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface MessagePublisher<T> {\n    // kafka uses sticky partitioning if key is null, refer to org.apache.kafka.clients.producer.internals.DefaultPartitioner\n    default void publish(T value) {\n        publish(null, value);\n    }\n\n    void publish(@Nullable String key, T value);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package log."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.log:\n\nActionLogContext.java\n```java\npackage core.framework.log;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class ActionLogContext {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ActionLogContext.class);\n\n    @Nullable\n    public static String id() {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return null;\n        return actionLog.id;\n    }\n\n    public static List<String> get(String key) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return List.of();\n        List<String> values = actionLog.context.get(key);\n        if (values == null) return List.of();\n        return values;\n    }\n\n    public static void put(String key, Object... values) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {    // here to check null is for unit testing the logManager.begin may not be called\n            actionLog.context(key, values);\n        }\n    }\n\n    // to collect numeric metrics, and can be aggregated by Elasticsearch/Kibana\n    public static void stat(String key, double value) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.stat(key, value);\n        }\n    }\n\n    public static int track(String operation, long elapsed) {\n        return track(operation, elapsed, 0, 0);\n    }\n\n    // return the total count of operations within current action\n    public static int track(String operation, long elapsed, int readEntries, int writeEntries) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return 1;    // be called without action context\n        return actionLog.track(operation, elapsed, readEntries, writeEntries);\n    }\n\n    public static void info(String key, Object... values) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.info(key, values);\n        }\n    }\n\n    public static void triggerTrace(boolean cascade) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            Trace trace = cascade ? Trace.CASCADE : Trace.CURRENT;\n            LOGGER.debug(\"trigger trace, trace={}\", trace);\n            actionLog.trace = trace;\n        }\n    }\n\n    // for long process, use this guidance to determine whether continue to do more work\n    @Nullable\n    public static Duration remainingProcessTime() {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return null;\n        return Duration.ofNanos(actionLog.remainingProcessTimeInNano());\n    }\n}\n```\n\nErrorCode.java\n```java\npackage core.framework.log;\n\n/**\n * @author neo\n */\npublic interface ErrorCode {\n    String errorCode();\n\n    default Severity severity() {\n        return Severity.ERROR;\n    }\n}\n```\n\nIOWarning.java\n```java\npackage core.framework.log;\n\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\n@Repeatable(IOWarnings.class)\npublic @interface IOWarning {   // currently only supports WS/Controller and MessageHandler methods, and Executor task inherits from parent\n    String operation();\n\n    int maxOperations() default -1;     // total times called by one action, if exceeds, it indicates bad practice (not CD friendly), better change design or split into multiple actions\n\n    int maxElapsedInMs() default -1;    // max elapsed of one operation\n\n    int maxReads() default -1;          // number of rows/entries returned by one query\n\n    int maxTotalReads() default -1;     // total entries read by one action\n\n    int maxTotalWrites() default -1;    // total entries updated by one action\n}\n```\n\nIOWarnings.java\n```java\npackage core.framework.log;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface IOWarnings {\n    IOWarning[] value();\n}\n```\n\nLogAppender.java\n```java\npackage core.framework.log;\n\nimport core.framework.log.message.ActionLogMessage;\nimport core.framework.log.message.StatMessage;\n\n/**\n * @author neo\n */\npublic interface LogAppender {\n    void append(ActionLogMessage message);\n\n    void append(StatMessage message);\n}\n```\n\nMarkers.java\n```java\npackage core.framework.log;\n\nimport core.framework.internal.log.marker.ErrorCodeMarker;\nimport org.slf4j.Marker;\n\n/**\n * @author neo\n */\npublic final class Markers {\n    public static Marker errorCode(String code) {\n        return new ErrorCodeMarker(code);\n    }\n}\n```\n\nActionLogMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport javax.annotation.Nullable;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class ActionLogMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"host\")\n    public String host;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"action\")\n    public String action;\n    @Property(name = \"correlation_ids\")\n    public List<String> correlationIds;\n    @Property(name = \"clients\")\n    public List<String> clients;\n    @Property(name = \"ref_ids\")\n    public List<String> refIds;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"elapsed\")\n    public Long elapsed;\n    @Property(name = \"context\")\n    public Map<String, List<String>> context;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"perf_stats\")\n    public Map<String, PerformanceStatMessage> performanceStats;\n    @Property(name = \"info\")\n    public Map<String, List<String>> info;\n    @Property(name = \"trace_log\")\n    public String traceLog;\n\n    @Nullable\n    public String firstContextValue(String key) {\n        List<String> values = context.get(key);\n        if (values == null) return null;\n        return values.get(0);\n    }\n}\n```\n\nEventMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class EventMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"received_time\")\n    public Instant receivedTime;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"action\")\n    public String action;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"context\")\n    public Map<String, String> context;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"info\")\n    public Map<String, String> info;\n    @Property(name = \"elapsed\")\n    public Long elapsed;\n}\n```\n\nLogTopics.java\n```java\npackage core.framework.log.message;\n\n/**\n * @author neo\n */\npublic final class LogTopics {\n    public static final String TOPIC_ACTION_LOG = \"action-log-v2\";\n    public static final String TOPIC_STAT = \"stat\";\n    public static final String TOPIC_EVENT = \"event\";\n}\n```\n\nPerformanceStatMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic class PerformanceStatMessage {\n    @Property(name = \"total_elapsed\")\n    public Long totalElapsed;\n    @Property(name = \"count\")\n    public Integer count;\n    @Property(name = \"read_entries\")\n    public Integer readEntries;\n    @Property(name = \"write_entries\")\n    public Integer writeEntries;\n}\n```\n\nStatMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class StatMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"host\")\n    public String host;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"info\")\n    public Map<String, String> info;\n}\n```\n\nSeverity.java\n```java\npackage core.framework.log;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic enum Severity {\n    @Property(name = \"WARN\")\n    WARN,\n\n    @Property(name = \"ERROR\")\n    ERROR\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package module."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.module:\n\nAccessConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.internal.web.http.IPv4Ranges;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class AccessConfig {\n    private final Logger logger = LoggerFactory.getLogger(AccessConfig.class);\n    private final ModuleContext context;\n\n    AccessConfig(ModuleContext context) {\n        this.context = context;\n    }\n\n    /**\n     * Set allowed cidr blocks, e.g. 192.168.0.1/24 or 192.168.1.1/32 for single ip\n     *\n     * @param cidrs cidr blocks\n     */\n    public void allow(List<String> cidrs) {\n        IPv4AccessControl accessControl = accessControl();\n        if (accessControl.allow != null) throw new Error(\"allowed cidrs is already configured\");\n\n        logger.info(\"allow http access, cidrs={}\", cidrsLogParam(cidrs, 5));\n        accessControl.allow = new IPv4Ranges(cidrs);\n    }\n\n    /**\n     * Set denied cidr blocks, e.g. 192.168.0.1/24 or 192.168.1.1/32 for single ip\n     *\n     * @param cidrs cidr blocks\n     */\n    public void deny(List<String> cidrs) {\n        IPv4AccessControl accessControl = accessControl();\n        if (accessControl.deny != null) throw new Error(\"denied cidrs is already configured\");\n\n        logger.info(\"deny http access, cidrs={}\", cidrsLogParam(cidrs, 5));\n        accessControl.deny = new IPv4Ranges(cidrs);\n    }\n\n    /**\n     * Set denied ip range list, one cidr per line, comment starts with '#'\n     *\n     * @param classpath cidr file\n     */\n    public void denyFromFile(String classpath) {\n        deny(new IPv4RangeFileParser(classpath).parse());\n    }\n\n    private IPv4AccessControl accessControl() {\n        if (context.httpServer.handler.accessControl == null) {\n            context.httpServer.handler.accessControl = new IPv4AccessControl();\n        }\n        return context.httpServer.handler.accessControl;\n    }\n\n    String cidrsLogParam(List<String> cidrs, int maxSize) {\n        if (cidrs.size() <= maxSize) return String.valueOf(cidrs);\n        return \"[\" + String.join(\", \", cidrs.subList(0, maxSize)) + \", ...]\";\n    }\n}\n```\n\nAPIClientConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.web.service.WebServiceClientInterceptor;\nimport core.framework.web.service.WebServiceClientProxy;\n\n/**\n * @author neo\n */\npublic final class APIClientConfig {     // returned from APIConfig, must be public to be called\n    private final WebServiceClientProxy client;\n\n    APIClientConfig(WebServiceClientProxy client) {\n        this.client = client;\n    }\n\n    public void intercept(WebServiceClientInterceptor interceptor) {\n        new InjectValidator(interceptor).validate();\n        client.intercept(interceptor);\n    }\n}\n```\n\nAPIConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.api.web.service.Path;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.bean.RequestBeanWriter;\nimport core.framework.internal.web.bean.ResponseBeanReader;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.internal.web.service.HTTPMethods;\nimport core.framework.internal.web.service.WebServiceClient;\nimport core.framework.internal.web.service.WebServiceClientBuilder;\nimport core.framework.internal.web.service.WebServiceControllerBuilder;\nimport core.framework.internal.web.service.WebServiceImplValidator;\nimport core.framework.internal.web.service.WebServiceInterfaceValidator;\nimport core.framework.util.ASCII;\nimport core.framework.web.Controller;\nimport core.framework.web.service.WebServiceClientProxy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.Method;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class APIConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(APIConfig.class);\n    ModuleContext context;\n    private HTTPClient httpClient;\n    private RequestBeanWriter writer;\n    private ResponseBeanReader reader;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        // default value is for internal api call only, targeting for kube env (with short connect timeout and more retries)\n        httpClient = HTTPClient.builder()\n            .userAgent(WebServiceClient.USER_AGENT)\n            .trustAll()\n            .connectTimeout(Duration.ofSeconds(2))\n            .timeout(Duration.ofSeconds(20))    // refer to: kube graceful shutdown period is 30s, db timeout is 15s\n            .keepAlive(Duration.ofMinutes(5))   // use longer keep alive timeout within cluster, to reduce connection creation overhead\n            .slowOperationThreshold(Duration.ofSeconds(10))\n            .maxRetries(5)\n            .build();\n        writer = new RequestBeanWriter();\n        reader = new ResponseBeanReader();\n    }\n\n    public <T> void service(Class<T> serviceInterface, T service) {\n        logger.info(\"create web service, interface={}\", serviceInterface.getCanonicalName());\n        var validator = new WebServiceInterfaceValidator(serviceInterface, context.beanClassValidator);\n        validator.requestBeanReader = context.httpServer.handler.requestBeanReader;\n        validator.responseBeanWriter = context.httpServer.handler.responseBeanWriter;\n        validator.validate();\n        new WebServiceImplValidator<>(serviceInterface, service).validate();\n        new InjectValidator(service).validate();\n        context.apiController.serviceInterfaces.add(serviceInterface);    // doesn't need to check duplicate, duplication will failed to register route\n\n        for (Method method : serviceInterface.getMethods()) {\n            HTTPMethod httpMethod = HTTPMethods.httpMethod(method);\n            String path = method.getDeclaredAnnotation(Path.class).value();\n            Controller controller = new WebServiceControllerBuilder<>(serviceInterface, service, method).build();\n            try {\n                Class<?> serviceClass = service.getClass();\n                Method targetMethod = serviceClass.getMethod(method.getName(), method.getParameterTypes());\n                String controllerInfo = serviceClass.getCanonicalName() + \".\" + targetMethod.getName();\n                String action = \"api:\" + ASCII.toLowerCase(httpMethod.name()) + \":\" + path;\n                context.httpServer.handler.route.add(httpMethod, path, new ControllerHolder(controller, targetMethod, controllerInfo, action, false));\n            } catch (NoSuchMethodException e) {\n                throw new Error(\"failed to find impl method\", e);\n            }\n        }\n    }\n\n    public <T> APIClientConfig client(Class<T> serviceInterface, String serviceURL) {\n        return client(serviceInterface, serviceURL, httpClient);\n    }\n\n    public <T> APIClientConfig client(Class<T> serviceInterface, String serviceURL, HTTPClient httpClient) {\n        T client = createClient(serviceInterface, serviceURL, httpClient);\n        context.beanFactory.bind(serviceInterface, null, client);\n        return new APIClientConfig((WebServiceClientProxy) client);\n    }\n\n    public <T> T createClient(Class<T> serviceInterface, String serviceURL, HTTPClient httpClient) {\n        logger.info(\"create web service client, interface={}, serviceURL={}\", serviceInterface.getCanonicalName(), serviceURL);\n        var validator = new WebServiceInterfaceValidator(serviceInterface, context.beanClassValidator);\n        validator.requestBeanWriter = writer;\n        validator.responseBeanReader = reader;\n        validator.validate();\n        return createWebServiceClient(serviceInterface, new WebServiceClient(serviceURL, httpClient, writer, reader));\n    }\n\n    <T> T createWebServiceClient(Class<T> serviceInterface, WebServiceClient webServiceClient) {\n        return new WebServiceClientBuilder<>(serviceInterface, webServiceClient).build();\n    }\n}\n```\n\nApp.java\n```java\npackage core.framework.module;\n\nimport com.sun.management.OperatingSystemMXBean;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.validate.Validator;\nimport core.framework.log.Markers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.management.ManagementFactory;\n\n/**\n * @author neo\n */\npublic abstract class App extends Module {\n    private final LogManager logManager = new LogManager();\n    private final Logger logger = LoggerFactory.getLogger(App.class);\n\n    public final void start() {\n        ActionLog actionLog = logManager.begin(\"=== startup begin ===\", null);\n        boolean failed = false;\n        try {\n            logContext(actionLog);\n            configure();\n            context.probe.check();    // readiness probe only needs to run on actual startup, not on test\n            logger.info(\"execute startup tasks\");\n            context.startupHook.initialize();\n            context.startupHook.start();\n            cleanup();\n            logger.info(\"startup completed, elapsed={}\", actionLog.elapsed());\n        } catch (Throwable e) {\n            logger.error(Markers.errorCode(\"FAILED_TO_START\"), \"app failed to start, error={}\", e.getMessage(), e);\n            failed = true;\n        } finally {\n            logManager.end(\"=== startup end ===\");\n        }\n        if (failed) {\n            System.exit(1);\n        }\n    }\n\n    void logContext(ActionLog actionLog) {\n        actionLog.action(\"app:start\");\n    }\n\n    public final void configure() {\n        logger.info(\"initialize framework\");\n        Runtime runtime = Runtime.getRuntime();\n        logger.info(\"availableProcessors={}, maxMemory={}\", runtime.availableProcessors(), ((OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()).getTotalMemorySize());\n        logger.info(\"jvmArgs={}\", String.join(\" \", ManagementFactory.getRuntimeMXBean().getInputArguments()));\n\n        context = new ModuleContext(logManager);\n        context.initialize();\n        runtime.addShutdownHook(new Thread(context.shutdownHook, \"shutdown\"));\n\n        logger.info(\"initialize application\");\n        initialize();\n        context.validate();\n    }\n\n    private void cleanup() {\n        // free static objects not used anymore\n        Validator.cleanup();\n        JSONMapper.cleanup();\n        if (!context.httpServer.siteManager.webDirectory.localEnv) {    // for local env, it may rebuild html template at runtime\n            DynamicInstanceBuilder.cleanup();\n        }\n    }\n}\n```\n\nCacheConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.cache.Cache;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.cache.CacheClassValidator;\nimport core.framework.internal.cache.CacheImpl;\nimport core.framework.internal.cache.CacheStore;\nimport core.framework.internal.cache.LocalCacheMetrics;\nimport core.framework.internal.cache.LocalCacheStore;\nimport core.framework.internal.cache.RedisCacheStore;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.internal.web.sys.CacheController;\nimport core.framework.util.ASCII;\nimport core.framework.util.Types;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class CacheConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(CacheConfig.class);\n    Map<String, CacheImpl<?>> caches;\n\n    private ModuleContext context;\n    private LocalCacheStore localCacheStore;\n    private CacheStore redisCacheStore;\n    private int maxLocalSize;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n\n        caches = new HashMap<>();\n        var controller = new CacheController(caches);\n        context.route(HTTPMethod.GET, \"/_sys/cache\", (LambdaController) controller::list, true);\n        context.route(HTTPMethod.GET, \"/_sys/cache/:name/:key\", (LambdaController) controller::get, true);\n        context.route(HTTPMethod.DELETE, \"/_sys/cache/:name/:key\", (LambdaController) controller::delete, true);\n    }\n\n    @Override\n    protected void validate() {\n        if (caches.isEmpty()) {\n            throw new Error(\"cache is configured but no cache added, please remove unnecessary config\");\n        }\n        // maxLocalSize() can be configured before localCacheStore is created, so set max size at end\n        if (maxLocalSize > 0 && localCacheStore != null) {\n            localCacheStore.maxSize = maxLocalSize;\n        }\n    }\n\n    public void local() {\n        if (localCacheStore != null || redisCacheStore != null) throw new Error(\"cache store is already configured, please configure only once\");\n        localCacheStore();\n    }\n\n    public void redis(String host) {\n        redis(host, null);\n    }\n\n    public void redis(String host, String password) {\n        if (localCacheStore != null || redisCacheStore != null) throw new Error(\"cache store is already configured, please configure only once\");\n        configureRedis(host, password);\n    }\n\n    public <T> CacheStoreConfig add(Class<T> cacheClass, Duration duration) {\n        if (localCacheStore == null && redisCacheStore == null) throw new Error(\"cache store is not configured, please configure first\");\n        logger.info(\"add cache, class={}, duration={}\", cacheClass.getCanonicalName(), duration);\n        new CacheClassValidator(cacheClass).validate();\n        String name = cacheName(cacheClass);\n        var cache = new CacheImpl<>(name, cacheClass, duration);\n        cache.cacheStore = redisCacheStore != null ? redisCacheStore : localCacheStore;\n        CacheImpl<?> previous = caches.putIfAbsent(name, cache);\n        if (previous != null) throw new Error(\"found duplicate cache name, name=\" + name);\n        context.beanFactory.bind(Types.generic(Cache.class, cacheClass), null, cache);\n\n        return new CacheStoreConfig(cache, this);\n    }\n\n    // number of objects to cache\n    public void maxLocalSize(int size) {\n        maxLocalSize = size;\n    }\n\n    String cacheName(Class<?> cacheClass) {\n        return ASCII.toLowerCase(cacheClass.getSimpleName());\n    }\n\n    void configureRedis(String host, String password) {\n        logger.info(\"create redis cache store, host={}\", host);\n\n        var redis = new RedisImpl(\"redis-cache\");\n        redis.host(host);\n        redis.password(password);\n        redis.timeout(Duration.ofSeconds(1));   // for cache, use shorter timeout than default redis config\n        context.probe.hostURIs.add(host);\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n        redisCacheStore = new RedisCacheStore(redis);\n    }\n\n    LocalCacheStore localCacheStore() {\n        if (localCacheStore == null) {\n            logger.info(\"create local cache store\");\n            var localCacheStore = new LocalCacheStore();\n            context.backgroundTask().scheduleWithFixedDelay(localCacheStore::cleanup, Duration.ofMinutes(5));\n            context.collector.metrics.add(new LocalCacheMetrics(localCacheStore));\n            this.localCacheStore = localCacheStore;\n        }\n        return localCacheStore;\n    }\n}\n```\n\nCacheStoreConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.cache.CacheImpl;\nimport core.framework.internal.cache.RedisCacheStore;\n\n/**\n * @author neo\n */\npublic class CacheStoreConfig {\n    private final CacheImpl<?> cache;\n    private final CacheConfig config;\n\n    CacheStoreConfig(CacheImpl<?> cache, CacheConfig config) {\n        this.cache = cache;\n        this.config = config;\n    }\n\n    // for rarely changed data, or stale data is tolerated\n    // or use kafka with custom groupId to evict keys\n    // otherwise refresh can also be done by restarting service if there is emergence\n    public void local() {\n        if (cache.cacheStore instanceof RedisCacheStore) {\n            cache.cacheStore = config.localCacheStore();\n        }\n    }\n}\n```\n\nCDNConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.ModuleContext;\n\n/**\n * @author neo\n */\npublic final class CDNConfig {\n    private final ModuleContext context;\n\n    CDNConfig(ModuleContext context) {\n        this.context = context;\n    }\n\n    public void host(String host) {\n        context.httpServer.siteManager.templateManager.cdnManager.host(host);\n    }\n}\n```\n\nDBConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.db.CloudAuthProvider;\nimport core.framework.db.Database;\nimport core.framework.db.IsolationLevel;\nimport core.framework.db.Repository;\nimport core.framework.internal.db.DatabaseImpl;\nimport core.framework.internal.db.cloud.AzureAuthProvider;\nimport core.framework.internal.db.cloud.GCloudAuthProvider;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.util.Lists;\nimport core.framework.util.Strings;\nimport core.framework.util.Types;\n\nimport java.time.Duration;\nimport java.util.List;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class DBConfig extends Config {\n    final List<Class<?>> entityClasses = Lists.newArrayList();\n    protected String name;\n    DatabaseImpl database;\n    private ModuleContext context;\n    private String url;\n    private boolean entityAdded;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n\n        var database = new DatabaseImpl(\"db\" + (name == null ? \"\" : \"-\" + name));\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> database.close());\n        context.backgroundTask().scheduleWithFixedDelay(database.pool::refresh, Duration.ofMinutes(10));\n        context.collector.metrics.add(new PoolMetrics(database.pool));\n        context.beanFactory.bind(Database.class, name, database);\n        this.database = database;\n    }\n\n    @Override\n    protected void validate() {\n        if (url == null) throw new Error(\"db url must be configured, name=\" + name);\n        if (!entityAdded)\n            throw new Error(\"db is configured but no repository/view added, please remove unnecessary config, name=\" + name);\n    }\n\n    public void url(String url) {\n        if (this.url != null) throw new Error(format(\"db url is already configured, name={}, url={}, previous={}\", name, url, this.url));\n        database.url(databaseURL(url));\n        this.url = url;\n    }\n\n    String databaseURL(String url) {\n        return url;\n    }\n\n    public void user(String user) {\n        if (user.startsWith(\"iam/\")) {\n            CloudAuthProvider provider = CloudAuthProvider.Provider.get();\n            if (provider == null) {\n                provider = provider(user);\n                CloudAuthProvider.Provider.set(provider);\n            }\n            database.authProvider = provider;\n            context.logManager.maskFields(\"access_token\");  // mask token from IAM http response, gcloud/azure all use JWT token\n        } else {\n            database.user = user;\n        }\n    }\n\n    CloudAuthProvider provider(String user) {\n        if (\"iam/gcloud\".equals(user)) {\n            return new GCloudAuthProvider();\n        } else if (user.startsWith(\"iam/azure/\")) {\n            String iamUser = user.substring(10);\n            if (Strings.isBlank(iamUser)) {\n                throw new Error(\"invalid azure iam user, user=\" + user);\n            }\n            return new AzureAuthProvider(iamUser);\n        }\n        throw new Error(\"unsupported cloud provider, value=\" + user);\n    }\n\n    public void password(String password) {\n        database.password = password;\n    }\n\n    public void poolSize(int minSize, int maxSize) {\n        database.pool.size(minSize, maxSize);\n    }\n\n    public void isolationLevel(IsolationLevel level) {\n        database.isolationLevel = level;\n    }\n\n    public void longTransactionThreshold(Duration threshold) {\n        database.operation.transactionManager.longTransactionThresholdInNanos = threshold.toNanos();\n    }\n\n    public void timeout(Duration timeout) {\n        database.timeout(timeout);\n    }\n\n    public void view(Class<?> viewClass) {\n        if (url == null) throw new Error(\"db url must be configured first, name=\" + name);\n        database.view(viewClass);\n        entityAdded = true;\n    }\n\n    public <T> Repository<T> repository(Class<T> entityClass) {\n        if (url == null) throw new Error(\"db url must be configured first, name=\" + name);\n        Repository<T> repository = database.repository(entityClass);\n        context.beanFactory.bind(Types.generic(Repository.class, entityClass), name, repository);\n        entityAdded = true;\n        entityClasses.add(entityClass);\n        return repository;\n    }\n}\n```\n\nHTTPConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.HTTPHost;\nimport core.framework.internal.web.HTTPIOHandler;\nimport core.framework.internal.web.bean.RequestBeanReader;\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.web.Controller;\nimport core.framework.web.ErrorHandler;\nimport core.framework.web.Interceptor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class HTTPConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(HTTPConfig.class);\n    ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n    }\n\n    public void route(HTTPMethod method, String path, Controller controller) {\n        if (HTTPIOHandler.HEALTH_CHECK_PATH.equals(path)) throw new Error(\"/health-check is reserved path\");\n        context.route(method, path, controller, false);\n    }\n\n    public void route(HTTPMethod method, String path, LambdaController controller) {\n        route(method, path, (Controller) controller);\n    }\n\n    public void bean(Class<?> beanClass) {\n        logger.info(\"register bean, class={}\", beanClass.getCanonicalName());\n        if (beanClass.isEnum()) {   // enum is usually declared to expose constants via /_sys/api, e.g. errorCodes, or pathParams used by controller directly\n//            context.beanClassValidator.beanClassNameValidator.validate(beanClass);\n            JSONClassValidator.validateEnum(beanClass);\n        } else {\n            registerBean(beanClass);\n        }\n        boolean added = context.apiController.beanClasses.add(beanClass);\n        if (!added) throw new Error(\"bean class is already registered, class=\" + beanClass.getCanonicalName());\n    }\n\n    // register http body bean and query param bean\n    private void registerBean(Class<?> beanClass) {\n        RequestBeanReader reader = context.httpServer.handler.requestBeanReader;\n        if (RequestBeanReader.isQueryParamBean(beanClass)) {\n            if (reader.containsQueryParam(beanClass)) {\n                throw new Error(\"query param bean class is already registered or referred by service interface, class=\" + beanClass.getCanonicalName());\n            }\n            reader.registerQueryParam(beanClass, context.beanClassValidator.beanClassNameValidator);\n        } else {\n            ResponseBeanWriter writer = context.httpServer.handler.responseBeanWriter;\n            if (reader.containsBean(beanClass) || writer.contains(beanClass)) {\n                throw new Error(\"bean class is already registered or referred by service interface, class=\" + beanClass.getCanonicalName());\n            }\n            reader.registerBean(beanClass, context.beanClassValidator);\n            writer.register(beanClass, context.beanClassValidator);\n        }\n    }\n\n    public void intercept(Interceptor interceptor) {\n        if (interceptor.getClass().isSynthetic())\n            throw new Error(\"interceptor class must not be anonymous class or lambda, please use static class, interceptorClass=\" + interceptor.getClass().getCanonicalName());\n        new InjectValidator(interceptor).validate();\n        context.httpServerConfig.interceptors.add(interceptor);\n    }\n\n    public void errorHandler(ErrorHandler handler) {\n        context.httpServer.handler.errorHandler.customErrorHandler = handler;\n    }\n\n    // host is in \"host:port\" or \"port\" format, e.g. 8080 or 127.0.0.1:8080\n    public void listenHTTP(String host) {\n        context.httpServerConfig.httpHost = HTTPHost.parse(host);\n    }\n\n    public void listenHTTPS(String host) {\n        context.httpServerConfig.httpsHost = HTTPHost.parse(host);\n    }\n\n    public LimitRateConfig limitRate() {\n        return context.config(LimitRateConfig.class, null);\n    }\n\n    /**\n     * Set max x-forwarded-for ips to prevent client ip spoofing, e.g. script clients send custom x-forwarded-for header to bypass rate limiting by ip.\n     * Default is 2 to fit common scenarios, e.g. Google LB(append 2 ips)->kube service, AWS->nginx->webapp\n     *\n     * @param maxIPs the max number for forwarded ips\n     */\n    public void maxForwardedIPs(int maxIPs) {\n        if (maxIPs < 1) throw new Error(\"maxIPs must be greater than 1, maxIPs=\" + maxIPs);\n        context.httpServer.handler.requestParser.clientIPParser.maxForwardedIPs = maxIPs;\n    }\n\n    public AccessConfig access() {\n        return new AccessConfig(context);\n    }\n\n    public void gzip() {\n        context.httpServerConfig.gzip = true;\n    }\n\n    // use backend timeout of cloud lb\n    public void maxProcessTime(Duration maxProcessTime) {\n        context.httpServer.handler.maxProcessTimeInNano = maxProcessTime.toNanos();\n    }\n\n    // to configure max body size for both regular post and multipart upload\n    public void maxEntitySize(long maxEntitySize) {\n        context.httpServerConfig.maxEntitySize = maxEntitySize;\n    }\n}\n```\n\nIPv4RangeFileParser.java\n```java\npackage core.framework.module;\n\nimport core.framework.util.ClasspathResources;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class IPv4RangeFileParser {\n    private final Logger logger = LoggerFactory.getLogger(IPv4RangeFileParser.class);\n    private final String classpath;\n\n    public IPv4RangeFileParser(String classpath) {\n        this.classpath = classpath;\n    }\n\n    // write cidr for each line\n    // comment line starts with '#'\n    public List<String> parse() {\n        logger.info(\"load ip range file, classpath={}\", classpath);\n\n        try (InputStream stream = ClasspathResources.stream(classpath);\n             var reader = new BufferedReader(new InputStreamReader(stream, UTF_8))) {\n            return reader.lines()\n                .filter(line -> !line.isBlank() && line.charAt(0) != '#')\n                .toList();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nIPv4RangePropertyValueParser.java\n```java\npackage core.framework.module;\n\nimport core.framework.util.Strings;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author neo\n */\npublic final class IPv4RangePropertyValueParser {\n    private final String value;\n\n    public IPv4RangePropertyValueParser(String value) {\n        this.value = value;\n    }\n\n    // support two formats,\n    // 1. cidr,cidr\n    // 2. name1: cidr, cidr; name2: cidr\n    public List<String> parse() {\n        if (Strings.isBlank(value)) return List.of();\n        if (value.indexOf(':') > 0) {\n            return parseSemicolonDelimited(value);\n        } else {\n            return parseCommaDelimited(value);\n        }\n    }\n\n    private List<String> parseCommaDelimited(String value) {\n        return Arrays.stream(Strings.split(value, ',')).map(String::strip).collect(Collectors.toList());\n    }\n\n    private List<String> parseSemicolonDelimited(String value) {\n        List<String> results = new ArrayList<>();\n        for (String item : Strings.split(value, ';')) {\n            if (Strings.isBlank(item)) continue;\n            int index = item.indexOf(':');\n            Arrays.stream(Strings.split(item.substring(index + 1), ','))\n                  .map(String::strip)\n                  .forEach(results::add);\n        }\n        return results;\n    }\n}\n```\n\nKafkaConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.kafka.KafkaURI;\nimport core.framework.internal.kafka.MessageListener;\nimport core.framework.internal.kafka.MessageProducer;\nimport core.framework.internal.kafka.MessagePublisherImpl;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.web.sys.KafkaController;\nimport core.framework.kafka.BulkMessageHandler;\nimport core.framework.kafka.MessageHandler;\nimport core.framework.kafka.MessagePublisher;\nimport core.framework.util.Types;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class KafkaConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(KafkaConfig.class);\n    String name;\n    MessageProducer producer;\n    private ModuleContext context;\n    private KafkaURI uri;\n    private MessageListener listener;\n    private boolean handlerAdded;\n    private int maxRequestSize = 1024 * 1024;   // default 1M, refer to org.apache.kafka.clients.producer.ProducerConfig.MAX_REQUEST_SIZE_CONFIG\n    private KafkaController controller;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n        controller = new KafkaController();\n    }\n\n    @Override\n    protected void validate() {\n        if (!handlerAdded)\n            throw new Error(\"kafka is configured, but no publisher/handler added, please remove unnecessary config, name=\" + name);\n        if (listener != null && listener.topics.isEmpty())\n            throw new Error(\"kafka listener is configured, but no handler added, please remove unnecessary config, name=\" + name);\n    }\n\n    public void uri(String uri) {\n        if (this.uri != null)\n            throw new Error(format(\"kafka uri is already configured, name={}, uri={}, previous={}\", name, uri, this.uri));\n        this.uri = new KafkaURI(uri);\n        // in kube env, it's ok to just check first pod dns of stateful set\n        context.probe.hostURIs.add(this.uri.bootstrapURIs.get(0));\n    }\n\n    // to make IoC simpler, each topic should have its own message class\n    public <T> MessagePublisher<T> publish(String topic, Class<T> messageClass) {\n        if (topic == null) throw new Error(\"topic must not be null\");\n        logger.info(\"publish, topic={}, messageClass={}, name={}\", topic, messageClass.getTypeName(), name);\n        if (uri == null) throw new Error(\"kafka uri must be configured first, name=\" + name);\n        context.beanClassValidator.validate(messageClass);\n        MessagePublisher<T> publisher = createMessagePublisher(topic, messageClass);\n        context.beanFactory.bind(Types.generic(MessagePublisher.class, messageClass), name, publisher);\n        context.apiController.topics.put(topic, messageClass);\n        handlerAdded = true;\n        return publisher;\n    }\n\n    <T> MessagePublisher<T> createMessagePublisher(String topic, Class<T> messageClass) {\n        if (producer == null) {\n            var producer = new MessageProducer(uri, name, maxRequestSize);\n            context.collector.metrics.add(producer.producerMetrics);\n            context.startupHook.initialize.add(producer::initialize);\n            context.shutdownHook.add(ShutdownHook.STAGE_4, producer::close);\n            controller.producer = producer;\n            context.route(HTTPMethod.POST, managementPathPattern(\"/topic/:topic/key/:key/publish\"), (LambdaController) controller::publish, true);\n            this.producer = producer;\n        }\n        return new MessagePublisherImpl<>(producer, topic, messageClass);\n    }\n\n    String managementPathPattern(String postfix) {\n        var builder = new StringBuilder(\"/_sys/kafka\");\n        if (name != null) builder.append('/').append(name);\n        builder.append(postfix);\n        return builder.toString();\n    }\n\n    public <T> void subscribe(String topic, Class<T> messageClass, MessageHandler<T> handler) {\n        subscribe(topic, messageClass, handler, null);\n    }\n\n    public <T> void subscribe(String topic, Class<T> messageClass, BulkMessageHandler<T> handler) {\n        subscribe(topic, messageClass, null, handler);\n    }\n\n    private <T> void subscribe(String topic, Class<T> messageClass, MessageHandler<T> handler, BulkMessageHandler<T> bulkHandler) {\n        if (handler == null && bulkHandler == null) throw new Error(\"handler must not be null\");\n        logger.info(\"subscribe, topic={}, messageClass={}, handlerClass={}, name={}\", topic, messageClass.getTypeName(), handler != null ? handler.getClass().getCanonicalName() : bulkHandler.getClass().getCanonicalName(), name);\n        context.beanClassValidator.validate(messageClass);\n        new InjectValidator(handler != null ? handler : bulkHandler).validate();\n        listener().subscribe(topic, messageClass, handler, bulkHandler);\n        handlerAdded = true;\n    }\n\n    private MessageListener listener() {\n        if (listener == null) {\n            if (uri == null) throw new Error(\"kafka uri must be configured first, name=\" + name);\n            var listener = new MessageListener(uri, name, context.logManager, context.shutdownHook.shutdownTimeoutInNano);\n            context.startupHook.start.add(listener::start);\n            context.shutdownHook.add(ShutdownHook.STAGE_0, timeout -> listener.shutdown());\n            context.shutdownHook.add(ShutdownHook.STAGE_1, listener::awaitTermination);\n            context.collector.metrics.add(listener.consumerMetrics);\n            controller.listener = listener;\n            context.route(HTTPMethod.POST, managementPathPattern(\"/topic/:topic/key/:key/handle\"), (LambdaController) controller::handle, true);\n            this.listener = listener;   // make lambda not refer to this class/field\n        }\n        return listener;\n    }\n\n    // by default listener use AppName as consumer group\n    // e.g. use Network.LOCAL_HOST_NAME to make every pod receives messages from topic, (local cache invalidation, web socket notification)\n    // use \"${service-name}-${label}\" to allow same service to be deployed for mutlitenancy\n    public void groupId(String groupId) {\n        listener().groupId = groupId;\n    }\n\n    public void concurrency(int concurrency) {\n        listener().concurrency = concurrency;\n    }\n\n    // to increase max message size, both producer and broker sides have size limitation\n    // for broker\n    // use \"--override message.max.bytes=size\", refer to https://kafka.apache.org/documentation/#message.max.bytes\n    // for producer\n    // refer to org.apache.kafka.clients.producer.ProducerConfig.MAX_REQUEST_SIZE_CONFIG\n    // producer checks uncompressed request size, broker checks compressed request (actual request) size\n    // if message size exceeds producer limit, it throws error within current action\n    // if exceeds broker limit, broker rejects the message, error only shows on KafkaCallback (console output on kafka producer thread), no warning on broker side\n    public void maxRequestSize(int size) {\n        if (size <= 0) throw new Error(\"max request size must be greater than 0, value=\" + size);\n        if (producer != null) throw new Error(\"kafka().maxRequestSize() must be configured before adding publisher\");\n        maxRequestSize = size;\n    }\n\n    public void longConsumerDelayThreshold(Duration threshold) {\n        listener().longConsumerDelayThresholdInNano = threshold.toNanos();\n    }\n\n    public void maxPoll(int maxRecords, int maxBytes) {\n        if (maxRecords <= 0) throw new Error(\"max poll records must be greater than 0, value=\" + maxRecords);\n        if (maxBytes <= 0) throw new Error(\"max poll bytes must be greater than 0, value=\" + maxBytes);\n        MessageListener listener = listener();\n        listener.maxPollRecords = maxRecords;\n        listener.maxPollBytes = maxBytes;\n    }\n\n    public void minPoll(int minBytes, Duration maxWaitTime) {\n        if (minBytes <= 0) throw new Error(\"min poll bytes must be greater than 0, value=\" + minBytes);\n        if (maxWaitTime == null || maxWaitTime.toMillis() <= 0) throw new Error(\"max wait time must be greater than 0, value=\" + maxWaitTime);\n        MessageListener listener = listener();\n        listener.minPollBytes = minBytes;\n        listener.maxWaitTime = maxWaitTime;\n    }\n}\n```\n\nLambdaController.java\n```java\npackage core.framework.module;\n\nimport core.framework.web.Controller;\n\nimport java.io.Serializable;\n\n/**\n * @author neo\n */\npublic interface LambdaController extends Controller, Serializable {\n    // due to in JDK, method reference does not have enclosing class/method info,\n    // and from JDK 12, ConstantPool can't be access unless run with \"--add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\"\n    // so here use another way to retrieve method reference controller info by serializing\n    // refer to ControllerInspector and git history for details\n}\n```\n\nLimitRateConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.LimitRateInterceptor;\nimport core.framework.internal.web.http.RateControl;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class LimitRateConfig extends Config {\n    private boolean rateControlGroupAdded;\n    private RateControl rateControl;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        rateControl = context.httpServer.handler.rateControl;\n        // save at max 5K group/ip combination per pod, about 800K memory, to adapt with more ips/cc attack, better defense with cloud infra based solution together\n        maxEntries(5000);\n        context.httpServerConfig.interceptors.add(new LimitRateInterceptor(rateControl));\n    }\n\n    @Override\n    protected void validate() {\n        if (!rateControlGroupAdded) {\n            throw new Error(\"limitRate is configured but no group added, please remove unnecessary config\");\n        }\n    }\n\n    // how many group/ip combinations to keep, 5000 is about 800K, 10K is about 1.8M\n    public void maxEntries(int entries) {\n        rateControl.maxEntries(entries);\n    }\n\n    // maintain maxPermits at most, fill permits by fillRate per interval\n    // e.g. add(\"group\", 10, 5, Duration.ofSeconds(1)) keeps 10 permits at most, fills 5 permits every second\n    // e.g. add(\"group\", 20, 10, Duration.ofMinutes(5)) keeps 20 permits at most, fills 10 permits every 5 minutes\n    public void add(String group, int maxPermits, int fillRate, Duration interval) {\n        rateControl.config(group, maxPermits, fillRate, interval);\n        rateControlGroupAdded = true;\n    }\n}\n```\n\nLogConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.kafka.KafkaURI;\nimport core.framework.internal.log.CollectStatTask;\nimport core.framework.internal.log.appender.ConsoleAppender;\nimport core.framework.internal.log.appender.KafkaAppender;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.log.LogAppender;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class LogConfig extends Config {\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n    }\n\n    public void appendToConsole() {\n        appender(new ConsoleAppender());\n    }\n\n    public void appendToKafka(String uri) {\n        var appender = new KafkaAppender(new KafkaURI(uri));\n        appender(appender);\n        context.startupHook.start.add(appender::start);\n        context.shutdownHook.add(ShutdownHook.STAGE_7, appender::stop);\n        context.collector.metrics.add(appender.producerMetrics);\n    }\n\n    public void appender(LogAppender appender) {\n        if (context.logManager.appender != null) throw new Error(\"log appender is already set, appender=\" + context.logManager.appender.getClass().getSimpleName());\n        context.logManager.appender = appender;\n        context.backgroundTask().scheduleWithFixedDelay(new CollectStatTask(appender, context.collector), Duration.ofSeconds(10));\n    }\n\n    public void maskFields(String... fields) {\n        context.logManager.maskFields(fields);\n    }\n}\n```\n\nModule.java\n```java\npackage core.framework.module;\n\nimport core.framework.async.Task;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic abstract class Module {\n    private final Logger logger = LoggerFactory.getLogger(Module.class);\n\n    protected ModuleContext context;\n\n    protected void load(Module module) {\n        logger.info(\"load module, module={}\", module.getClass().getName());\n        module.context = context;\n        module.initialize();\n    }\n\n    public void onShutdown(Task task) {\n        context.shutdownHook.add(ShutdownHook.STAGE_5, timeout -> task.execute());\n    }\n\n    public void onStartup(Task task) {\n        // put all custom startup task on start stage\n        context.startupHook.start.add(task);\n    }\n\n    public <T> T bind(Class<T> instanceClass) {\n        T instance = context.beanFactory.create(instanceClass);\n        return context.bind(instanceClass, null, instance);\n    }\n\n    public <T> T bind(T instance) {\n        return bind(instance.getClass(), null, instance);\n    }\n\n    public <T> T bind(Class<? super T> instanceClass, T instance) {\n        return bind(instanceClass, null, instance);\n    }\n\n    public <T> T bind(Type type, @Nullable String name, T instance) {\n        context.beanFactory.inject(instance);\n        return context.bind(type, name, instance);\n    }\n\n    public <T> T bean(Class<T> instanceClass) {\n        return bean(instanceClass, null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T bean(Type type, @Nullable String name) {\n        return (T) context.beanFactory.bean(type, name);\n    }\n\n    public void loadProperties(String classpath) {\n        logger.info(\"load properties, classpath={}\", classpath);\n        context.propertyManager.properties.load(classpath);\n    }\n\n    public Optional<String> property(String key) {\n        return context.property(key);\n    }\n\n    public String requiredProperty(String key) {\n        return property(key).orElseThrow(() -> new Error(\"property key not found, key=\" + key));\n    }\n\n    public LogConfig log() {\n        return context.config(LogConfig.class, null);\n    }\n\n    public HTTPConfig http() {\n        return context.config(HTTPConfig.class, null);\n    }\n\n    public WebSocketConfig ws() {\n        return context.config(WebSocketConfig.class, null);\n    }\n\n    public SiteConfig site() {\n        return context.config(SiteConfig.class, null);\n    }\n\n    public CacheConfig cache() {\n        return context.config(CacheConfig.class, null);\n    }\n\n    public SchedulerConfig schedule() {\n        return context.config(SchedulerConfig.class, null);\n    }\n\n    public APIConfig api() {\n        return context.config(APIConfig.class, null);\n    }\n\n    public DBConfig db() {\n        return db(null);\n    }\n\n    public DBConfig db(String name) {\n        return context.config(DBConfig.class, name);\n    }\n\n    public RedisConfig redis() {\n        return context.config(RedisConfig.class, null);\n    }\n\n    public RedisConfig redis(String name) {\n        return context.config(RedisConfig.class, name);\n    }\n\n    public KafkaConfig kafka() {\n        return kafka(null);\n    }\n\n    public KafkaConfig kafka(String name) {\n        return context.config(KafkaConfig.class, name);\n    }\n\n    public <T extends Config> T config(Class<T> configClass) {\n        return config(configClass, null);\n    }\n\n    public <T extends Config> T config(Class<T> configClass, String name) {\n        return context.config(configClass, name);\n    }\n\n    public void highCPUUsageThreshold(double threshold) {\n        context.collector.highCPUUsageThreshold = threshold;\n    }\n\n    public void highHeapUsageThreshold(double threshold) {\n        context.collector.highHeapUsageThreshold = threshold;\n    }\n\n    // monitor java process VmRSS / cgroup ram limit\n    public void highMemUsageThreshold(double threshold) {\n        context.collector.highMemUsageThreshold = threshold;\n    }\n\n    protected abstract void initialize();\n}\n```\n\nRedisConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.redis.Redis;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class RedisConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(RedisConfig.class);\n    private ModuleContext context;\n    private Redis redis;\n    private String name;\n    private String host;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n        redis = createRedis();\n        context.beanFactory.bind(Redis.class, name, redis);\n    }\n\n    @Override\n    protected void validate() {\n        if (host == null) throw new Error(\"redis host must be configured, name=\" + name);\n    }\n\n    Redis createRedis() {\n        logger.info(\"create redis client, name={}\", name);\n        var redis = new RedisImpl(\"redis\" + (name == null ? \"\" : \"-\" + name));\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n        return redis;\n    }\n\n    public void host(String host) {\n        setHost(host);\n        this.host = host;\n    }\n\n    void setHost(String host) {\n        RedisImpl redis = (RedisImpl) this.redis;\n        redis.host(host);\n        context.probe.hostURIs.add(host);\n    }\n\n    public void password(String password) {\n        RedisImpl redis = (RedisImpl) this.redis;\n        redis.password(password);\n    }\n\n    public void poolSize(int minSize, int maxSize) {\n        ((RedisImpl) redis).pool.size(minSize, maxSize);\n    }\n\n    public void timeout(Duration timeout) {\n        ((RedisImpl) redis).timeout(timeout);\n    }\n\n    public Redis client() {\n        return redis;\n    }\n}\n```\n\nSchedulerConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.scheduler.DailyTrigger;\nimport core.framework.internal.scheduler.HourlyTrigger;\nimport core.framework.internal.scheduler.MonthlyTrigger;\nimport core.framework.internal.scheduler.Scheduler;\nimport core.framework.internal.scheduler.WeeklyTrigger;\nimport core.framework.internal.web.sys.SchedulerController;\nimport core.framework.scheduler.Job;\nimport core.framework.scheduler.Trigger;\nimport core.framework.util.Strings;\n\nimport java.time.Clock;\nimport java.time.DayOfWeek;\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.time.ZoneId;\n\n/**\n * @author neo\n */\npublic final class SchedulerConfig extends Config {\n    private Scheduler scheduler;\n    private boolean triggerAdded;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        var scheduler = new Scheduler(context.logManager);\n        context.startupHook.start.add(scheduler::start);\n        context.shutdownHook.add(ShutdownHook.STAGE_0, timeout -> scheduler.shutdown());\n        context.shutdownHook.add(ShutdownHook.STAGE_1, scheduler::awaitTermination);\n\n        var schedulerController = new SchedulerController(scheduler);\n        context.route(HTTPMethod.GET, \"/_sys/job\", (LambdaController) schedulerController::jobs, true);\n        context.route(HTTPMethod.POST, \"/_sys/job/:job\", (LambdaController) schedulerController::triggerJob, true);\n\n        this.scheduler = scheduler; // make lambda not refer to this class/field\n    }\n\n    public void timeZone(ZoneId zoneId) {\n        if (triggerAdded) throw new Error(\"schedule().timeZone() must be configured before adding trigger\");\n        if (zoneId == null) throw new Error(\"zoneId must not be null\");\n        scheduler.clock = Clock.system(zoneId);\n    }\n\n    public void fixedRate(String name, Job job, Duration rate) {\n        validateJob(name, job);\n\n        scheduler.addFixedRateTask(name, job, rate);\n        triggerAdded = true;\n    }\n\n    public void hourlyAt(String name, Job job, int minute, int second) {\n        trigger(name, job, new HourlyTrigger(minute, second));\n    }\n\n    public void dailyAt(String name, Job job, LocalTime time) {\n        trigger(name, job, new DailyTrigger(time));\n    }\n\n    public void weeklyAt(String name, Job job, DayOfWeek dayOfWeek, LocalTime time) {\n        trigger(name, job, new WeeklyTrigger(dayOfWeek, time));\n    }\n\n    public void monthlyAt(String name, Job job, int dayOfMonth, LocalTime time) {\n        trigger(name, job, new MonthlyTrigger(dayOfMonth, time));\n    }\n\n    public void trigger(String name, Job job, Trigger trigger) {\n        validateJob(name, job);\n\n        scheduler.addTriggerTask(name, job, trigger);\n        triggerAdded = true;\n    }\n\n    void validateJob(String name, Job job) {\n        Class<? extends Job> jobClass = job.getClass();\n        if (jobClass.isSynthetic())\n            throw new Error(Strings.format(\"job class must not be anonymous class or lambda, please create static class, name={}, jobClass={}\", name, jobClass.getCanonicalName()));\n        new InjectValidator(job).validate();\n    }\n}\n```\n\nSessionConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.internal.web.session.LocalSessionStore;\nimport core.framework.internal.web.session.RedisSessionStore;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class SessionConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(SessionConfig.class);\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        cookie(\"SessionId\", null);\n    }\n\n    public void timeout(Duration timeout) {\n        context.httpServer.siteManager.sessionManager.timeout(timeout);\n    }\n\n    public void cookie(String name, String domain) {\n        context.httpServer.siteManager.sessionManager.cookie(name, domain);\n        context.logManager.maskFields(name);\n    }\n\n    public void header(String name) {\n        context.httpServer.siteManager.sessionManager.header(name);\n        context.logManager.maskFields(name);\n    }\n\n    public void local() {\n        logger.info(\"create local session store\");\n        LocalSessionStore sessionStore = new LocalSessionStore();\n        context.backgroundTask().scheduleWithFixedDelay(sessionStore::cleanup, Duration.ofMinutes(30));\n        context.httpServer.siteManager.sessionManager.store(sessionStore);\n    }\n\n    public void redis(String host) {\n        logger.info(\"create redis session store, host={}\", host);\n\n        var redis = new RedisImpl(\"redis-session\");\n        redis.host(host);\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n\n        context.probe.hostURIs.add(host);\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.httpServer.siteManager.sessionManager.store(new RedisSessionStore(redis));\n    }\n}\n```\n\nSiteConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.IPv4Ranges;\nimport core.framework.internal.web.site.MessageImpl;\nimport core.framework.internal.web.site.StaticContentController;\nimport core.framework.internal.web.site.StaticDirectoryController;\nimport core.framework.internal.web.site.StaticFileController;\nimport core.framework.internal.web.site.WebSecurityInterceptor;\nimport core.framework.web.site.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class SiteConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(SiteConfig.class);\n    boolean messageConfigured;\n    private WebSecurityInterceptor webSecurityInterceptor;\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        context.httpServer.handler.requestParser.logSiteHeaders = true;\n    }\n\n    public SessionConfig session() {\n        return context.config(SessionConfig.class, null);\n    }\n\n    public CDNConfig cdn() {\n        return new CDNConfig(context);\n    }\n\n    public void message(List<String> paths, String... languages) {\n        if (messageConfigured) {\n            throw new Error(\"site().message() can only be configured once and must before adding template\");\n        }\n        messageConfigured = true;\n\n        context.httpServer.siteManager.message.load(paths, languages);\n        context.beanFactory.bind(Message.class, null, message(context.httpServer.siteManager.message));\n    }\n\n    Message message(MessageImpl message) {\n        return message;\n    }\n\n    public void template(String path, Class<?> modelClass) {\n        messageConfigured = true; // can not configure message() after adding template\n        context.httpServer.siteManager.templateManager.add(path, modelClass);\n    }\n\n    // this is only for POC or local testing, in cloud env, all static content should be served from LB + AWS S3/Google Storage/Azure Storage Account\n    public StaticContentConfig staticContent(String path) {\n        logger.info(\"add static content path, path={}\", path);\n        Path contentPath = context.httpServer.siteManager.webDirectory.path(path);\n        if (!Files.exists(contentPath, LinkOption.NOFOLLOW_LINKS)) throw new Error(\"path does not exist, path=\" + path);\n\n        StaticContentController controller;\n        if (Files.isDirectory(contentPath)) {\n            controller = new StaticDirectoryController(contentPath);\n            context.route(HTTPMethod.GET, path + \"/:path(*)\", controller, true);\n        } else {\n            controller = new StaticFileController(contentPath);\n            context.route(HTTPMethod.GET, path, controller, true);\n        }\n        return new StaticContentConfig(controller);\n    }\n\n    public WebSecurityConfig security() {\n        if (webSecurityInterceptor == null) {\n            webSecurityInterceptor = new WebSecurityInterceptor();\n            context.httpServerConfig.interceptors.add(webSecurityInterceptor);\n        }\n        return new WebSecurityConfig(webSecurityInterceptor);\n    }\n\n    public void allowAPI(List<String> cidrs) {\n        logger.info(\"allow /_sys/api access, cidrs={}\", cidrs);\n        context.apiController.accessControl.allow = new IPv4Ranges(cidrs);\n    }\n}\n```\n\nStaticContentConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.web.site.StaticContentController;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class StaticContentConfig {\n    private final StaticContentController controller;\n\n    StaticContentConfig(StaticContentController controller) {\n        this.controller = controller;\n    }\n\n    public void cache(Duration maxAge) {\n        if (maxAge == null || maxAge.getSeconds() <= 0) throw new Error(\"maxAge must be greater than 0, maxAge=\" + maxAge);\n        controller.cache(maxAge);\n    }\n}\n```\n\nSystemModule.java\n```java\npackage core.framework.module;\n\n/**\n * @author neo\n */\npublic final class SystemModule extends Module {\n    private final String propertyFileClasspath;\n\n    public SystemModule(String propertyFileClasspath) {\n        this.propertyFileClasspath = propertyFileClasspath;\n    }\n\n    @Override\n    protected void initialize() {\n        loadProperties(propertyFileClasspath);\n\n        configureHTTP();\n        configureCache();\n        configureLog();\n        property(\"sys.kafka.uri\").ifPresent(uri -> kafka().uri(uri));\n        configureDB();\n        property(\"sys.redis.host\").ifPresent(host -> redis().host(host));\n        configureSite();\n    }\n\n    private void configureCache() {\n        property(\"sys.cache.host\").ifPresent(host -> {\n            if (\"local\".equals(host)) {\n                cache().local();\n            } else {\n                cache().redis(host);\n            }\n        });\n    }\n\n    void configureSite() {\n        property(\"sys.session.host\").ifPresent(host -> {\n            if (\"local\".equals(host)) {\n                site().session().local();\n            } else {\n                site().session().redis(host);\n            }\n        });\n        property(\"sys.cdn.host\").ifPresent(host -> site().cdn().host(host));\n        property(\"sys.security.csp\").ifPresent(policy -> site().security().contentSecurityPolicy(policy));\n        property(\"sys.api.allowCIDR\").ifPresent(cidrs -> site().allowAPI(new IPv4RangePropertyValueParser(cidrs).parse()));\n    }\n\n    void configureHTTP() {\n        property(\"sys.http.listen\").ifPresent(host -> http().listenHTTP(host));\n        property(\"sys.https.listen\").ifPresent(host -> http().listenHTTPS(host));\n        property(\"sys.http.allowCIDR\").ifPresent(cidrs -> http().access().allow(new IPv4RangePropertyValueParser(cidrs).parse()));\n    }\n\n    private void configureLog() {\n        property(\"sys.log.appender\").ifPresent(appender -> {\n            if (\"console\".equals(appender)) {\n                log().appendToConsole();\n            } else {\n                log().appendToKafka(appender);\n            }\n        });\n    }\n\n    private void configureDB() {\n        property(\"sys.jdbc.url\").ifPresent(url -> db().url(url));\n        property(\"sys.jdbc.user\").ifPresent(user -> db().user(user));\n        property(\"sys.jdbc.password\").ifPresent(password -> db().password(password));\n    }\n}\n```\n\nWebSecurityConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.web.site.WebSecurityInterceptor;\n\n/**\n * @author neo\n */\npublic class WebSecurityConfig {\n    final WebSecurityInterceptor interceptor;\n\n    WebSecurityConfig(WebSecurityInterceptor interceptor) {\n        this.interceptor = interceptor;\n    }\n\n    public void contentSecurityPolicy(String policy) {\n        if (policy == null) throw new Error(\"policy must not be null\");\n        interceptor.contentSecurityPolicy = policy;\n    }\n}\n```\n\nWebSocketConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.HTTPIOHandler;\nimport core.framework.internal.web.websocket.ChannelHandler;\nimport core.framework.internal.web.websocket.WebSocketHandler;\nimport core.framework.internal.web.websocket.WebSocketMetrics;\nimport core.framework.web.websocket.ChannelListener;\nimport core.framework.web.websocket.WebSocketContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class WebSocketConfig extends Config {\n    // use http().limitRate().add(WebSocketConfig.WS_OPEN_GROUP, ...) to configure rate limiting for ws connections\n    public static final String WS_OPEN_GROUP = \"ws:open\";\n\n    private final Logger logger = LoggerFactory.getLogger(WebSocketConfig.class);\n    ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, @Nullable String name) {\n        this.context = context;\n    }\n\n    @Override\n    protected void validate() {\n        if (!context.httpServer.handler.rateControl.hasGroup(WS_OPEN_GROUP)) {\n            context.httpServer.handler.rateControl.config(WS_OPEN_GROUP, 10, 10, Duration.ofSeconds(30));\n        }\n    }\n\n    public <T, V> void listen(String path, Class<T> clientMessageClass, Class<V> serverMessageClass, ChannelListener<T, V> listener) {\n        if (HTTPIOHandler.HEALTH_CHECK_PATH.equals(path)) throw new Error(\"/health-check is reserved path\");\n        if (path.contains(\"/:\")) throw new Error(\"listener path must be static, path=\" + path);\n\n        if (listener.getClass().isSynthetic())\n            throw new Error(\"listener class must not be anonymous class or lambda, please create static class, listenerClass=\" + listener.getClass().getCanonicalName());\n        new InjectValidator(listener).validate();\n\n        logger.info(\"ws, path={}, clientMessageClass={}, serverMessageClass={}, listener={}\",\n            path, clientMessageClass.getCanonicalName(), serverMessageClass.getCanonicalName(), listener.getClass().getCanonicalName());\n\n        if (context.httpServer.handler.webSocketHandler == null) {\n            context.httpServer.handler.webSocketHandler = new WebSocketHandler(context.logManager, context.httpServer.siteManager.sessionManager, context.httpServer.handler.rateControl);\n            context.beanFactory.bind(WebSocketContext.class, null, context.httpServer.handler.webSocketHandler.context);\n\n            context.collector.metrics.add(new WebSocketMetrics(context.httpServer.handler.webSocketHandler));\n        }\n\n        context.beanClassValidator.validate(clientMessageClass);\n        context.beanClassValidator.validate(serverMessageClass);\n        context.apiController.beanClasses.add(clientMessageClass);\n        context.apiController.beanClasses.add(serverMessageClass);\n\n        var handler = new ChannelHandler<>(clientMessageClass, serverMessageClass, listener);\n        context.httpServer.handler.webSocketHandler.add(path, handler);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package redis."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.redis:\n\nRedis.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\n/**\n * @author neo\n */\npublic interface Redis {\n    @Nullable\n    String get(String key);\n\n    default void set(String key, String value) {\n        set(key, value, null, false);\n    }\n\n    default void set(String key, String value, Duration expiration) {\n        set(key, value, expiration, false);\n    }\n\n    boolean set(String key, String value, @Nullable Duration expiration, boolean onlyIfAbsent);\n\n    RedisSet set();\n\n    void expire(String key, Duration duration);\n\n    long del(String... keys);\n\n    long increaseBy(String key, long increment);\n\n    Map<String, String> multiGet(String... keys);\n\n    void multiSet(Map<String, String> values);\n\n    void forEach(String pattern, Consumer<String> consumer);\n\n    RedisHash hash();\n\n    RedisList list();\n\n    RedisSortedSet sortedSet();\n\n    RedisAdmin admin();\n\n    RedisHyperLogLog hyperLogLog();\n}\n```\n\nRedisAdmin.java\n```java\npackage core.framework.redis;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface RedisAdmin {\n    Map<String, String> info();\n}\n```\n\nRedisHash.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface RedisHash {\n    @Nullable\n    String get(String key, String field);\n\n    Map<String, String> getAll(String key);\n\n    void set(String key, String field, String value);\n\n    void multiSet(String key, Map<String, String> values);\n\n    long increaseBy(String key, String field, long increment);\n\n    long del(String key, String... fields);\n}\n```\n\nRedisHyperLogLog.java\n```java\npackage core.framework.redis;\n\n/**\n * @author tempo\n */\npublic interface RedisHyperLogLog {\n    boolean add(String key, String... values);\n\n    long count(String... keys);\n}\n```\n\nRedisList.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\n/**\n * @author rexthk\n */\npublic interface RedisList {\n    @Nullable\n    default String pop(String key) {\n        List<String> values = pop(key, 1);\n        return values.isEmpty() ? null : values.get(0);\n    }\n\n    List<String> pop(String key, int size);\n\n    // return the length of the list after the push operation\n    long push(String key, String... values);\n\n    default List<String> range(String key) {\n        return range(key, 0, -1);\n    }\n\n    List<String> range(String key, long start, long stop);\n\n    // trim the list, only keep most recent items\n    void trim(String key, int maxSize);\n}\n```\n\nRedisSet.java\n```java\npackage core.framework.redis;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic interface RedisSet {\n    long add(String key, String... values);\n\n    Set<String> members(String key);\n\n    boolean isMember(String key, String value);\n\n    long remove(String key, String... values);\n\n    // use pop(key, Long.MAX_VALUE) to pop all elements\n    Set<String> pop(String key, long count);\n\n    long size(String key);\n}\n```\n\nRedisSortedSet.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * @author tempo\n */\npublic interface RedisSortedSet {\n    // use long as score to keep precision, redis uses float type for score\n    default boolean add(String key, String value, long score) {\n        return add(key, Map.of(value, score), false) == 1;\n    }\n\n    int add(String key, Map<String, Long> values, boolean onlyIfAbsent);\n\n    long increaseScoreBy(String key, String value, long increment);\n\n    default Map<String, Long> range(String key) {\n        return range(key, 0, -1);\n    }\n\n    Map<String, Long> range(String key, long start, long stop);\n\n    default Map<String, Long> rangeByScore(String key, long minScore, long maxScore) {\n        return rangeByScore(key, minScore, maxScore, -1);\n    }\n\n    Map<String, Long> rangeByScore(String key, long minScore, long maxScore, long limit);\n\n    default Map<String, Long> popByScore(String key, long minScore, long maxScore) {\n        return popByScore(key, minScore, maxScore, -1);\n    }\n\n    Map<String, Long> popByScore(String key, long minScore, long maxScore, long limit);\n\n    @Nullable\n    default String popMin(String key) {\n        Map<String, Long> values = popMin(key, 1);\n        Iterator<String> iterator = values.keySet().iterator();\n        if (iterator.hasNext()) return iterator.next();\n        return null;\n    }\n\n    Map<String, Long> popMin(String key, long limit);\n\n    long remove(String key, String... values);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package scheduler."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.scheduler:\n\nJob.java\n```java\npackage core.framework.scheduler;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Job {\n    void execute(JobContext context) throws Exception;\n}\n```\n\nJobContext.java\n```java\npackage core.framework.scheduler;\n\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\npublic class JobContext {\n    public final String name;\n    public final ZonedDateTime scheduledTime;\n\n    public JobContext(String name, ZonedDateTime scheduledTime) {\n        this.name = name;\n        this.scheduledTime = scheduledTime;\n    }\n}\n```\n\nTrigger.java\n```java\npackage core.framework.scheduler;\n\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Trigger {\n    ZonedDateTime next(ZonedDateTime previous);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package template."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.template:\n\nHTMLTemplateEngine.java\n```java\npackage core.framework.template;\n\nimport core.framework.internal.template.CDNManager;\nimport core.framework.internal.template.HTMLTemplate;\nimport core.framework.internal.template.HTMLTemplateBuilder;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.source.ClasspathTemplateSource;\nimport core.framework.internal.template.source.StringTemplateSource;\nimport core.framework.internal.template.source.TemplateSource;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class HTMLTemplateEngine {\n    private final Logger logger = LoggerFactory.getLogger(HTMLTemplateEngine.class);\n    private final Map<String, HTMLTemplate> templates = Maps.newConcurrentHashMap();\n    private final CDNManager cdnManager = new CDNManager();\n\n    public String process(String name, Object model) {\n        var watch = new StopWatch();\n        try {\n            HTMLTemplate template = templates.get(name);\n            if (template == null) throw new Error(\"template not found, name=\" + name);\n            TemplateContext context = new TemplateContext(model, cdnManager);\n            return template.process(context);\n        } finally {\n            logger.debug(\"process, name={}, elapsed={}\", name, watch.elapsed());\n        }\n    }\n\n    public void add(String name, String template, Class<?> modelClass) {\n        add(new StringTemplateSource(name, template), modelClass);\n    }\n\n    public void add(String classpath, Class<?> modelClass) {\n        add(new ClasspathTemplateSource(classpath), modelClass);\n    }\n\n    private void add(TemplateSource source, Class<?> modelClass) {\n        var watch = new StopWatch();\n        String name = source.name();\n        try {\n            HTMLTemplate previous = templates.putIfAbsent(name, new HTMLTemplateBuilder(source, modelClass).build());\n            if (previous != null) throw new Error(\"template is already added, name=\" + name);\n        } finally {\n            logger.info(\"add, name={}, modelClass={}, elapsed={}\", name, modelClass.getCanonicalName(), watch.elapsed());\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package web."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.web:\n\nController.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Controller {\n    Response execute(Request request) throws Exception;\n}\n```\n\nCookieSpec.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.Objects;\n\n/**\n * @author neo\n */\npublic final class CookieSpec {\n    private static final Duration SESSION_SCOPE = Duration.ofSeconds(-1);\n\n    public final String name;\n    @Nullable\n    public String domain;\n    @Nullable\n    public String path;\n    public boolean httpOnly;\n    public boolean secure;\n    @Nullable\n    public Duration maxAge;\n    public boolean sameSite;\n\n    public CookieSpec(String name) {\n        this.name = name;\n    }\n\n    public CookieSpec httpOnly() {\n        httpOnly = true;\n        return this;\n    }\n\n    public CookieSpec domain(String domain) {\n        this.domain = domain;\n        return this;\n    }\n\n    public CookieSpec path(String path) {\n        this.path = path;\n        return this;\n    }\n\n    public CookieSpec secure() {\n        secure = true;\n        return this;\n    }\n\n    public CookieSpec maxAge(Duration maxAge) {\n        this.maxAge = maxAge;\n        return this;\n    }\n\n    public CookieSpec sessionScope() {\n        maxAge = SESSION_SCOPE;\n        return this;\n    }\n\n    public CookieSpec sameSite() {\n        sameSite = true;\n        return this;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null || getClass() != other.getClass()) return false;\n        CookieSpec spec = (CookieSpec) other;\n        return Objects.equals(name, spec.name)\n                && Objects.equals(domain, spec.domain)\n                && Objects.equals(path, spec.path);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, domain, path);\n    }\n}\n\n\n```\n\nErrorHandler.java\n```java\npackage core.framework.web;\n\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface ErrorHandler {\n    Optional<Response> handle(Request request, Throwable e);\n}\n```\n\nBadRequestException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.BAD_REQUEST)\npublic final class BadRequestException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = -2304226404736886782L;\n\n    private final String errorCode;\n\n    public BadRequestException(String message) {\n        super(message);\n        errorCode = \"BAD_REQUEST\";\n    }\n\n    public BadRequestException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public BadRequestException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nConflictException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.CONFLICT)\npublic final class ConflictException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 7787085179989898162L;\n\n    private final String errorCode;\n\n    public ConflictException(String message) {\n        super(message);\n        errorCode = \"CONFLICT\";\n    }\n\n    public ConflictException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public ConflictException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nForbiddenException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.FORBIDDEN)\npublic final class ForbiddenException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 5472429043879214361L;\n\n    private final String errorCode;\n\n    public ForbiddenException(String message) {\n        super(message);\n        errorCode = \"FORBIDDEN\";\n    }\n\n    public ForbiddenException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public ForbiddenException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nMethodNotAllowedException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.METHOD_NOT_ALLOWED)\npublic final class MethodNotAllowedException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 2349080664326196294L;\n\n    public MethodNotAllowedException(String message) {\n        super(message);\n    }\n\n    public MethodNotAllowedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"METHOD_NOT_ALLOWED\";\n    }\n}\n```\n\nNotFoundException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.NOT_FOUND)\npublic final class NotFoundException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 8663360723004690205L;\n\n    private final String errorCode;\n\n    public NotFoundException(String message) {\n        super(message);\n        errorCode = \"NOT_FOUND\";\n    }\n\n    public NotFoundException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nTooManyRequestsException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.TOO_MANY_REQUESTS)\npublic final class TooManyRequestsException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 6657854760603154454L;\n\n    public TooManyRequestsException(String message) {\n        super(message);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"TOO_MANY_REQUESTS\";\n    }\n}\n```\n\nUnauthorizedException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.UNAUTHORIZED)\npublic final class UnauthorizedException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 5545181864430282120L;\n\n    public UnauthorizedException(String message) {\n        super(message);\n    }\n\n    public UnauthorizedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"UNAUTHORIZED\";\n    }\n}\n```\n\nInterceptor.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Interceptor {\n    Response intercept(Invocation invocation) throws Exception;\n}\n```\n\nInvocation.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.lang.annotation.Annotation;\n\n/**\n * @author neo\n */\npublic interface Invocation {\n    @Nullable\n    <T extends Annotation> T annotation(Class<T> annotationClass);\n\n    WebContext context();\n\n    Response proceed() throws Exception;\n}\n```\n\nMultipartFile.java\n```java\npackage core.framework.web;\n\nimport java.nio.file.Path;\n\n/**\n * @author neo\n */\npublic final class MultipartFile {\n    public final Path path;\n    public final String fileName;\n    public final String contentType;\n\n    public MultipartFile(Path path, String fileName, String contentType) {\n        this.path = path;\n        this.fileName = fileName;\n        this.contentType = contentType;\n    }\n}\n```\n\nLimitRate.java\n```java\npackage core.framework.web.rate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target({TYPE, METHOD})\n@Retention(RUNTIME)\npublic @interface LimitRate {\n    String value();\n}\n```\n\nRequest.java\n```java\npackage core.framework.web;\n\nimport core.framework.http.HTTPMethod;\n\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Request {\n    String requestURL();  // original request url without decoding\n\n    String scheme();\n\n    String hostname();\n\n    String path();      // original path without decoding\n\n    HTTPMethod method();\n\n    Optional<String> header(String name);\n\n    String pathParam(String name);\n\n    Map<String, String> queryParams();\n\n    Map<String, String> formParams();\n\n    Map<String, MultipartFile> files();\n\n    Optional<byte[]> body();\n\n    <T> T bean(Class<T> beanClass);\n\n    String clientIP();\n\n    Optional<String> cookie(CookieSpec spec);\n\n    Session session();\n}\n```\n\nResponse.java\n```java\npackage core.framework.web;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPHeaders;\nimport core.framework.internal.web.response.BeanBody;\nimport core.framework.internal.web.response.ByteArrayBody;\nimport core.framework.internal.web.response.FileBody;\nimport core.framework.internal.web.response.ResponseImpl;\nimport core.framework.internal.web.response.TemplateBody;\nimport core.framework.internal.web.response.TextBody;\n\nimport javax.annotation.Nullable;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Response {\n    static Response text(String text) {\n        return new ResponseImpl(new TextBody(text))\n                .contentType(ContentType.TEXT_PLAIN);\n    }\n\n    static Response bean(Object bean) {\n        if (bean == null) throw new Error(\"bean must not be null\");\n        return new ResponseImpl(new BeanBody(bean))\n                .contentType(ContentType.APPLICATION_JSON);\n    }\n\n    static Response html(String templatePath, Object model) {\n        return html(templatePath, model, null);\n    }\n\n    static Response html(String templatePath, Object model, @Nullable String language) {\n        return new ResponseImpl(new TemplateBody(templatePath, model, language))\n                .contentType(ContentType.TEXT_HTML);\n    }\n\n    static Response empty() {\n        return new ResponseImpl(new ByteArrayBody(new byte[0])).status(HTTPStatus.NO_CONTENT);\n    }\n\n    static Response bytes(byte[] bytes) {\n        return new ResponseImpl(new ByteArrayBody(bytes))\n                .contentType(ContentType.APPLICATION_OCTET_STREAM);\n    }\n\n    static Response file(Path path) {\n        return new ResponseImpl(new FileBody(path));\n    }\n\n    static Response redirect(String url) {\n        return redirect(url, HTTPStatus.SEE_OTHER);\n    }\n\n    static Response redirect(String url, HTTPStatus redirectStatus) {\n        if (redirectStatus != HTTPStatus.SEE_OTHER\n                && redirectStatus != HTTPStatus.MOVED_PERMANENTLY\n                && redirectStatus != HTTPStatus.PERMANENT_REDIRECT\n                && redirectStatus != HTTPStatus.TEMPORARY_REDIRECT)\n            throw new Error(\"invalid redirect status, status=\" + redirectStatus);\n\n        return new ResponseImpl(new ByteArrayBody(new byte[0]))\n                .header(HTTPHeaders.LOCATION, url)\n                .status(redirectStatus);\n    }\n\n    HTTPStatus status();\n\n    Response status(HTTPStatus status);\n\n    Optional<String> header(String name);\n\n    Response header(String name, @Nullable String value);\n\n    Optional<ContentType> contentType();\n\n    Response contentType(ContentType contentType);\n\n    Response cookie(CookieSpec spec, @Nullable String value);\n}\n```\n\nRemoteServiceException.java\n```java\npackage core.framework.web.service;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\n/**\n * @author neo\n */\npublic final class RemoteServiceException extends RuntimeException implements ErrorCode {\n    private static final long serialVersionUID = 6935063785656278927L;\n\n    public final HTTPStatus status;\n    private final Severity severity;\n    private final String errorCode;\n\n    public RemoteServiceException(String message, Severity severity, String errorCode, HTTPStatus status) {\n        super(message);\n        this.severity = severity;\n        this.errorCode = errorCode;\n        this.status = status;\n    }\n\n    public RemoteServiceException(String message, Severity severity, String errorCode, HTTPStatus status, Throwable cause) {\n        super(message, cause);\n        this.severity = severity;\n        this.errorCode = errorCode;\n        this.status = status;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return severity;\n    }\n}\n```\n\nWebServiceClientInterceptor.java\n```java\npackage core.framework.web.service;\n\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\n\n/**\n * @author neo\n */\npublic interface WebServiceClientInterceptor {\n    default void onRequest(HTTPRequest request) {\n    }\n\n    default void onResponse(HTTPResponse response) {\n    }\n}\n```\n\nWebServiceClientProxy.java\n```java\npackage core.framework.web.service;\n\n/**\n * @author neo\n */\npublic interface WebServiceClientProxy {    // all dynamic webservice clients will impl this interface to support extension\n    void intercept(WebServiceClientInterceptor interceptor);\n}\n```\n\nSession.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Session {\n    Optional<String> get(String key);\n\n    void set(String key, @Nullable String value); // set value to null to remove key\n\n    void invalidate();\n}\n```\n\nSessionContext.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\npublic interface SessionContext {\n    // invalidate all session matches key=value\n    void invalidate(String key, String value);\n}\n```\n\nMessage.java\n```java\npackage core.framework.web.site;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface Message {\n    String get(String key, @Nullable String language);\n\n    default String get(String key) {\n        return get(key, null);\n    }\n}\n```\n\nWebDirectory.java\n```java\npackage core.framework.web.site;\n\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * @author neo\n */\npublic final class WebDirectory {\n    private final Logger logger = LoggerFactory.getLogger(WebDirectory.class);\n\n    private final Path root;\n    public boolean localEnv;\n\n    public WebDirectory() {\n        this.root = locateRootDirectory();\n    }\n\n    private Path locateRootDirectory() {\n        String value = System.getProperty(\"core.webPath\");\n        if (value != null) {\n            Path path = Paths.get(value).toAbsolutePath();\n            if (Files.isDirectory(path)) {\n                logger.info(\"found -Dcore.webPath as web directory, path={}\", path);\n                return path;\n            }\n        } else {\n            Path path = findLocalRootDirectory();\n            if (path != null) {\n                logger.info(\"found local web directory, this should only happen in local dev env or test, path={}\", path);\n                localEnv = true;\n                try {\n                    return path.toRealPath();\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n        }\n        logger.info(\"can not locate web directory\");\n        return null;\n    }\n\n    private Path findLocalRootDirectory() {\n        Path path = Paths.get(\"./src/main/dist/web\");\n        if (Files.isDirectory(path)) return path;\n        return null;\n    }\n\n    public Path path(String path) {\n        if (!Strings.startsWith(path, '/')) throw new Error(\"path must start with '/', path=\" + path);\n        return root().resolve(path.substring(1)).toAbsolutePath();\n    }\n\n    public Path root() {\n        if (root == null)\n            throw new Error(\"can not find web path, set working dir to module dir for local dev env, or check -Dcore.webPath for server env, workingDir=\" + System.getProperty(\"user.dir\"));\n        return root;\n    }\n}\n```\n\nWebContext.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface WebContext {\n    Object get(String key);     // context is used to pass value from interceptor to controller/ws, key will be static and deterministic, that's why here is designed to return Object, not Optional<T>\n\n    void put(String key, Object value);\n\n    Request request();\n\n    // to let ws assign cookie to response\n    void responseCookie(CookieSpec spec, @Nullable String value);\n}\n```\n\nChannel.java\n```java\npackage core.framework.web.websocket;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface Channel<V> {\n    void send(V message);\n\n    Context context();\n\n    void close();\n\n    void join(String room);\n\n    void leave(String room);\n\n    interface Context {\n        @Nullable\n        Object get(String key); // channel is stateful, context key usually be static put onConnect, so in most of the cases get(key) expects result, that's why here is designed to return Object, not Optional<T>\n\n        void put(String key, @Nullable Object value);\n    }\n}\n```\n\nChannelListener.java\n```java\npackage core.framework.web.websocket;\n\nimport core.framework.web.Request;\n\n/**\n * @author neo\n */\npublic interface ChannelListener<T, V> {\n    default void onConnect(Request request, Channel<V> channel) {\n    }\n\n    void onMessage(Channel<V> channel, T message);\n\n    default void onClose(Channel<V> channel, int code, String reason) {\n    }\n}\n```\n\nWebSocketContext.java\n```java\npackage core.framework.web.websocket;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic interface WebSocketContext {\n    <V> List<Channel<V>> all();\n\n    <V> List<Channel<V>> room(String name);\n}\n```"}]}
