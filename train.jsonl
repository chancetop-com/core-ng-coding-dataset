{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "In the CoreNG framework, how is an interface defined by CoreAPI?"}, {"role": "assistant", "content": "Example: \napi class example:\n```java\npackage app.kos.service.api;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.DELETE;\nimport core.framework.api.web.service.GET;\nimport core.framework.api.web.service.POST;\nimport core.framework.api.web.service.PUT;\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.api.web.service.ResponseStatus;\n\n/**  \n* @author stephen  \n*/ \npublic interface RunnerScannerWebService {\n    @POST\n    @ResponseStatus(HTTPStatus.CREATED)\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    void create(@PathParam(\"hdrId\") String hdrId, CreateScannerRequest request);\n    \n    @DELETE\n    @Path(\"/runner-scanner/scanner/:id\")\n    void delete(@PathParam(\"id\") String id);\n    \n    @PUT\n    @Path(\"/runner-scanner/scanner/:id\")\n    void update(@PathParam(\"id\") String id, UpdateScannerRequest request);\n\n    @GET\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    ListScannerResponse list(@PathParam(\"hdrId\") String hdrId);\n} \n```\nrequest class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class UpdateScannerRequest {\n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n\n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n\n    @NotNull\n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n``` \nresponse class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotNull;\nimport java.util.List;\n\n/**  \n* @author stephen  \n*/ \npublic class ListScannerResponse {\n    @NotNull\n    @Property(name = \"scanners\")\n    public List<ScannerView> scanners = List.of();\n} \n``` \nview class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class ScannerView { \n    @NotBlank\n    @Property(name = \"id\")\n    public String id;\n       \n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n \n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n     \n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n```\n"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-api in CoreNG framework."}, {"role": "assistant", "content": "Here is the source code of package core-ng-api:\ntree /mnt/d/wonder-core-ng-project/core-ng-api/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-api/src/main/java\n├── core\n│   └── framework\n│       └── api\n│           ├── http\n│           │   └── HTTPStatus.java\n│           ├── json\n│           │   └── Property.java\n│           ├── validate\n│           │   ├── Digits.java\n│           │   ├── Max.java\n│           │   ├── Min.java\n│           │   ├── NotBlank.java\n│           │   ├── NotNull.java\n│           │   ├── Pattern.java\n│           │   └── Size.java\n│           └── web\n│               └── service\n│                   ├── DELETE.java\n│                   ├── GET.java\n│                   ├── PATCH.java\n│                   ├── POST.java\n│                   ├── PUT.java\n│                   ├── Path.java\n│                   ├── PathParam.java\n│                   ├── QueryParam.java\n│                   └── ResponseStatus.java\n└── module-info.java\n\n9 directories, 19 files\n\nHTTPStatus.java\n```java\npackage core.framework.api.http;\n\n/**\n * @author neo\n */\npublic enum HTTPStatus {\n    OK(200),\n    CREATED(201),\n    ACCEPTED(202),\n    NO_CONTENT(204),\n    MOVED_PERMANENTLY(301),\n    FOUND(302),     // 302 Moved Temporarily, sometimes Found\n    SEE_OTHER(303),\n    NOT_MODIFIED(304),\n    TEMPORARY_REDIRECT(307),\n    PERMANENT_REDIRECT(308),\n    BAD_REQUEST(400),\n    UNAUTHORIZED(401),\n    FORBIDDEN(403),\n    NOT_FOUND(404),\n    METHOD_NOT_ALLOWED(405),\n    NOT_ACCEPTABLE(406),\n    CONFLICT(409),\n    GONE(410),\n    PRECONDITION_FAILED(412),\n    UNPROCESSABLE_ENTITY(422),\n    UPGRADE_REQUIRED(426),\n    TOO_MANY_REQUESTS(429),\n    INTERNAL_SERVER_ERROR(500),\n    BAD_GATEWAY(502),\n    SERVICE_UNAVAILABLE(503),\n    GATEWAY_TIMEOUT(504);\n\n    public final int code;\n\n    HTTPStatus(int code) {\n        this.code = code;\n    }\n}\n```\n\nProperty.java\n```java\npackage core.framework.api.json;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Property {\n    String name();\n}\n```\n\nDigits.java\n```java\npackage core.framework.api.validate;\n\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Digits can be used on numeric fields.\n *\n * @author chris\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Digits {\n    int integer() default -1; // maximum number of integral digits accepted for this number\n\n    int fraction() default -1; // maximum number of fractional digits accepted for this number\n\n    String message() default \"field out of bounds (<{integer} digits>.<{fraction} digits> expected), value={value}\";\n}\n```\n\nMax.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Max {\n    double value();\n\n    String message() default \"field must not be greater than {max}, value={value}\";\n}\n```\n\nMin.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Min {\n    double value();\n\n    String message() default \"field must not be less than {min}, value={value}\";\n}\n```\n\nNotBlank.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * used for String field, to check string is not blank, be aware of null is not treated as blank,\n * this is to validate if the value presents, it must not be blank string\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotBlank {\n    String message() default \"field must not be blank\";\n}\n```\n\nNotNull.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotNull {\n    String message() default \"field must not be null\";\n}\n```\n\nPattern.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Pattern {\n    String value();\n\n    String message() default \"field must match /{pattern}/, value={value}\";\n}\n```\n\nSize.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Size is used on String, List and Map.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Size {\n    int min() default -1;\n\n    int max() default -1;\n\n    String message() default \"size must be between {min} and {max}, size={value}\";\n}\n```\n\nDELETE.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface DELETE {\n}\n```\n\nGET.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface GET {\n}\n```\n\nPATCH.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PATCH {\n}\n```\n\nPath.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface Path {\n    String value();\n}\n```\n\nPathParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(PARAMETER)\n@Retention(RUNTIME)\npublic @interface PathParam {\n    String value();\n}\n```\n\nPOST.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface POST {\n}\n```\n\nPUT.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PUT {\n}\n```\n\nQueryParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface QueryParam {\n    String name();\n}\n```\n\nResponseStatus.java\n```java\npackage core.framework.api.web.service;\n\nimport core.framework.api.http.HTTPStatus;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target({TYPE, METHOD})\n@Retention(RUNTIME)\npublic @interface ResponseStatus {\n    HTTPStatus value() default HTTPStatus.OK;\n}\n```\n\nmodule-info.java\n```java\nmodule core.framework.api {\n    exports core.framework.api.web.service;\n    exports core.framework.api.http;\n    exports core.framework.api.json;\n    exports core.framework.api.validate;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-json."}, {"role": "assistant", "content": "Here is the source code of package core-ng-json:\ntree /mnt/d/wonder-core-ng-project/core-ng-json/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-json/src/main/java\n└── core\n    └── framework\n        ├── internal\n        │   └── json\n        │       ├── JSONAnnotationIntrospector.java\n        │       ├── JSONMapper.java\n        │       ├── JSONReader.java\n        │       └── JSONWriter.java\n        └── json\n            └── JSON.java\n\n6 directories, 5 files\n\nJSONAnnotationIntrospector.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedClass;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport core.framework.api.json.Property;\n\nimport java.io.Serial;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class JSONAnnotationIntrospector extends AnnotationIntrospector {\n    @Serial\n    private static final long serialVersionUID = 3638140740110527623L;\n\n    @Override\n    public Version version() {\n        return Version.unknownVersion();\n    }\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    @Override\n    public String[] findEnumValues(MapperConfig<?> config, AnnotatedClass annotatedClass, Enum<?>[] enumValues, String[] names) {\n        Map<String, String> mappings = null;\n        for (AnnotatedField field : annotatedClass.fields()) {\n            if (!field.getAnnotated().isEnumConstant()) continue;\n\n            Property enumValue = field.getAnnotation(Property.class);\n            if (enumValue == null) continue;\n\n            String value = enumValue.name();\n            if (value.isEmpty()) continue;\n\n            if (mappings == null) mappings = new HashMap<>();\n            mappings.put(field.getName(), value);\n        }\n\n        if (mappings != null) {\n            int length = enumValues.length;\n            for (int i = 0; i < length; i++) {\n                String name = enumValues[i].name();\n                String value = mappings.get(name);\n                if (value != null) names[i] = value;\n            }\n        }\n        return names;\n    }\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    private PropertyName propertyName(Annotated annotated) {\n        Property element = annotated.getAnnotation(Property.class);\n        if (element != null) {\n            return new PropertyName(element.name(), null);\n        }\n        return null;\n    }\n}\n```\n\nJSONMapper.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.StreamReadFeature;\nimport com.fasterxml.jackson.core.StreamWriteFeature;\nimport com.fasterxml.jackson.core.util.JsonRecyclerPools;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.MapperFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.json.JsonMapper;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.ZonedDateTimeSerializer;\nimport com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeFormatterBuilder;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.PUBLIC_ONLY;\nimport static java.time.format.DateTimeFormatter.ISO_INSTANT;\nimport static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\n\n/**\n * @author neo\n */\npublic class JSONMapper {\n    public static final ObjectMapper OBJECT_MAPPER = builder().build();\n    private static Map<Class<?>, JSONReader<?>> readers = new HashMap<>();\n    private static Map<Class<?>, JSONWriter<?>> writers = new HashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONReader<T> reader(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONReader<T>) readers.computeIfAbsent(beanClass, JSONReader::new);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONWriter<T> writer(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONWriter<T>) writers.computeIfAbsent(beanClass, JSONWriter::new);\n    }\n\n    public static void cleanup() {\n        readers = null;\n        writers = null;\n    }\n\n    // expose builder, to allow app build its own JSON mapper to parse external json, e.g. can be less strict\n    public static JsonMapper.Builder builder() {\n        JsonFactory jsonFactory = JsonFactory.builder()\n            .recyclerPool(JsonRecyclerPools.sharedLockFreePool())\n            .build();\n\n        // refer to com.fasterxml.jackson.databind.ObjectMapper.DEFAULT_BASE for default settings, e.g. cacheProvider\n        return JsonMapper.builder(jsonFactory)\n            .addModule(timeModule())\n            .defaultDateFormat(new StdDateFormat())\n            // disable value class loader to avoid jdk illegal reflection warning, requires JSON class/fields must be public\n            .addModule(new AfterburnerModule().setUseValueClassLoader(false))\n            // only detect public fields, refer to com.fasterxml.jackson.databind.introspect.VisibilityChecker.Std\n            .visibility(new VisibilityChecker.Std(NONE, NONE, NONE, NONE, PUBLIC_ONLY))\n            .enable(StreamReadFeature.USE_FAST_DOUBLE_PARSER)\n            .enable(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER)\n            .enable(StreamWriteFeature.USE_FAST_DOUBLE_WRITER)\n            .enable(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)\n            .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)\n            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n            // e.g. disable convert empty string to Integer null\n            .disable(MapperFeature.ALLOW_COERCION_OF_SCALARS)\n            .annotationIntrospector(new JSONAnnotationIntrospector())\n            .deactivateDefaultTyping();\n    }\n\n    private static JavaTimeModule timeModule() {\n        var module = new JavaTimeModule();\n\n        // redefine date time formatter to output nano seconds in at least 3 digits, which inline with ISO standard and ES standard\n        DateTimeFormatter localTimeFormatter = new DateTimeFormatterBuilder()\n            .parseStrict()\n            .appendValue(HOUR_OF_DAY, 2)\n            .appendLiteral(':')\n            .appendValue(MINUTE_OF_HOUR, 2)\n            .appendLiteral(':')\n            .appendValue(SECOND_OF_MINUTE, 2)\n            .appendFraction(NANO_OF_SECOND, 3, 9, true) // always output 3 digits of nano seconds (iso date format doesn't specify how many digits it should present, here always keep 3)\n            .toFormatter();\n\n        module.addSerializer(ZonedDateTime.class, new ZonedDateTimeSerializer(ISO_INSTANT));\n        module.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(ISO_LOCAL_DATE)\n            .appendLiteral('T')\n            .append(localTimeFormatter)\n            .toFormatter()));\n        module.addSerializer(LocalTime.class, new LocalTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(localTimeFormatter)\n            .toFormatter()));\n        return module;\n    }\n}\n```\n\nJSONReader.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.databind.ObjectReader;\n\nimport java.io.IOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONReader<T> {\n    // used internally, performance is top priority in design, reader is about 3~6% faster than mapper since type is pre determined\n    // refer to https://github.com/FasterXML/jackson-docs/wiki/Presentation:-Jackson-Performance\n    private final ObjectReader reader;\n\n    public JSONReader(Class<T> instanceClass) {\n        this.reader = JSONMapper.OBJECT_MAPPER.readerFor(instanceClass);\n    }\n\n    public T fromJSON(byte[] json) throws IOException {\n        return reader.readValue(json);\n    }\n\n    public T fromJSON(String json) throws IOException {\n        return reader.readValue(json);\n    }\n}\n```\n\nJSONWriter.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport core.framework.util.Strings;\n\nimport java.io.UncheckedIOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONWriter<T> {\n    private final ObjectWriter writer;\n\n    public JSONWriter(Class<T> instanceClass) {\n        this.writer = JSONMapper.OBJECT_MAPPER.writerFor(instanceClass);\n    }\n\n    // with jdk 11, write to String then covert to byte[] is faster than write to byte[]\n    // toJSON won't throw exception especially instance class will be validated before\n    public byte[] toJSON(T instance) {\n        try {\n            return Strings.bytes(writer.writeValueAsString(instance));\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public String toJSONString(T instance) {\n        try {\n            return writer.writeValueAsString(instance);\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nJSON.java\n```java\npackage core.framework.json;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Type;\n\nimport static core.framework.internal.json.JSONMapper.OBJECT_MAPPER;\n\n/**\n * @author neo\n */\npublic final class JSON {\n    public static <T> T fromJSON(Type instanceType, String json) {\n        try {\n            JavaType javaType = OBJECT_MAPPER.getTypeFactory().constructType(instanceType);\n            T result = OBJECT_MAPPER.readValue(json, javaType);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T> T fromJSON(Class<T> instanceClass, String json) {\n        try {\n            T result = OBJECT_MAPPER.readValue(json, instanceClass);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static String toJSON(Object instance) {\n        if (instance == null) throw new Error(\"instance must not be null\");\n        try {\n            return OBJECT_MAPPER.writeValueAsString(instance);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T extends Enum<?>> T fromEnumValue(Class<T> valueClass, String jsonValue) {\n        return OBJECT_MAPPER.convertValue(jsonValue, valueClass);\n    }\n\n    public static <T extends Enum<?>> String toEnumValue(T value) {\n        return OBJECT_MAPPER.convertValue(value, String.class);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-common."}, {"role": "assistant", "content": "Here is the source code of package core-ng-common:\ntree /mnt/d/wonder-core-ng-project/core-ng-common/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-common/src/main/java\n├── core\n│   └── framework\n│       └── util\n│           ├── ASCII.java\n│           ├── ClasspathResources.java\n│           ├── Encodings.java\n│           ├── Exceptions.java\n│           ├── Files.java\n│           ├── Lists.java\n│           ├── Maps.java\n│           ├── Network.java\n│           ├── Properties.java\n│           ├── Randoms.java\n│           ├── Sets.java\n│           ├── StopWatch.java\n│           ├── Strings.java\n│           ├── Threads.java\n│           └── Types.java\n└── javax\n    └── annotation\n        └── Nullable.java\n\n6 directories, 16 files\n\nASCII.java\n```java\npackage core.framework.util;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic final class ASCII {\n    // only convert ascii chars, faster than JDK String.toUpperCase due to JDK needs to handle UTF and locale\n    // refers to https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Ascii.java\n    public static String toUpperCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isLowerCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isLowerCase(ch)) {\n                        chars[j] = (char) (ch & 0x5F);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toUpperCase(char ch) {\n        if (isLowerCase(ch)) return (char) (ch & 0x5F);\n        return ch;\n    }\n\n    public static String toLowerCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isUpperCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isUpperCase(ch)) {\n                        chars[j] = (char) (ch ^ 0x20);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toLowerCase(char ch) {\n        if (isUpperCase(ch)) return (char) (ch ^ 0x20);\n        return ch;\n    }\n\n    public static boolean isLowerCase(char ch) {\n        return ch >= 'a' && ch <= 'z';\n    }\n\n    public static boolean isUpperCase(char ch) {\n        return ch >= 'A' && ch <= 'Z';\n    }\n\n    public static boolean isDigit(char ch) {\n        return ch >= '0' && ch <= '9';\n    }\n\n    public static boolean isLetter(char ch) {\n        return isLowerCase(ch) || isUpperCase(ch);\n    }\n}\n```\n\nClasspathResources.java\n```java\npackage core.framework.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.util.Iterator;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class ClasspathResources {\n    public static String text(String path) {\n        return new String(bytes(path), UTF_8);\n    }\n\n    public static byte[] bytes(String path) {\n        try (InputStream stream = stream(path)) {\n            return stream.readAllBytes();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static InputStream stream(String path) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Iterator<URL> urls = loader.getResources(path).asIterator();\n            return openStream(urls, path);\n        } catch (IOException e) {\n            throw new Error(\"can not load resource, path=\" + path, e);\n        }\n    }\n\n    static InputStream openStream(Iterator<URL> urls, String path) throws IOException {\n        if (urls.hasNext()) {\n            URL url = urls.next();\n            // to avoid have same resource name within different jars, as the order of loading jar is not determined on different env/os, we'd better avoid potential unexpected behavior\n            if (urls.hasNext()) throw new Error(\"found duplicate resources with same name, path=\" + path);\n            return url.openStream();\n        }\n        throw new Error(\"can not load resource, path=\" + path);\n    }\n}\n\n```\n\nEncodings.java\n```java\npackage core.framework.util;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.BitSet;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\n/**\n * @author neo\n */\npublic final class Encodings {\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    // refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent,\n    // refer to http://tools.ietf.org/html/rfc3986\n    private static final BitSet URI_UNESCAPED = new BitSet(128);\n\n    static {\n        for (int i = 'a'; i <= 'z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = '0'; i <= '9'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        URI_UNESCAPED.set('-');\n        URI_UNESCAPED.set('_');\n        URI_UNESCAPED.set('.');\n        URI_UNESCAPED.set('!');\n        URI_UNESCAPED.set('~');\n        URI_UNESCAPED.set('*');\n        URI_UNESCAPED.set('\'');\n        URI_UNESCAPED.set('(');\n        URI_UNESCAPED.set(')');\n    }\n\n    // refer to impl from org.springframework.web.util.HierarchicalUriComponents#encodeUriComponent\n    public static String uriComponent(String value) {\n        byte[] bytes = Strings.bytes(value);\n        int length = bytes.length;\n\n        for (int i = 0; i < length; i++) {\n            byte b1 = bytes[i];\n            if (b1 < 0 || !URI_UNESCAPED.get(b1)) {   // the bytes java returned is signed, but we only need to check ascii (0-127)\n                StringBuilder builder = new StringBuilder(length * 2);\n                if (i > 0) builder.append(value, 0, i); // unescaped bytes must be single byte char\n                for (int j = i; j < length; j++) {\n                    byte b2 = bytes[j];\n                    if (b2 >= 0 && URI_UNESCAPED.get(b2)) {\n                        builder.append((char) b2);\n                    } else {\n                        builder.append('%')\n                            .append(HEX_CHARS[(b2 >> 4) & 0xF])\n                            .append(HEX_CHARS[b2 & 0xF]);\n                    }\n                }\n                return builder.toString();\n            }\n        }\n        return value;\n    }\n\n    // refer to impl from org.springframework.web.util.UriUtils#decode\n    public static String decodeURIComponent(String value) {\n        int length = value.length();\n        int index = 0;\n        for (; index < length; index++) {\n            int ch = value.charAt(index);\n            if (ch == '%') break;\n        }\n        if (index == length) return value;\n\n        byte[] buffer = new byte[length];\n        for (int i = 0; i < index; i++) buffer[i] = (byte) value.charAt(i);\n        int position = index;\n\n        for (; index < length; index++) {\n            char ch = value.charAt(index);\n            if (ch == '%') {\n                if ((index + 2) >= length) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                char hex1 = value.charAt(index + 1);\n                char hex2 = value.charAt(index + 2);\n                int u = Character.digit(hex1, 16);\n                int l = Character.digit(hex2, 16);\n                if (u == -1 || l == -1) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                buffer[position] = (byte) ((u << 4) + l);\n                index += 2;\n            } else {\n                buffer[position] = (byte) ch;   // here assume value is valid uri encoded string, if it contains multi-bytes (which should be encoded), here will not give right result\n            }\n            position++;\n        }\n        return new String(buffer, 0, position, StandardCharsets.UTF_8);\n    }\n\n    public static String base64(String value) {\n        return base64(Strings.bytes(value));\n    }\n\n    public static String base64(byte[] value) {\n        return Base64.getEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64(String value) {\n        return Base64.getDecoder().decode(value);\n    }\n\n    public static String base64URLSafe(byte[] value) {\n        return Base64.getUrlEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64URLSafe(String value) {\n        return Base64.getUrlDecoder().decode(value);\n    }\n\n    public static String hex(byte[] bytes) {\n        var values = new byte[bytes.length * 2];\n        int i = 0;\n        for (byte value : bytes) {\n            values[i++] = (byte) HEX_CHARS[value >> 4 & 0xF];\n            values[i++] = (byte) HEX_CHARS[value & 0xF];\n        }\n        return new String(values, US_ASCII);\n    }\n}\n```\n\nExceptions.java\n```java\npackage core.framework.util;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n/**\n * @author neo\n */\npublic final class Exceptions {\n    public static String stackTrace(Throwable e) {\n        var writer = new StringWriter();\n        e.printStackTrace(new PrintWriter(writer));\n        return writer.toString();\n    }\n}\n```\n\nFiles.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.time.Instant;\nimport java.util.UUID;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.createDirectories;\nimport static java.nio.file.Files.getLastModifiedTime;\nimport static java.nio.file.Files.readAllBytes;\nimport static java.nio.file.Files.walkFileTree;\n\n/**\n * @author neo\n */\npublic final class Files {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Files.class);\n\n    public static String text(Path file) {\n        return new String(bytes(file), UTF_8);\n    }\n\n    public static byte[] bytes(Path file) {\n        var watch = new StopWatch();\n        try {\n            return readAllBytes(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"bytes, file={}, elapsed={}\", file, watch.elapsed());\n        }\n    }\n\n    public static void createDir(Path directory) {\n        try {\n            createDirectories(directory);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static void deleteDir(Path directory) {\n        var watch = new StopWatch();\n        try {\n            walkFileTree(directory, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\n                    delete(file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException e) {\n                    delete(dir);\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"deleteDir, directory={}, elapsed={}\", directory, watch.elapsed());\n        }\n    }\n\n    public static Path tempFile() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        return Paths.get(tempDir + \"/\" + UUID.randomUUID().toString() + \".tmp\");\n    }\n\n    public static Path tempDir() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        Path path = Paths.get(tempDir + \"/\" + UUID.randomUUID().toString());\n        createDir(path);\n        return path;\n    }\n\n    public static void delete(Path file) {\n        try {\n            java.nio.file.Files.delete(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static long size(Path file) {\n        try {\n            return java.nio.file.Files.size(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static Instant lastModified(Path file) {\n        try {\n            return getLastModifiedTime(file).toInstant();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nLists.java\n```java\npackage core.framework.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class Lists {\n    public static <T> List<T> newArrayList() {\n        return new ArrayList<>();\n    }\n}\n```\n\nMaps.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * @author neo\n */\npublic final class Maps {\n    public static <T, V> Map<T, V> newHashMap() {\n        return new HashMap<>();\n    }\n\n    public static <T, V> ConcurrentMap<T, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMap() {\n        return new LinkedHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMapWithExpectedSize(int size) {\n        return new LinkedHashMap<>(capacity(size));\n    }\n\n    public static <T, V> Map<T, V> newHashMapWithExpectedSize(int size) {\n        return new HashMap<>(capacity(size));\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    private static int capacity(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return capacity;\n    }\n\n    public static <T extends Enum<T>, V> Map<T, V> newEnumMap(Class<T> enumClass) {\n        return new EnumMap<>(enumClass);\n    }\n}\n```\n\nNetwork.java\n```java\npackage core.framework.util;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author neo\n */\npublic final class Network {    // in cloud env, the application vm or container stick with same host ip / name during entire lifecycle\n    public static final String LOCAL_HOST_ADDRESS;\n    public static final String LOCAL_HOST_NAME;\n\n    static {\n        try {\n            InetAddress address = InetAddress.getLocalHost();\n            LOCAL_HOST_ADDRESS = address.getHostAddress();\n            LOCAL_HOST_NAME = address.getHostName();\n        } catch (UnknownHostException e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\nProperties.java\n```java\npackage core.framework.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Properties {\n    final Map<String, String> properties = Maps.newHashMap();\n\n    public void load(String classpath) {\n        try (InputStream stream = ClasspathResources.stream(classpath);\n             var reader = new BufferedReader(new InputStreamReader(stream, UTF_8))) {\n            var properties = new java.util.Properties();\n            properties.load(reader);\n            properties.forEach((key, value) -> set((String) key, (String) value));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public Optional<String> get(String key) {\n        String value = properties.get(key);\n        if (!Strings.isBlank(value)) return Optional.of(value);\n        return Optional.empty();\n    }\n\n    public void set(String key, String value) {\n        String previous = this.properties.putIfAbsent(key, value);\n        if (previous != null) throw new Error(format(\"property already exists, key={}, previous={}, current={}\", key, previous, value));\n    }\n\n    public Set<String> keys() {\n        return properties.keySet();\n    }\n\n    public boolean containsKey(String key) {\n        return properties.containsKey(key);\n    }\n}\n```\n\nRandoms.java\n```java\npackage core.framework.util;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\n/**\n * @author neo\n */\npublic final class Randoms {\n    private static final String ALPHA_NUMERIC = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n    public static String alphaNumeric(int length) {\n        StringBuilder builder = new StringBuilder(length);\n        for (int i = 0; i < length; i++)\n            builder.append(ALPHA_NUMERIC.charAt(ThreadLocalRandom.current().nextInt(ALPHA_NUMERIC.length())));\n        return builder.toString();\n    }\n\n    // return next double, ranges in [min, max)\n    public static double nextDouble(double min, double max) {\n        return (max - min) * ThreadLocalRandom.current().nextDouble() + min;\n    }\n\n    // return next int, ranges in [min, max)\n    public static int nextInt(int min, int max) {\n        return min + ThreadLocalRandom.current().nextInt(max - min);\n    }\n}\n```\n\nSets.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author neo\n */\npublic final class Sets {\n    public static <T> Set<T> newHashSet() {\n        return new HashSet<>();\n    }\n\n    public static <T> Set<T> newConcurrentHashSet() {\n        return ConcurrentHashMap.newKeySet();\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    public static <T> Set<T> newHashSetWithExpectedSize(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return new HashSet<>(capacity);\n    }\n\n    // EnumSet provides EnumSet.of(values...) methods, use it directly when apply\n    public static <T extends Enum<T>> Set<T> newEnumSet(Class<T> enumClass) {\n        return EnumSet.noneOf(enumClass);\n    }\n}\n```\n\nStopWatch.java\n```java\npackage core.framework.util;\n\n/**\n * @author neo\n */\npublic final class StopWatch {\n    private long start;\n\n    public StopWatch() {\n        reset();\n    }\n\n    public void reset() {\n        start = System.nanoTime();\n    }\n\n    public long elapsed() {\n        long end = System.nanoTime();\n        return end - start;\n    }\n}\n```\n\nStrings.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.helpers.MessageFormatter;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Strings {\n    public static byte[] bytes(String text) {\n        return text.getBytes(UTF_8);\n    }\n\n    public static String format(String pattern, Object... params) {\n        return MessageFormatter.arrayFormat(pattern, params).getMessage();\n    }\n\n    public static int compare(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null && text2 == null) return 0;\n        if (text1 != null && text2 == null) return 1;\n        if (text1 == null) return -1;\n        return text1.compareTo(text2);\n    }\n\n    public static boolean isBlank(@Nullable String text) {\n        return text == null || text.isBlank();\n    }\n\n    public static boolean equals(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null) return text2 == null;\n        return text1.equals(text2);\n    }\n\n    @Nullable\n    public static String truncate(@Nullable String text, int maxLength) {\n        if (text == null) return null;\n        if (text.length() <= maxLength) return text;\n        return text.substring(0, maxLength);\n    }\n\n    @Nullable\n    public static String strip(@Nullable String text) {\n        if (text == null) return null;\n        return text.strip();\n    }\n\n    public static boolean startsWith(String text, char prefix) {\n        if (text.isEmpty()) return false;\n        return text.charAt(0) == prefix;\n    }\n\n    public static String[] split(String text, char delimiter) {\n        List<String> tokens = Lists.newArrayList();\n        int start = 0;\n        while (true) {\n            int next = text.indexOf(delimiter, start);\n            if (next == -1) break;\n            tokens.add(text.substring(start, next));\n            start = next + 1;\n        }\n        if (start == 0) return new String[]{text};\n        else tokens.add(text.substring(start));\n        return tokens.toArray(new String[0]);\n    }\n}\n```\n\nThreads.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class Threads {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Threads.class);\n\n    public static void sleepRoughly(Duration duration) {\n        long sleepTime = sleepTime(duration);\n        LOGGER.debug(\"sleep {} ms\", sleepTime);\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            LOGGER.debug(\"sleep is interrupted\", e);\n        }\n    }\n\n    static long sleepTime(Duration duration) {\n        long milliseconds = duration.toMillis();\n        double times = Randoms.nextDouble(0.8, 1.2); // +/-20% random\n        return (long) (milliseconds * times);\n    }\n}\n```\n\nTypes.java\n```java\npackage core.framework.util;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Supplier;\n\n/**\n * @author neo\n */\npublic final class Types {\n    public static Type generic(Class<?> rawType, Type... arguments) {\n        return new ParameterizedTypeImpl(rawType, arguments);\n    }\n\n    public static Type optional(Type valueType) {\n        return generic(Optional.class, valueType);\n    }\n\n    public static Type list(Type valueType) {\n        return generic(List.class, valueType);\n    }\n\n    public static Type map(Type keyType, Type valueType) {\n        return generic(Map.class, keyType, valueType);\n    }\n\n    public static Type supplier(Type valueType) {\n        return generic(Supplier.class, valueType);\n    }\n\n    static final class ParameterizedTypeImpl implements ParameterizedType {\n        private final Type rawType;\n        private final Type[] arguments;\n\n        ParameterizedTypeImpl(Class<?> rawType, Type... arguments) {\n            this.rawType = rawType;\n            this.arguments = arguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return arguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n\n        // refer to sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.hashCode, must return same hashcode as builtin type\n        @Override\n        public int hashCode() {\n            return Arrays.hashCode(arguments) ^ rawType.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (!(other instanceof ParameterizedType that)) return false;\n\n            return Objects.equals(rawType, that.getRawType())\n                   && that.getOwnerType() == null\n                   && Arrays.equals(arguments, that.getActualTypeArguments());\n        }\n\n        @Override\n        public String toString() {\n            var builder = new StringBuilder(rawType.getTypeName()).append('<');\n\n            for (int i = 0; i < arguments.length; i++) {\n                if (i > 0) builder.append(\", \");\n                builder.append(arguments[i].getTypeName());\n            }\n\n            builder.append('>');\n            return builder.toString();\n        }\n    }\n}\n```\n\nNullable.java\n```java\npackage javax.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * help IDE (Intellij) to do nullability analysis﻿\n * <p>\n * refer to https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html#nullable\n *\n * @author neo\n */\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\npublic @interface Nullable {\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": ""}, {"role": "assistant", "content": }]}