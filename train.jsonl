{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "In the CoreNG framework, how is an interface defined by CoreAPI?"}, {"role": "assistant", "content": "Example: \napi class example:\n```java\npackage app.kos.service.api;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.DELETE;\nimport core.framework.api.web.service.GET;\nimport core.framework.api.web.service.POST;\nimport core.framework.api.web.service.PUT;\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.api.web.service.ResponseStatus;\n\n/**  \n* @author stephen  \n*/ \npublic interface RunnerScannerWebService {\n    @POST\n    @ResponseStatus(HTTPStatus.CREATED)\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    void create(@PathParam(\"hdrId\") String hdrId, CreateScannerRequest request);\n    \n    @DELETE\n    @Path(\"/runner-scanner/scanner/:id\")\n    void delete(@PathParam(\"id\") String id);\n    \n    @PUT\n    @Path(\"/runner-scanner/scanner/:id\")\n    void update(@PathParam(\"id\") String id, UpdateScannerRequest request);\n\n    @GET\n    @Path(\"/runner-scanner/hdr/:hdrId/scanner\")\n    ListScannerResponse list(@PathParam(\"hdrId\") String hdrId);\n} \n```\nrequest class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class UpdateScannerRequest {\n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n\n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n\n    @NotNull\n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n``` \nresponse class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotNull;\nimport java.util.List;\n\n/**  \n* @author stephen  \n*/ \npublic class ListScannerResponse {\n    @NotNull\n    @Property(name = \"scanners\")\n    public List<ScannerView> scanners = List.of();\n} \n``` \nview class example: \n```java \npackage app.kos.service.api.runnerscanner;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\n\n/**  \n* @author stephen  \n*/ \npublic class ScannerView { \n    @NotBlank\n    @Property(name = \"id\")\n    public String id;\n       \n    @NotNull\n    @Property(name = \"connected\")\n    public Boolean connected;\n \n    @NotNull\n    @NotBlank\n    @Property(name = \"name\")\n    public String name;\n     \n    @Property(name = \"battery_capacity\")\n    public Double batteryCapacity;\n} \n```\n"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-api."}, {"role": "assistant", "content": "Here is the source code of package core-ng-api:\ntree /mnt/d/wonder-core-ng-project/core-ng-api/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-api/src/main/java\n├── core\n│   └── framework\n│       └── api\n│           ├── http\n│           │   └── HTTPStatus.java\n│           ├── json\n│           │   └── Property.java\n│           ├── validate\n│           │   ├── Digits.java\n│           │   ├── Max.java\n│           │   ├── Min.java\n│           │   ├── NotBlank.java\n│           │   ├── NotNull.java\n│           │   ├── Pattern.java\n│           │   └── Size.java\n│           └── web\n│               └── service\n│                   ├── DELETE.java\n│                   ├── GET.java\n│                   ├── PATCH.java\n│                   ├── POST.java\n│                   ├── PUT.java\n│                   ├── Path.java\n│                   ├── PathParam.java\n│                   ├── QueryParam.java\n│                   └── ResponseStatus.java\n└── module-info.java\n\n9 directories, 19 files\n\nHTTPStatus.java\n```java\npackage core.framework.api.http;\n\n/**\n * @author neo\n */\npublic enum HTTPStatus {\n    OK(200),\n    CREATED(201),\n    ACCEPTED(202),\n    NO_CONTENT(204),\n    MOVED_PERMANENTLY(301),\n    FOUND(302),     // 302 Moved Temporarily, sometimes Found\n    SEE_OTHER(303),\n    NOT_MODIFIED(304),\n    TEMPORARY_REDIRECT(307),\n    PERMANENT_REDIRECT(308),\n    BAD_REQUEST(400),\n    UNAUTHORIZED(401),\n    FORBIDDEN(403),\n    NOT_FOUND(404),\n    METHOD_NOT_ALLOWED(405),\n    NOT_ACCEPTABLE(406),\n    CONFLICT(409),\n    GONE(410),\n    PRECONDITION_FAILED(412),\n    UNPROCESSABLE_ENTITY(422),\n    UPGRADE_REQUIRED(426),\n    TOO_MANY_REQUESTS(429),\n    INTERNAL_SERVER_ERROR(500),\n    BAD_GATEWAY(502),\n    SERVICE_UNAVAILABLE(503),\n    GATEWAY_TIMEOUT(504);\n\n    public final int code;\n\n    HTTPStatus(int code) {\n        this.code = code;\n    }\n}\n```\n\nProperty.java\n```java\npackage core.framework.api.json;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Property {\n    String name();\n}\n```\n\nDigits.java\n```java\npackage core.framework.api.validate;\n\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Digits can be used on numeric fields.\n *\n * @author chris\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Digits {\n    int integer() default -1; // maximum number of integral digits accepted for this number\n\n    int fraction() default -1; // maximum number of fractional digits accepted for this number\n\n    String message() default \"field out of bounds (<{integer} digits>.<{fraction} digits> expected), value={value}\";\n}\n```\n\nMax.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Max {\n    double value();\n\n    String message() default \"field must not be greater than {max}, value={value}\";\n}\n```\n\nMin.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Min can be used on numeric fields.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Min {\n    double value();\n\n    String message() default \"field must not be less than {min}, value={value}\";\n}\n```\n\nNotBlank.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * used for String field, to check string is not blank, be aware of null is not treated as blank,\n * this is to validate if the value presents, it must not be blank string\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotBlank {\n    String message() default \"field must not be blank\";\n}\n```\n\nNotNull.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface NotNull {\n    String message() default \"field must not be null\";\n}\n```\n\nPattern.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Pattern {\n    String value();\n\n    String message() default \"field must match /{pattern}/, value={value}\";\n}\n```\n\nSize.java\n```java\npackage core.framework.api.validate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * Size is used on String, List and Map.\n *\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Size {\n    int min() default -1;\n\n    int max() default -1;\n\n    String message() default \"size must be between {min} and {max}, size={value}\";\n}\n```\n\nDELETE.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface DELETE {\n}\n```\n\nGET.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface GET {\n}\n```\n\nPATCH.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PATCH {\n}\n```\n\nPath.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface Path {\n    String value();\n}\n```\n\nPathParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(PARAMETER)\n@Retention(RUNTIME)\npublic @interface PathParam {\n    String value();\n}\n```\n\nPOST.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface POST {\n}\n```\n\nPUT.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface PUT {\n}\n```\n\nQueryParam.java\n```java\npackage core.framework.api.web.service;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface QueryParam {\n    String name();\n}\n```\n\nResponseStatus.java\n```java\npackage core.framework.api.web.service;\n\nimport core.framework.api.http.HTTPStatus;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target({TYPE, METHOD})\n@Retention(RUNTIME)\npublic @interface ResponseStatus {\n    HTTPStatus value() default HTTPStatus.OK;\n}\n```\n\nmodule-info.java\n```java\nmodule core.framework.api {\n    exports core.framework.api.web.service;\n    exports core.framework.api.http;\n    exports core.framework.api.json;\n    exports core.framework.api.validate;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-json."}, {"role": "assistant", "content": "Here is the source code of package core-ng-json:\ntree /mnt/d/wonder-core-ng-project/core-ng-json/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-json/src/main/java\n└── core\n    └── framework\n        ├── internal\n        │   └── json\n        │       ├── JSONAnnotationIntrospector.java\n        │       ├── JSONMapper.java\n        │       ├── JSONReader.java\n        │       └── JSONWriter.java\n        └── json\n            └── JSON.java\n\n6 directories, 5 files\n\nJSONAnnotationIntrospector.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.Version;\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedClass;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport core.framework.api.json.Property;\n\nimport java.io.Serial;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class JSONAnnotationIntrospector extends AnnotationIntrospector {\n    @Serial\n    private static final long serialVersionUID = 3638140740110527623L;\n\n    @Override\n    public Version version() {\n        return Version.unknownVersion();\n    }\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    @Override\n    public String[] findEnumValues(MapperConfig<?> config, AnnotatedClass annotatedClass, Enum<?>[] enumValues, String[] names) {\n        Map<String, String> mappings = null;\n        for (AnnotatedField field : annotatedClass.fields()) {\n            if (!field.getAnnotated().isEnumConstant()) continue;\n\n            Property enumValue = field.getAnnotation(Property.class);\n            if (enumValue == null) continue;\n\n            String value = enumValue.name();\n            if (value.isEmpty()) continue;\n\n            if (mappings == null) mappings = new HashMap<>();\n            mappings.put(field.getName(), value);\n        }\n\n        if (mappings != null) {\n            int length = enumValues.length;\n            for (int i = 0; i < length; i++) {\n                String name = enumValues[i].name();\n                String value = mappings.get(name);\n                if (value != null) names[i] = value;\n            }\n        }\n        return names;\n    }\n\n    @Override\n    public PropertyName findNameForDeserialization(Annotated annotated) {\n        return propertyName(annotated);\n    }\n\n    private PropertyName propertyName(Annotated annotated) {\n        Property element = annotated.getAnnotation(Property.class);\n        if (element != null) {\n            return new PropertyName(element.name(), null);\n        }\n        return null;\n    }\n}\n```\n\nJSONMapper.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.StreamReadFeature;\nimport com.fasterxml.jackson.core.StreamWriteFeature;\nimport com.fasterxml.jackson.core.util.JsonRecyclerPools;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.MapperFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.introspect.VisibilityChecker;\nimport com.fasterxml.jackson.databind.json.JsonMapper;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.ZonedDateTimeSerializer;\nimport com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeFormatterBuilder;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.PUBLIC_ONLY;\nimport static java.time.format.DateTimeFormatter.ISO_INSTANT;\nimport static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\n\n/**\n * @author neo\n */\npublic class JSONMapper {\n    public static final ObjectMapper OBJECT_MAPPER = builder().build();\n    private static Map<Class<?>, JSONReader<?>> readers = new HashMap<>();\n    private static Map<Class<?>, JSONWriter<?>> writers = new HashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONReader<T> reader(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONReader<T>) readers.computeIfAbsent(beanClass, JSONReader::new);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> JSONWriter<T> writer(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (JSONWriter<T>) writers.computeIfAbsent(beanClass, JSONWriter::new);\n    }\n\n    public static void cleanup() {\n        readers = null;\n        writers = null;\n    }\n\n    // expose builder, to allow app build its own JSON mapper to parse external json, e.g. can be less strict\n    public static JsonMapper.Builder builder() {\n        JsonFactory jsonFactory = JsonFactory.builder()\n            .recyclerPool(JsonRecyclerPools.sharedLockFreePool())\n            .build();\n\n        // refer to com.fasterxml.jackson.databind.ObjectMapper.DEFAULT_BASE for default settings, e.g. cacheProvider\n        return JsonMapper.builder(jsonFactory)\n            .addModule(timeModule())\n            .defaultDateFormat(new StdDateFormat())\n            // disable value class loader to avoid jdk illegal reflection warning, requires JSON class/fields must be public\n            .addModule(new AfterburnerModule().setUseValueClassLoader(false))\n            // only detect public fields, refer to com.fasterxml.jackson.databind.introspect.VisibilityChecker.Std\n            .visibility(new VisibilityChecker.Std(NONE, NONE, NONE, NONE, PUBLIC_ONLY))\n            .enable(StreamReadFeature.USE_FAST_DOUBLE_PARSER)\n            .enable(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER)\n            .enable(StreamWriteFeature.USE_FAST_DOUBLE_WRITER)\n            .enable(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)\n            .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)\n            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n            // e.g. disable convert empty string to Integer null\n            .disable(MapperFeature.ALLOW_COERCION_OF_SCALARS)\n            .annotationIntrospector(new JSONAnnotationIntrospector())\n            .deactivateDefaultTyping();\n    }\n\n    private static JavaTimeModule timeModule() {\n        var module = new JavaTimeModule();\n\n        // redefine date time formatter to output nano seconds in at least 3 digits, which inline with ISO standard and ES standard\n        DateTimeFormatter localTimeFormatter = new DateTimeFormatterBuilder()\n            .parseStrict()\n            .appendValue(HOUR_OF_DAY, 2)\n            .appendLiteral(':')\n            .appendValue(MINUTE_OF_HOUR, 2)\n            .appendLiteral(':')\n            .appendValue(SECOND_OF_MINUTE, 2)\n            .appendFraction(NANO_OF_SECOND, 3, 9, true) // always output 3 digits of nano seconds (iso date format doesn't specify how many digits it should present, here always keep 3)\n            .toFormatter();\n\n        module.addSerializer(ZonedDateTime.class, new ZonedDateTimeSerializer(ISO_INSTANT));\n        module.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(ISO_LOCAL_DATE)\n            .appendLiteral('T')\n            .append(localTimeFormatter)\n            .toFormatter()));\n        module.addSerializer(LocalTime.class, new LocalTimeSerializer(new DateTimeFormatterBuilder()\n            .parseStrict()\n            .append(localTimeFormatter)\n            .toFormatter()));\n        return module;\n    }\n}\n```\n\nJSONReader.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.databind.ObjectReader;\n\nimport java.io.IOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONReader<T> {\n    // used internally, performance is top priority in design, reader is about 3~6% faster than mapper since type is pre determined\n    // refer to https://github.com/FasterXML/jackson-docs/wiki/Presentation:-Jackson-Performance\n    private final ObjectReader reader;\n\n    public JSONReader(Class<T> instanceClass) {\n        this.reader = JSONMapper.OBJECT_MAPPER.readerFor(instanceClass);\n    }\n\n    public T fromJSON(byte[] json) throws IOException {\n        return reader.readValue(json);\n    }\n\n    public T fromJSON(String json) throws IOException {\n        return reader.readValue(json);\n    }\n}\n```\n\nJSONWriter.java\n```java\npackage core.framework.internal.json;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport core.framework.util.Strings;\n\nimport java.io.UncheckedIOException;\n\n\n/**\n * @author neo\n */\npublic final class JSONWriter<T> {\n    private final ObjectWriter writer;\n\n    public JSONWriter(Class<T> instanceClass) {\n        this.writer = JSONMapper.OBJECT_MAPPER.writerFor(instanceClass);\n    }\n\n    // with jdk 11, write to String then covert to byte[] is faster than write to byte[]\n    // toJSON won't throw exception especially instance class will be validated before\n    public byte[] toJSON(T instance) {\n        try {\n            return Strings.bytes(writer.writeValueAsString(instance));\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public String toJSONString(T instance) {\n        try {\n            return writer.writeValueAsString(instance);\n        } catch (JsonProcessingException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nJSON.java\n```java\npackage core.framework.json;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Type;\n\nimport static core.framework.internal.json.JSONMapper.OBJECT_MAPPER;\n\n/**\n * @author neo\n */\npublic final class JSON {\n    public static <T> T fromJSON(Type instanceType, String json) {\n        try {\n            JavaType javaType = OBJECT_MAPPER.getTypeFactory().constructType(instanceType);\n            T result = OBJECT_MAPPER.readValue(json, javaType);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T> T fromJSON(Class<T> instanceClass, String json) {\n        try {\n            T result = OBJECT_MAPPER.readValue(json, instanceClass);\n            if (result == null) throw new Error(\"invalid json value, value=\" + json);   // not allow passing \"null\" as json value\n            return result;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static String toJSON(Object instance) {\n        if (instance == null) throw new Error(\"instance must not be null\");\n        try {\n            return OBJECT_MAPPER.writeValueAsString(instance);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T extends Enum<?>> T fromEnumValue(Class<T> valueClass, String jsonValue) {\n        return OBJECT_MAPPER.convertValue(jsonValue, valueClass);\n    }\n\n    public static <T extends Enum<?>> String toEnumValue(T value) {\n        return OBJECT_MAPPER.convertValue(value, String.class);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of package core-ng-common."}, {"role": "assistant", "content": "Here is the source code of package core-ng-common:\ntree /mnt/d/wonder-core-ng-project/core-ng-common/src/main/java:\n/mnt/d/wonder-core-ng-project/core-ng-common/src/main/java\n├── core\n│   └── framework\n│       └── util\n│           ├── ASCII.java\n│           ├── ClasspathResources.java\n│           ├── Encodings.java\n│           ├── Exceptions.java\n│           ├── Files.java\n│           ├── Lists.java\n│           ├── Maps.java\n│           ├── Network.java\n│           ├── Properties.java\n│           ├── Randoms.java\n│           ├── Sets.java\n│           ├── StopWatch.java\n│           ├── Strings.java\n│           ├── Threads.java\n│           └── Types.java\n└── javax\n    └── annotation\n        └── Nullable.java\n\n6 directories, 16 files\n\nASCII.java\n```java\npackage core.framework.util;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic final class ASCII {\n    // only convert ascii chars, faster than JDK String.toUpperCase due to JDK needs to handle UTF and locale\n    // refers to https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Ascii.java\n    public static String toUpperCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isLowerCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isLowerCase(ch)) {\n                        chars[j] = (char) (ch & 0x5F);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toUpperCase(char ch) {\n        if (isLowerCase(ch)) return (char) (ch & 0x5F);\n        return ch;\n    }\n\n    public static String toLowerCase(@Nullable String text) {\n        if (text == null) return null;\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            if (isUpperCase(text.charAt(i))) {\n                char[] chars = text.toCharArray();\n                for (int j = i; j < length; j++) {\n                    char ch = chars[j];\n                    if (isUpperCase(ch)) {\n                        chars[j] = (char) (ch ^ 0x20);\n                    }\n                }\n                return String.valueOf(chars);\n            }\n        }\n        return text;\n    }\n\n    public static char toLowerCase(char ch) {\n        if (isUpperCase(ch)) return (char) (ch ^ 0x20);\n        return ch;\n    }\n\n    public static boolean isLowerCase(char ch) {\n        return ch >= 'a' && ch <= 'z';\n    }\n\n    public static boolean isUpperCase(char ch) {\n        return ch >= 'A' && ch <= 'Z';\n    }\n\n    public static boolean isDigit(char ch) {\n        return ch >= '0' && ch <= '9';\n    }\n\n    public static boolean isLetter(char ch) {\n        return isLowerCase(ch) || isUpperCase(ch);\n    }\n}\n```\n\nClasspathResources.java\n```java\npackage core.framework.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.util.Iterator;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class ClasspathResources {\n    public static String text(String path) {\n        return new String(bytes(path), UTF_8);\n    }\n\n    public static byte[] bytes(String path) {\n        try (InputStream stream = stream(path)) {\n            return stream.readAllBytes();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static InputStream stream(String path) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Iterator<URL> urls = loader.getResources(path).asIterator();\n            return openStream(urls, path);\n        } catch (IOException e) {\n            throw new Error(\"can not load resource, path=\" + path, e);\n        }\n    }\n\n    static InputStream openStream(Iterator<URL> urls, String path) throws IOException {\n        if (urls.hasNext()) {\n            URL url = urls.next();\n            // to avoid have same resource name within different jars, as the order of loading jar is not determined on different env/os, we'd better avoid potential unexpected behavior\n            if (urls.hasNext()) throw new Error(\"found duplicate resources with same name, path=\" + path);\n            return url.openStream();\n        }\n        throw new Error(\"can not load resource, path=\" + path);\n    }\n}\n\n```\n\nEncodings.java\n```java\npackage core.framework.util;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.BitSet;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\n/**\n * @author neo\n */\npublic final class Encodings {\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    // refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent,\n    // refer to http://tools.ietf.org/html/rfc3986\n    private static final BitSet URI_UNESCAPED = new BitSet(128);\n\n    static {\n        for (int i = 'a'; i <= 'z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        for (int i = '0'; i <= '9'; i++) {\n            URI_UNESCAPED.set(i);\n        }\n        URI_UNESCAPED.set('-');\n        URI_UNESCAPED.set('_');\n        URI_UNESCAPED.set('.');\n        URI_UNESCAPED.set('!');\n        URI_UNESCAPED.set('~');\n        URI_UNESCAPED.set('*');\n        URI_UNESCAPED.set('\\'');\n        URI_UNESCAPED.set('(');\n        URI_UNESCAPED.set(')');\n    }\n\n    // refer to impl from org.springframework.web.util.HierarchicalUriComponents#encodeUriComponent\n    public static String uriComponent(String value) {\n        byte[] bytes = Strings.bytes(value);\n        int length = bytes.length;\n\n        for (int i = 0; i < length; i++) {\n            byte b1 = bytes[i];\n            if (b1 < 0 || !URI_UNESCAPED.get(b1)) {   // the bytes java returned is signed, but we only need to check ascii (0-127)\n                StringBuilder builder = new StringBuilder(length * 2);\n                if (i > 0) builder.append(value, 0, i); // unescaped bytes must be single byte char\n                for (int j = i; j < length; j++) {\n                    byte b2 = bytes[j];\n                    if (b2 >= 0 && URI_UNESCAPED.get(b2)) {\n                        builder.append((char) b2);\n                    } else {\n                        builder.append('%')\n                            .append(HEX_CHARS[(b2 >> 4) & 0xF])\n                            .append(HEX_CHARS[b2 & 0xF]);\n                    }\n                }\n                return builder.toString();\n            }\n        }\n        return value;\n    }\n\n    // refer to impl from org.springframework.web.util.UriUtils#decode\n    public static String decodeURIComponent(String value) {\n        int length = value.length();\n        int index = 0;\n        for (; index < length; index++) {\n            int ch = value.charAt(index);\n            if (ch == '%') break;\n        }\n        if (index == length) return value;\n\n        byte[] buffer = new byte[length];\n        for (int i = 0; i < index; i++) buffer[i] = (byte) value.charAt(i);\n        int position = index;\n\n        for (; index < length; index++) {\n            char ch = value.charAt(index);\n            if (ch == '%') {\n                if ((index + 2) >= length) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                char hex1 = value.charAt(index + 1);\n                char hex2 = value.charAt(index + 2);\n                int u = Character.digit(hex1, 16);\n                int l = Character.digit(hex2, 16);\n                if (u == -1 || l == -1) throw new IllegalArgumentException(\"invalid uri encoding, value=\" + value.substring(index));\n                buffer[position] = (byte) ((u << 4) + l);\n                index += 2;\n            } else {\n                buffer[position] = (byte) ch;   // here assume value is valid uri encoded string, if it contains multi-bytes (which should be encoded), here will not give right result\n            }\n            position++;\n        }\n        return new String(buffer, 0, position, StandardCharsets.UTF_8);\n    }\n\n    public static String base64(String value) {\n        return base64(Strings.bytes(value));\n    }\n\n    public static String base64(byte[] value) {\n        return Base64.getEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64(String value) {\n        return Base64.getDecoder().decode(value);\n    }\n\n    public static String base64URLSafe(byte[] value) {\n        return Base64.getUrlEncoder().encodeToString(value);\n    }\n\n    public static byte[] decodeBase64URLSafe(String value) {\n        return Base64.getUrlDecoder().decode(value);\n    }\n\n    public static String hex(byte[] bytes) {\n        var values = new byte[bytes.length * 2];\n        int i = 0;\n        for (byte value : bytes) {\n            values[i++] = (byte) HEX_CHARS[value >> 4 & 0xF];\n            values[i++] = (byte) HEX_CHARS[value & 0xF];\n        }\n        return new String(values, US_ASCII);\n    }\n}\n```\n\nExceptions.java\n```java\npackage core.framework.util;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n/**\n * @author neo\n */\npublic final class Exceptions {\n    public static String stackTrace(Throwable e) {\n        var writer = new StringWriter();\n        e.printStackTrace(new PrintWriter(writer));\n        return writer.toString();\n    }\n}\n```\n\nFiles.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.time.Instant;\nimport java.util.UUID;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.createDirectories;\nimport static java.nio.file.Files.getLastModifiedTime;\nimport static java.nio.file.Files.readAllBytes;\nimport static java.nio.file.Files.walkFileTree;\n\n/**\n * @author neo\n */\npublic final class Files {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Files.class);\n\n    public static String text(Path file) {\n        return new String(bytes(file), UTF_8);\n    }\n\n    public static byte[] bytes(Path file) {\n        var watch = new StopWatch();\n        try {\n            return readAllBytes(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"bytes, file={}, elapsed={}\", file, watch.elapsed());\n        }\n    }\n\n    public static void createDir(Path directory) {\n        try {\n            createDirectories(directory);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static void deleteDir(Path directory) {\n        var watch = new StopWatch();\n        try {\n            walkFileTree(directory, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\n                    delete(file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException e) {\n                    delete(dir);\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            LOGGER.debug(\"deleteDir, directory={}, elapsed={}\", directory, watch.elapsed());\n        }\n    }\n\n    public static Path tempFile() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        return Paths.get(tempDir + \"/\" + UUID.randomUUID().toString() + \".tmp\");\n    }\n\n    public static Path tempDir() {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        Path path = Paths.get(tempDir + \"/\" + UUID.randomUUID().toString());\n        createDir(path);\n        return path;\n    }\n\n    public static void delete(Path file) {\n        try {\n            java.nio.file.Files.delete(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static long size(Path file) {\n        try {\n            return java.nio.file.Files.size(file);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static Instant lastModified(Path file) {\n        try {\n            return getLastModifiedTime(file).toInstant();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nLists.java\n```java\npackage core.framework.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class Lists {\n    public static <T> List<T> newArrayList() {\n        return new ArrayList<>();\n    }\n}\n```\n\nMaps.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * @author neo\n */\npublic final class Maps {\n    public static <T, V> Map<T, V> newHashMap() {\n        return new HashMap<>();\n    }\n\n    public static <T, V> ConcurrentMap<T, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMap() {\n        return new LinkedHashMap<>();\n    }\n\n    public static <T, V> Map<T, V> newLinkedHashMapWithExpectedSize(int size) {\n        return new LinkedHashMap<>(capacity(size));\n    }\n\n    public static <T, V> Map<T, V> newHashMapWithExpectedSize(int size) {\n        return new HashMap<>(capacity(size));\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    private static int capacity(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return capacity;\n    }\n\n    public static <T extends Enum<T>, V> Map<T, V> newEnumMap(Class<T> enumClass) {\n        return new EnumMap<>(enumClass);\n    }\n}\n```\n\nNetwork.java\n```java\npackage core.framework.util;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author neo\n */\npublic final class Network {    // in cloud env, the application vm or container stick with same host ip / name during entire lifecycle\n    public static final String LOCAL_HOST_ADDRESS;\n    public static final String LOCAL_HOST_NAME;\n\n    static {\n        try {\n            InetAddress address = InetAddress.getLocalHost();\n            LOCAL_HOST_ADDRESS = address.getHostAddress();\n            LOCAL_HOST_NAME = address.getHostName();\n        } catch (UnknownHostException e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\nProperties.java\n```java\npackage core.framework.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Properties {\n    final Map<String, String> properties = Maps.newHashMap();\n\n    public void load(String classpath) {\n        try (InputStream stream = ClasspathResources.stream(classpath);\n             var reader = new BufferedReader(new InputStreamReader(stream, UTF_8))) {\n            var properties = new java.util.Properties();\n            properties.load(reader);\n            properties.forEach((key, value) -> set((String) key, (String) value));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public Optional<String> get(String key) {\n        String value = properties.get(key);\n        if (!Strings.isBlank(value)) return Optional.of(value);\n        return Optional.empty();\n    }\n\n    public void set(String key, String value) {\n        String previous = this.properties.putIfAbsent(key, value);\n        if (previous != null) throw new Error(format(\"property already exists, key={}, previous={}, current={}\", key, previous, value));\n    }\n\n    public Set<String> keys() {\n        return properties.keySet();\n    }\n\n    public boolean containsKey(String key) {\n        return properties.containsKey(key);\n    }\n}\n```\n\nRandoms.java\n```java\npackage core.framework.util;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\n/**\n * @author neo\n */\npublic final class Randoms {\n    private static final String ALPHA_NUMERIC = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n    public static String alphaNumeric(int length) {\n        StringBuilder builder = new StringBuilder(length);\n        for (int i = 0; i < length; i++)\n            builder.append(ALPHA_NUMERIC.charAt(ThreadLocalRandom.current().nextInt(ALPHA_NUMERIC.length())));\n        return builder.toString();\n    }\n\n    // return next double, ranges in [min, max)\n    public static double nextDouble(double min, double max) {\n        return (max - min) * ThreadLocalRandom.current().nextDouble() + min;\n    }\n\n    // return next int, ranges in [min, max)\n    public static int nextInt(int min, int max) {\n        return min + ThreadLocalRandom.current().nextInt(max - min);\n    }\n}\n```\n\nSets.java\n```java\npackage core.framework.util;\n\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author neo\n */\npublic final class Sets {\n    public static <T> Set<T> newHashSet() {\n        return new HashSet<>();\n    }\n\n    public static <T> Set<T> newConcurrentHashSet() {\n        return ConcurrentHashMap.newKeySet();\n    }\n\n    // refer to guava maps impl, init capacity with load factor 0.75\n    // https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Maps.java\n    public static <T> Set<T> newHashSetWithExpectedSize(int size) {\n        int capacity;\n        if (size < 3) {\n            capacity = size + 1;\n        } else {\n            capacity = (int) ((float) size / 0.75f + 1);\n        }\n        return new HashSet<>(capacity);\n    }\n\n    // EnumSet provides EnumSet.of(values...) methods, use it directly when apply\n    public static <T extends Enum<T>> Set<T> newEnumSet(Class<T> enumClass) {\n        return EnumSet.noneOf(enumClass);\n    }\n}\n```\n\nStopWatch.java\n```java\npackage core.framework.util;\n\n/**\n * @author neo\n */\npublic final class StopWatch {\n    private long start;\n\n    public StopWatch() {\n        reset();\n    }\n\n    public void reset() {\n        start = System.nanoTime();\n    }\n\n    public long elapsed() {\n        long end = System.nanoTime();\n        return end - start;\n    }\n}\n```\n\nStrings.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.helpers.MessageFormatter;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class Strings {\n    public static byte[] bytes(String text) {\n        return text.getBytes(UTF_8);\n    }\n\n    public static String format(String pattern, Object... params) {\n        return MessageFormatter.arrayFormat(pattern, params).getMessage();\n    }\n\n    public static int compare(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null && text2 == null) return 0;\n        if (text1 != null && text2 == null) return 1;\n        if (text1 == null) return -1;\n        return text1.compareTo(text2);\n    }\n\n    public static boolean isBlank(@Nullable String text) {\n        return text == null || text.isBlank();\n    }\n\n    public static boolean equals(@Nullable String text1, @Nullable String text2) {\n        if (text1 == null) return text2 == null;\n        return text1.equals(text2);\n    }\n\n    @Nullable\n    public static String truncate(@Nullable String text, int maxLength) {\n        if (text == null) return null;\n        if (text.length() <= maxLength) return text;\n        return text.substring(0, maxLength);\n    }\n\n    @Nullable\n    public static String strip(@Nullable String text) {\n        if (text == null) return null;\n        return text.strip();\n    }\n\n    public static boolean startsWith(String text, char prefix) {\n        if (text.isEmpty()) return false;\n        return text.charAt(0) == prefix;\n    }\n\n    public static String[] split(String text, char delimiter) {\n        List<String> tokens = Lists.newArrayList();\n        int start = 0;\n        while (true) {\n            int next = text.indexOf(delimiter, start);\n            if (next == -1) break;\n            tokens.add(text.substring(start, next));\n            start = next + 1;\n        }\n        if (start == 0) return new String[]{text};\n        else tokens.add(text.substring(start));\n        return tokens.toArray(new String[0]);\n    }\n}\n```\n\nThreads.java\n```java\npackage core.framework.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class Threads {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Threads.class);\n\n    public static void sleepRoughly(Duration duration) {\n        long sleepTime = sleepTime(duration);\n        LOGGER.debug(\"sleep {} ms\", sleepTime);\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            LOGGER.debug(\"sleep is interrupted\", e);\n        }\n    }\n\n    static long sleepTime(Duration duration) {\n        long milliseconds = duration.toMillis();\n        double times = Randoms.nextDouble(0.8, 1.2); // +/-20% random\n        return (long) (milliseconds * times);\n    }\n}\n```\n\nTypes.java\n```java\npackage core.framework.util;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Supplier;\n\n/**\n * @author neo\n */\npublic final class Types {\n    public static Type generic(Class<?> rawType, Type... arguments) {\n        return new ParameterizedTypeImpl(rawType, arguments);\n    }\n\n    public static Type optional(Type valueType) {\n        return generic(Optional.class, valueType);\n    }\n\n    public static Type list(Type valueType) {\n        return generic(List.class, valueType);\n    }\n\n    public static Type map(Type keyType, Type valueType) {\n        return generic(Map.class, keyType, valueType);\n    }\n\n    public static Type supplier(Type valueType) {\n        return generic(Supplier.class, valueType);\n    }\n\n    static final class ParameterizedTypeImpl implements ParameterizedType {\n        private final Type rawType;\n        private final Type[] arguments;\n\n        ParameterizedTypeImpl(Class<?> rawType, Type... arguments) {\n            this.rawType = rawType;\n            this.arguments = arguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return arguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n\n        // refer to sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.hashCode, must return same hashcode as builtin type\n        @Override\n        public int hashCode() {\n            return Arrays.hashCode(arguments) ^ rawType.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (!(other instanceof ParameterizedType that)) return false;\n\n            return Objects.equals(rawType, that.getRawType())\n                   && that.getOwnerType() == null\n                   && Arrays.equals(arguments, that.getActualTypeArguments());\n        }\n\n        @Override\n        public String toString() {\n            var builder = new StringBuilder(rawType.getTypeName()).append('<');\n\n            for (int i = 0; i < arguments.length; i++) {\n                if (i > 0) builder.append(\", \");\n                builder.append(arguments[i].getTypeName());\n            }\n\n            builder.append('>');\n            return builder.toString();\n        }\n    }\n}\n```\n\nNullable.java\n```java\npackage javax.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * help IDE (Intellij) to do nullability analysis﻿\n * <p>\n * refer to https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html#nullable\n *\n * @author neo\n */\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\npublic @interface Nullable {\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package async."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.async:\n\nExecutor.java\n```java\npackage core.framework.async;\n\nimport java.time.Duration;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\n\n/**\n * @author neo\n */\npublic interface Executor {\n    <T> Future<T> submit(String action, Callable<T> task);\n\n    Future<Void> submit(String action, Task task);\n\n    void submit(String action, Task task, Duration delay);\n}\n```\n\nTask.java\n```java\npackage core.framework.async;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Task {\n    void execute() throws Exception;    // not using Runnable to allow throw exception\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package cache."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.cache:\n\nCache.java\n```java\npackage core.framework.cache;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.function.Function;\n\n/**\n * @author neo\n */\npublic interface Cache<T> {\n    // loader must not return null, use wrapper class if it is necessary to cache null value\n    // for performance reason, it does not copy the object returned by local cache, so it must not modify local cache object unless to put it back\n    T get(String key, Function<String, T> loader);\n\n    Map<String, T> getAll(Collection<String> keys, Function<String, T> loader);\n\n    void put(String key, T value);\n\n    void putAll(Map<String, T> values);\n\n    void evict(String key);\n\n    void evictAll(Collection<String> keys);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package crypto."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.crypto:\n\nHash.java\n```java\npackage core.framework.crypto;\n\nimport core.framework.util.Strings;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * @author neo\n */\npublic final class Hash {\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    // md5 are not considered as secure algorithm, only used on legacy or security insensitive cases, like checksum or masking\n    public static String md5Hex(byte[] value) {\n        return hash(value, \"MD5\");\n    }\n\n    public static String md5Hex(String value) {\n        return md5Hex(Strings.bytes(value));\n    }\n\n    public static String sha256Hex(byte[] value) {\n        return hash(value, \"SHA-256\");\n    }\n\n    public static String sha256Hex(String value) {\n        return sha256Hex(Strings.bytes(value));\n    }\n\n    public static String sha512Hex(byte[] value) {\n        return hash(value, \"SHA-512\");\n    }\n\n    public static String sha512Hex(String value) {\n        return sha512Hex(Strings.bytes(value));\n    }\n\n    private static String hash(byte[] value, String algorithm) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(algorithm);    // lgtm[java/weak-cryptographic-algorithm]\n            byte[] digest = md.digest(value);\n            return hex(digest);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    private static String hex(byte[] bytes) {\n        char[] chars = new char[bytes.length << 1];\n        int index = 0;\n        for (byte b : bytes) {  // two characters form the hex value.\n            chars[index++] = HEX_CHARS[(b >> 4) & 0xF];\n            chars[index++] = HEX_CHARS[b & 0xF];\n        }\n        return new String(chars);\n    }\n}\n```\n\nHMAC.java\n```java\npackage core.framework.crypto;\n\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.Mac;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * http://en.wikipedia.org/wiki/Message_authentication_code\n *\n * @author neo\n */\npublic final class HMAC {\n    public static byte[] generateKey(Hash hash) {\n        try {\n            KeyGenerator generator = KeyGenerator.getInstance(hash.algorithm);\n            generator.init(128);\n            return generator.generateKey().getEncoded();\n        } catch (NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    private final byte[] key;\n    private final Hash hash;\n\n    public HMAC(byte[] key, Hash hash) {\n        this.key = key;\n        this.hash = hash;\n    }\n\n    public byte[] digest(byte[] message) {\n        if (key == null) throw new Error(\"key must not be null\");\n        try {\n            Mac mac = Mac.getInstance(hash.algorithm);\n            SecretKey secretKey = new SecretKeySpec(key, hash.algorithm);\n            mac.init(secretKey);\n            return mac.doFinal(message);\n        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n            throw new Error(e);\n        }\n    }\n\n    public enum Hash {\n        SHA256(\"HmacSHA256\"), SHA512(\"HmacSHA512\");\n        final String algorithm;\n\n        Hash(String algorithm) {\n            this.algorithm = algorithm;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package db."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.db:\n\nCloudAuthProvider.java\n```java\npackage core.framework.db;\n\n/**\n * @author neo\n */\npublic interface CloudAuthProvider {\n    String user();\n\n    String accessToken();\n\n    class Provider {\n        // used by driver to determine if current connection requires cloud auth, for multiple connections with different auth\n        public static final String CLOUD_AUTH = \"core.framework.db.cloudAuth\";\n        // in cloud env, only need one global auth provider\n        private static CloudAuthProvider provider;\n\n        public static void set(CloudAuthProvider provider) {\n            if (Provider.provider != null) throw new Error(\"provider is set, provider=\" + Provider.provider);\n            Provider.provider = provider;\n        }\n\n        public static CloudAuthProvider get() {\n            return provider;\n        }\n    }\n}\n```\n\nColumn.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Column {\n    String name();\n\n    boolean json() default false;\n}\n```\n\nDatabase.java\n```java\npackage core.framework.db;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Database {\n    /**\n     * for expected slow sql, such as query with small table or db chooses different query plan,\n     * disable warning then enable after<p>\n     * e.g.\n     * <blockquote><pre>\n     * Database.suppressSlowSQLWarning(false);\n     * database.select(...);\n     * Database.suppressSlowSQLWarning(true);\n     * </pre></blockquote>\n     *\n     * @param suppress whether suppress slow sql warning\n     */\n    static void suppressSlowSQLWarning(boolean suppress) {\n        // pass flag thru thread local to MySQLQueryInterceptor, and put in action log to reset for every action\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.warningContext.suppressSlowSQLWarning = suppress;\n        }\n    }\n\n    <T> List<T> select(String sql, Class<T> viewClass, Object... params);\n\n    <T> Optional<T> selectOne(String sql, Class<T> viewClass, Object... params);\n\n    int execute(String sql, Object... params);\n\n    // for bulk update operations, you may want to enclose it with Transaction to improve performance\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executePreparedBatchAsMultiStatement, mysql driver simply sends multiple queries with ';' as one statement,\n    // so it will reduce cost of creating transaction for each statement\n    int[] batchExecute(String sql, List<Object[]> params);\n\n    Transaction beginTransaction();\n}\n```\n\nDBEnumValue.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface DBEnumValue {\n    String value();\n}\n```\n\nIsolationLevel.java\n```java\npackage core.framework.db;\n\nimport java.sql.Connection;\n\n/**\n * @author neo\n */\npublic enum IsolationLevel {\n    READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED), READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED);\n\n    public final int level;\n\n    IsolationLevel(int level) {\n        this.level = level;\n    }\n}\n```\n\nPrimaryKey.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface PrimaryKey {\n    // only allow auto increment on primary key, not regular column\n    boolean autoIncrement() default false;\n}\n```\n\nQuery.java\n```java\npackage core.framework.db;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Query<T> {\n    void where(String condition, Object... params);\n\n    void orderBy(String sort);\n\n    void groupBy(String groupBy);\n\n    void skip(Integer skip);    // pass null to reset skip\n\n    void limit(Integer limit);  // pass null to reset limit\n\n    List<T> fetch();\n\n    Optional<T> fetchOne();\n\n    <P> List<P> project(String projection, Class<P> viewClass);\n\n    <P> Optional<P> projectOne(String projection, Class<P> viewClass);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count, count function return BIGINT\n    default long count() {\n        return projectOne(\"count(1)\", Long.class).orElseThrow();\n    }\n\n    // syntax sugar, to help to build \"where in clause\" with dynamic params\n    default <V> void in(String field, List<V> params) {\n        if (field == null) throw new Error(\"field must not be null\");\n        if (params == null || params.isEmpty()) throw new Error(\"params must not be empty\");\n        // efficient version of: where(Strings.format(\"{} IN ({})\", field, params.stream().map(param -> \"?\").collect(Collectors.joining(\", \"))), params.toArray());\n        int size = params.size();\n        var builder = new StringBuilder(field.length() + size * 3 + 6);    // e.g. field in (?, ?, ?)\n        builder.append(field).append(\" IN (\");\n        for (int i = 0; i < size; i++) {\n            if (i > 0) builder.append(\", \");\n            builder.append('?');\n        }\n        builder.append(')');\n        where(builder.toString(), params.toArray());\n    }\n}\n```\n\nQueryDiagnostic.java\n```java\npackage core.framework.db;\n\npublic interface QueryDiagnostic {\n    String sql();\n\n    boolean noGoodIndexUsed();\n\n    boolean noIndexUsed();\n}\n```\n\nRepository.java\n```java\npackage core.framework.db;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\n\n/**\n * @author neo\n */\npublic interface Repository<T> {\n    Query<T> select();\n\n    default List<T> select(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.fetch();\n    }\n\n    default long count(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.count();\n    }\n\n    default Optional<T> selectOne(String where, Object... params) {\n        Query<T> query = select();\n        if (where != null) query.where(where, params);\n        return query.fetchOne();\n    }\n\n    Optional<T> get(Object... primaryKeys);\n\n    OptionalLong insert(T entity);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/insert.html\n    // ignore if there is duplicate row, return true if inserted successfully\n    // BE CAUTION, it uses PK or unique index to determine duplication !!! read mysql doc carefully to avoid unexpected side effect\n    // BE CAUTION, With IGNORE, invalid values are adjusted to the closest values and inserted; warnings are produced but the statement does not abort.\n    // e.g. if you pass to out of range timestamp value, insert ignore will save it as 0 in db, which is terrible design of MySQL\n    boolean insertIgnore(T entity);\n\n    // refer to https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\n    // use insert on duplicate key sql, generally used by data sync\n    // BE CAUTION, it uses PK or unique index to determine duplication !!! read mysql doc carefully to avoid unexpected side effect\n    // return true if the new row inserted\n    boolean upsert(T entity);\n\n    // use update carefully, it will update all the columns according to the entity fields, includes null fields\n    // generally it's recommended to use partialUpdate if only few columns need to be updated and with optimistic lock\n    // return true if the row actually changed\n    boolean update(T entity);\n\n    // only update non-null fields, return true if the row actually changed\n    // if returned false, it CAN NOT distinguish if id not found, or all columns updated to its current values\n    boolean partialUpdate(T entity);\n\n    // partial update with additional condition, usually applied as optimistic lock pattern, return true if the row actually changed\n    boolean partialUpdate(T entity, String where, Object... params);\n\n    // return true if the row actually deleted\n    boolean delete(Object... primaryKeys);\n\n    Optional<long[]> batchInsert(List<T> entities);\n\n    // return true if any row inserted\n    // this is drawback of MySQL thin driver, though expected behavior\n    // with batch insert ignore (or insert on duplicate key), MySQL thin driver fills entire affectedRows array with same value, java.sql.Statement.SUCCESS_NO_INFO if updated count > 0\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executeBatchWithMultiValuesClause Line 612\n    boolean batchInsertIgnore(List<T> entities);\n\n    // return true if any row changed (inserted or updated)\n    // with batch, mysql treats both 1 (inserted) or 2 (updated) as java.sql.Statement.SUCCESS_NO_INFO\n    // batch performance is significantly better than single call, try to do batch if possible on data sync\n    boolean batchUpsert(List<T> entities);\n\n    // return true if any row deleted\n    // use Transaction if size of primaryKeys is too large, to avoid mysql create transaction for each statement\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executePreparedBatchAsMultiStatement, mysql driver simply sends multiple queries with ';' as one statement\n    boolean batchDelete(List<?> primaryKeys);\n}\n```\n\nTable.java\n```java\npackage core.framework.db;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(TYPE)\n@Retention(RUNTIME)\npublic @interface Table {\n    String name();\n}\n```\n\nTransaction.java\n```java\npackage core.framework.db;\n\n\n/**\n * @author neo\n */\npublic interface Transaction extends AutoCloseable {\n    void rollback();\n\n    void commit();\n\n    @Override\n    void close();\n}\n```\n\nUncheckedSQLException.java\n```java\npackage core.framework.db;\n\nimport java.io.Serial;\nimport java.sql.SQLException;\n\n/**\n * @author neo\n */\npublic final class UncheckedSQLException extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = 5857178985477320780L;\n\n    public final ErrorType errorType;\n\n    // expose original sqlState to support handle errors not covered by errorType\n    public final String sqlSate;\n\n    public UncheckedSQLException(SQLException e) {\n        super(e.getMessage() + \", sqlState=\" + e.getSQLState() + \", errorCode=\" + e.getErrorCode(), e);\n        sqlSate = e.getSQLState();\n        errorType = errorType(e);\n    }\n\n    // different jdbc driver translates sqlState to exception differently, but with common set\n    // hsqldb: org.hsqldb.jdbc.JDBCUtil,\n    // mysql: com.mysql.cj.jdbc.exceptions.SQLError\n    private ErrorType errorType(SQLException e) {\n        String state = e.getSQLState();\n        if (state == null) return null;\n        // in batchExecute, driver throws BatchUpdateException and may not have SQLIntegrityConstraintViolationException as cause, so here use sql state as contract\n        if (state.startsWith(\"23\")) return ErrorType.INTEGRITY_CONSTRAINT_VIOLATION;\n        if (state.startsWith(\"08\") || \"S1009\".equals(state)) return ErrorType.CONNECTION_ERROR;\n        return null;\n    }\n\n    // currently only valid use case to catch UncheckedSQLException is for duplicate key / constraint violation , e.g. register with duplicate name,\n    // it should not catch UncheckedSQLException for rest use cases\n    public enum ErrorType {\n        CONNECTION_ERROR,   // error type used to retry db operation potentially for top critical system, in cloud env / webapp, there are only limited use cases where retry db query makes sense\n        INTEGRITY_CONSTRAINT_VIOLATION\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package http."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.http:\n\nContentType.java\n```java\npackage core.framework.http;\n\nimport core.framework.util.ASCII;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport static core.framework.log.Markers.errorCode;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class ContentType {\n    public static final ContentType TEXT_HTML = create(\"text/html\", UTF_8);\n    public static final ContentType TEXT_CSS = create(\"text/css\", UTF_8);\n    public static final ContentType TEXT_PLAIN = create(\"text/plain\", UTF_8);\n    public static final ContentType TEXT_XML = create(\"text/xml\", UTF_8);\n    // refer to https://www.iana.org/assignments/media-types/application/json, No \"charset\" parameter is defined for application/json\n    // https://tools.ietf.org/html/rfc7159#section-8.1, UTF-8 as default encoding for JSON\n    // https://chromium-review.googlesource.com/c/chromium/src/+/587829\n    public static final ContentType APPLICATION_JSON = create(\"application/json\", null);\n    public static final ContentType APPLICATION_JAVASCRIPT = create(\"application/javascript\", UTF_8);\n    // form body content type doesn't use charset normally, refer to https://www.w3.org/TR/html5/sec-forms.html#urlencoded-form-data\n    public static final ContentType APPLICATION_FORM_URLENCODED = create(\"application/x-www-form-urlencoded\", null);\n    public static final ContentType APPLICATION_OCTET_STREAM = create(\"application/octet-stream\", null);\n    public static final ContentType IMAGE_PNG = create(\"image/png\", null);\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ContentType.class);\n    // cache most used ones to save paring time\n    private static final Map<String, ContentType> CACHE = Map.of(\n            APPLICATION_JSON.contentType, APPLICATION_JSON,\n            TEXT_HTML.contentType, TEXT_HTML\n    );\n\n    // only cover common case, assume pattern is \"media-type; charset=\" or \"multipart/form-data; boundary=\"\n    // according to https://www.w3.org/Protocols/rfc1341/4_Content-Type.html, content type value is case insensitive\n    public static ContentType parse(String contentType) {\n        String normalizedContentType = ASCII.toLowerCase(contentType);\n        ContentType type = CACHE.get(normalizedContentType);\n        if (type != null) return type;\n\n        return parseContentType(normalizedContentType);\n    }\n\n    public static ContentType create(String mediaType, Charset charset) {\n        String contentType = charset == null ? mediaType : mediaType + \"; charset=\" + ASCII.toLowerCase(charset.name());\n        return new ContentType(contentType, mediaType, charset);\n    }\n\n    private static ContentType parseContentType(String contentType) {\n        String mediaType = contentType;\n        Charset charset = null;\n\n        int firstSemicolon = contentType.indexOf(';');\n        if (firstSemicolon > 0) {\n            mediaType = contentType.substring(0, firstSemicolon);\n\n            int charsetStartIndex = contentType.indexOf(\"charset=\", firstSemicolon + 1);\n            if (charsetStartIndex > 0) {\n                int charsetEndIndex = contentType.indexOf(';', charsetStartIndex + 8);\n                charset = parseCharset(contentType.substring(charsetStartIndex + 8, charsetEndIndex == -1 ? contentType.length() : charsetEndIndex));\n            }\n        }\n\n        return new ContentType(contentType, mediaType, charset);\n    }\n\n    private static Charset parseCharset(String charset) {\n        try {\n            return Charset.forName(charset);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException e) {\n            LOGGER.warn(errorCode(\"INVALID_CONTENT_TYPE\"), \"ignore unsupported charset, charset={}\", charset, e);\n            return null;\n        }\n    }\n\n    public final String mediaType;\n    private final String contentType;\n    private final Charset charset;\n\n    private ContentType(String contentType, String mediaType, Charset charset) {\n        this.contentType = contentType;\n        this.mediaType = mediaType;\n        this.charset = charset;\n    }\n\n    public Optional<Charset> charset() {\n        return Optional.ofNullable(charset);\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || ContentType.class != object.getClass()) return false;\n        ContentType that = (ContentType) object;\n        return contentType.equals(that.contentType);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(contentType);\n    }\n\n    @Override\n    public String toString() {\n        return contentType;\n    }\n}\n```\n\nHTTPClient.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic interface HTTPClient {\n    static HTTPClientBuilder builder() {\n        return new HTTPClientBuilder();\n    }\n\n    HTTPResponse execute(HTTPRequest request);\n}\n```\n\nHTTPClientBuilder.java\n```java\npackage core.framework.http;\n\nimport core.framework.internal.http.CookieManager;\nimport core.framework.internal.http.DefaultTrustManager;\nimport core.framework.internal.http.FallbackDNSCache;\nimport core.framework.internal.http.HTTPClientImpl;\nimport core.framework.internal.http.HTTPEventListenerFactory;\nimport core.framework.internal.http.PEM;\nimport core.framework.internal.http.RetryInterceptor;\nimport core.framework.internal.http.ServiceUnavailableInterceptor;\nimport core.framework.internal.http.TimeoutInterceptor;\nimport core.framework.util.StopWatch;\nimport okhttp3.ConnectionPool;\nimport okhttp3.OkHttpClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.Security;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author neo\n */\npublic final class HTTPClientBuilder {\n    static {\n        // the system property must be set before loading jdk http client class, JDK uses static field to initialize those values\n\n        // allow server ssl cert change during renegotiation\n        // http client uses pooled connection, multiple requests to same host may hit different server behind LB\n        // refer to sun.security.ssl.ClientHandshakeContext, allowUnsafeServerCertChange = Utilities.getBooleanProperty(\"jdk.tls.allowUnsafeServerCertChange\", false);\n        System.setProperty(\"jdk.tls.allowUnsafeServerCertChange\", \"true\");\n\n        // refer to jdk InetAddressCachePolicy.class, it reads value from Security properties\n        // for application to override, one way is to put Security.setProperty() in Main before starting app\n        // override default to 300\n        if (Security.getProperty(\"networkaddress.cache.ttl\") == null) {\n            Security.setProperty(\"networkaddress.cache.ttl\", \"300\");\n        }\n        // override negative default from 10 to 0, not cache failure when http client retry dns resolving\n        if (\"10\".equals(Security.getProperty(\"networkaddress.cache.negative.ttl\"))) {\n            Security.setProperty(\"networkaddress.cache.negative.ttl\", \"0\");\n        }\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(HTTPClientBuilder.class);\n\n    private Duration connectTimeout = Duration.ofSeconds(25);\n    private Duration timeout = Duration.ofSeconds(60);\n    private Duration keepAlive = Duration.ofSeconds(30);    // conservative setting, as http connection to internet/external can be cut off by NAT/firewall if idle too long\n    private Duration slowOperationThreshold = Duration.ofSeconds(30);   // slow threshold should be longer than connect timeout\n    private boolean enableCookie = false;\n    // there is already networkaddress.cache.ttl=300s, this is to mitigate dns failure further,\n    // like external domain can be under DDos attack constantly (DNS hijacking) or unstable DNS query between countries\n    // this is trying to use previous success resolution to reduce intermittent dns resolve failures\n    private boolean enableFallbackDNSCache = false;\n    private String userAgent = \"HTTPClient\";\n    private boolean trustAll = false;\n    private KeyStore trustStore;\n    private KeyManager[] keyManagers;   // for client auth\n    private Integer maxRetries;\n    private Duration retryWaitTime = Duration.ofMillis(500);\n\n    // force to use HTTPClient.builder()\n    HTTPClientBuilder() {\n    }\n\n    public HTTPClient build() {\n        var watch = new StopWatch();\n        try {\n            OkHttpClient.Builder builder = new OkHttpClient.Builder()\n                .connectTimeout(connectTimeout)\n                .readTimeout(timeout)\n                .writeTimeout(timeout)\n                .callTimeout(callTimeout()) // call timeout is only used as last defense, timeout for complete call includes connect/retry/etc\n                .connectionPool(new ConnectionPool(100, keepAlive.toSeconds(), TimeUnit.SECONDS))\n                .eventListenerFactory(new HTTPEventListenerFactory())\n                .retryOnConnectionFailure(false)    // disable all okHTTP builtin retry and followups, those should be handled on application level for traces\n                .followRedirects(false)\n                .followSslRedirects(false);\n\n            configureHTTPS(builder);\n\n            builder.addInterceptor(new TimeoutInterceptor());\n            if (maxRetries != null) {\n                builder.addNetworkInterceptor(new ServiceUnavailableInterceptor());\n                builder.addInterceptor(new RetryInterceptor(maxRetries, retryWaitTime));\n            }\n            if (enableCookie) builder.cookieJar(new CookieManager());\n            if (enableFallbackDNSCache) builder.dns(new FallbackDNSCache());\n\n            return new HTTPClientImpl(builder.build(), userAgent, slowOperationThreshold, timeout);\n        } finally {\n            logger.info(\"create http client, elapsed={}\", watch.elapsed());\n        }\n    }\n\n    private void configureHTTPS(OkHttpClient.Builder builder) {\n        if (!trustAll && trustStore == null && keyManagers == null) return;\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManager[] trustManagers;\n            if (trustAll) {\n                trustManagers = new TrustManager[]{new DefaultTrustManager()};\n                builder.hostnameVerifier((hostname, sslSession) -> true);\n            } else {\n                var trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                trustManagerFactory.init(trustStore);\n                trustManagers = trustManagerFactory.getTrustManagers();\n            }\n            sslContext.init(keyManagers, trustManagers, null);  // lgtm [java/insecure-trustmanager]\n            builder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0]);\n        } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {\n            throw new Error(e);\n        }\n    }\n\n    // client level connect timeout, request level timeout can be specified in HTTPRequest\n    public HTTPClientBuilder connectTimeout(Duration connectTimeout) {\n        this.connectTimeout = connectTimeout;\n        return this;\n    }\n\n    // client level read/write timeout, request level timeout can be specified in HTTPRequest\n    public HTTPClientBuilder timeout(Duration timeout) {\n        this.timeout = timeout;\n        return this;\n    }\n\n    public HTTPClientBuilder keepAlive(Duration keepAlive) {\n        this.keepAlive = keepAlive;\n        return this;\n    }\n\n    public HTTPClientBuilder slowOperationThreshold(Duration slowOperationThreshold) {\n        this.slowOperationThreshold = slowOperationThreshold;\n        return this;\n    }\n\n    public HTTPClientBuilder userAgent(String userAgent) {\n        this.userAgent = userAgent;\n        return this;\n    }\n\n    public HTTPClientBuilder maxRetries(int maxRetries) {\n        this.maxRetries = maxRetries;\n        return this;\n    }\n\n    public HTTPClientBuilder retryWaitTime(Duration waitTime) {\n        retryWaitTime = waitTime;\n        return this;\n    }\n\n    public HTTPClientBuilder enableCookie() {\n        enableCookie = true;\n        return this;\n    }\n\n    public HTTPClientBuilder enableFallbackDNSCache() {\n        enableFallbackDNSCache = true;\n        return this;\n    }\n\n    public HTTPClientBuilder trustAll() {\n        trustAll = true;\n        return this;\n    }\n\n    public HTTPClientBuilder trust(String cert) {\n        try {\n            if (trustStore == null) {\n                trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null, null);  // must be init first\n\n                // add all system issuers to trust store to accept all authorized http certs\n                TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                factory.init((KeyStore) null);\n                for (TrustManager trustManager : factory.getTrustManagers()) {\n                    if (trustManager instanceof final X509TrustManager manager) {\n                        for (X509Certificate issuer : manager.getAcceptedIssuers()) {\n                            trustStore.setCertificateEntry(issuer.getSubjectX500Principal().getName(), issuer);\n                        }\n                    }\n                }\n            }\n            CertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\n            Certificate certificate = factory.generateCertificate(new ByteArrayInputStream(PEM.decode(cert)));\n            trustStore.setCertificateEntry(String.valueOf(trustStore.size() + 1), certificate);\n            return this;\n        } catch (CertificateException | KeyStoreException | IOException | NoSuchAlgorithmException e) {\n            throw new Error(e);\n        }\n    }\n\n    public HTTPClientBuilder clientAuth(String privateKey, String cert) {\n        try {\n            PrivateKey clientPrivateKey = KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(PEM.decode(privateKey)));\n            Certificate clientCertificate = CertificateFactory.getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(PEM.decode(cert)));\n\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, null);\n            keyStore.setKeyEntry(\"default\", clientPrivateKey, new char[0], new Certificate[]{clientCertificate});\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, new char[0]);\n            keyManagers = keyManagerFactory.getKeyManagers();\n            return this;\n        } catch (UnrecoverableKeyException | CertificateException | InvalidKeySpecException | NoSuchAlgorithmException | KeyStoreException | IOException e) {\n            throw new Error(e);\n        }\n    }\n\n    // this is rough estimate, like read timeout doesn't mean fetching full response will complete within duration of timeout\n    Duration callTimeout() {\n        int attempts = maxRetries == null ? 1 : maxRetries;\n        long callTimeout = connectTimeout.toMillis() + timeout.toMillis() * attempts;\n        for (int i = 1; i < attempts; i++) {\n            callTimeout += retryWaitTime.toMillis() << i - 1;\n        }\n        callTimeout += 2000;  // add 2 seconds as extra buffer\n        return Duration.ofMillis(callTimeout);\n    }\n}\n```\n\nHTTPClientException.java\n```java\npackage core.framework.http;\n\nimport core.framework.log.ErrorCode;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\npublic final class HTTPClientException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = -7577571026619549539L;\n\n    private final String errorCode;\n\n    public HTTPClientException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nHTTPHeaders.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic final class HTTPHeaders {\n    public static final String ACCEPT = \"Accept\";\n    public static final String AUTHORIZATION = \"Authorization\";\n    public static final String CACHE_CONTROL = \"Cache-Control\";\n    public static final String CONTENT_TYPE = \"Content-Type\";\n    public static final String LOCATION = \"Location\";\n    public static final String USER_AGENT = \"User-Agent\";\n}\n```\n\nHTTPMethod.java\n```java\npackage core.framework.http;\n\n/**\n * @author neo\n */\npublic enum HTTPMethod {\n    HEAD, GET, POST, PUT, DELETE, OPTIONS, TRACE, CONNECT, PATCH\n}\n```\n\nHTTPRequest.java\n```java\npackage core.framework.http;\n\nimport core.framework.internal.http.HTTPRequestHelper;\nimport core.framework.util.Encodings;\nimport core.framework.util.Maps;\nimport core.framework.util.Strings;\n\nimport java.time.Duration;\nimport java.util.Map;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class HTTPRequest {\n    public final HTTPMethod method;\n    public final Map<String, String> params = Maps.newLinkedHashMap();\n    public final Map<String, String> headers = Maps.newLinkedHashMap();    // make headers/params order deterministic\n    public String uri;\n    public byte[] body;\n    public ContentType contentType;\n    public Map<String, String> form;    // shortcut view only, doesn't impact final request\n\n    public Duration connectTimeout;\n    public Duration timeout;            // read and write timeout\n    public Duration slowOperationThreshold;\n\n    public HTTPRequest(HTTPMethod method, String uri) {\n        this.method = method;\n        this.uri = uri;\n    }\n\n    public void accept(ContentType contentType) {\n        headers.put(HTTPHeaders.ACCEPT, contentType.toString());\n    }\n\n    public void basicAuth(String user, String password) {\n        headers.put(HTTPHeaders.AUTHORIZATION, \"Basic \" + Encodings.base64(user + ':' + password));\n    }\n\n    public void bearerAuth(String token) {\n        headers.put(HTTPHeaders.AUTHORIZATION, \"Bearer \" + token);\n    }\n\n    public void body(byte[] body, ContentType contentType) {\n        this.body = body;\n        this.contentType = contentType;\n        headers.put(HTTPHeaders.CONTENT_TYPE, contentType.toString());\n    }\n\n    public void body(String body, ContentType contentType) {\n        byte[] bytes = body.getBytes(contentType.charset().orElse(UTF_8));\n        body(bytes, contentType);\n    }\n\n    public void form(Map<String, String> form) {\n        if (method != HTTPMethod.POST) throw new Error(\"form must be used with POST, method=\" + method);\n        this.form = form;\n        var builder = new StringBuilder(256);\n        HTTPRequestHelper.urlEncoding(builder, form);\n        body(Strings.bytes(builder.toString()), ContentType.APPLICATION_FORM_URLENCODED);\n    }\n\n    public String requestURI() {\n        if (params.isEmpty()) return uri;\n\n        var builder = new StringBuilder(256).append(uri).append(uri.indexOf('?') > -1 ? '&' : '?');\n        HTTPRequestHelper.urlEncoding(builder, params);\n        return builder.toString();\n    }\n}\n```\n\nHTTPResponse.java\n```java\npackage core.framework.http;\n\nimport java.nio.charset.Charset;\nimport java.util.Map;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class HTTPResponse {\n    public final int statusCode;\n    public final byte[] body;\n    public final Map<String, String> headers;   // headers key is case insensitive\n    public final ContentType contentType;\n\n    public HTTPResponse(int statusCode, Map<String, String> headers, byte[] body) {\n        this.statusCode = statusCode;\n        this.headers = headers;\n        this.body = body;\n\n        String contentType = headers.get(HTTPHeaders.CONTENT_TYPE);\n        this.contentType = contentType == null ? null : ContentType.parse(contentType);\n    }\n\n    public String text() {\n        Charset charset = UTF_8;\n        if (contentType != null) charset = contentType.charset().orElse(UTF_8);\n        return new String(body, charset);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package inject."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.inject:\n\nInject.java\n```java\npackage core.framework.inject;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Inject {\n}\n```\n\nNamed.java\n```java\npackage core.framework.inject;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(FIELD)\n@Retention(RUNTIME)\npublic @interface Named {\n    String value();\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package json."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.json:\n\nBean.java\n```java\npackage core.framework.json;\n\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.Validator;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class Bean {\n    private static final Map<Class<?>, Context<?>> CONTEXT = new HashMap<>(); // always requires register beanClass during startup, so not be thread safe\n\n    public static void register(Class<?> beanClass) {\n        CONTEXT.compute(beanClass, (key, value) -> {\n            if (value != null) throw new Error(\"bean class is already registered, beanClass=\" + key.getCanonicalName());\n            new JSONClassValidator(key).validate();\n            return new Context<>(beanClass);\n        });\n    }\n\n    public static <T> T fromJSON(Class<T> beanClass, String json) {\n        Context<T> context = context(beanClass);\n        try {\n            T instance = context.reader.fromJSON(json);\n            context.validator.validate(instance, false);\n            return instance;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public static <T> String toJSON(T bean) {\n        Context<T> context = context(bean.getClass());\n\n        context.validator.validate(bean, false);\n        return context.writer.toJSONString(bean);\n    }\n\n    private static <T> Context<T> context(Class<?> beanClass) {\n        @SuppressWarnings(\"unchecked\")\n        Context<T> context = (Context<T>) CONTEXT.get(beanClass);\n        if (context == null) throw new Error(\"bean class is not registered, beanClass=\" + beanClass.getCanonicalName());\n        return context;\n    }\n\n    private static class Context<T> {\n        final JSONReader<T> reader;\n        final JSONWriter<T> writer;\n        final Validator<T> validator;\n\n        Context(Class<T> beanClass) {\n            reader = JSONMapper.reader(beanClass);\n            writer = JSONMapper.writer(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package kafka."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.kafka:\n\nBulkMessageHandler.java\n```java\npackage core.framework.kafka;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface BulkMessageHandler<T> {\n    void handle(List<Message<T>> messages) throws Exception;\n}\n```\n\nKafkaException.java\n```java\npackage core.framework.kafka;\n\n/**\n * @author neo\n */\npublic class KafkaException extends RuntimeException {\n    private static final long serialVersionUID = -3982633342908753686L;\n\n    public KafkaException(String message) {\n        super(message);\n    }\n}\n```\n\nMessage.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic final class Message<T> {\n    @Nullable\n    public final String key;\n    public final T value;\n\n    public Message(@Nullable String key, T value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```\n\nMessageHandler.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface MessageHandler<T> {\n    void handle(@Nullable String key, T value) throws Exception;\n}\n```\n\nMessagePublisher.java\n```java\npackage core.framework.kafka;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface MessagePublisher<T> {\n    // kafka uses sticky partitioning if key is null, refer to org.apache.kafka.clients.producer.internals.DefaultPartitioner\n    default void publish(T value) {\n        publish(null, value);\n    }\n\n    void publish(@Nullable String key, T value);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package log."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.log:\n\nActionLogContext.java\n```java\npackage core.framework.log;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class ActionLogContext {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ActionLogContext.class);\n\n    @Nullable\n    public static String id() {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return null;\n        return actionLog.id;\n    }\n\n    public static List<String> get(String key) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return List.of();\n        List<String> values = actionLog.context.get(key);\n        if (values == null) return List.of();\n        return values;\n    }\n\n    public static void put(String key, Object... values) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {    // here to check null is for unit testing the logManager.begin may not be called\n            actionLog.context(key, values);\n        }\n    }\n\n    // to collect numeric metrics, and can be aggregated by Elasticsearch/Kibana\n    public static void stat(String key, double value) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.stat(key, value);\n        }\n    }\n\n    public static int track(String operation, long elapsed) {\n        return track(operation, elapsed, 0, 0);\n    }\n\n    // return the total count of operations within current action\n    public static int track(String operation, long elapsed, int readEntries, int writeEntries) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return 1;    // be called without action context\n        return actionLog.track(operation, elapsed, readEntries, writeEntries);\n    }\n\n    public static void info(String key, Object... values) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.info(key, values);\n        }\n    }\n\n    public static void triggerTrace(boolean cascade) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            Trace trace = cascade ? Trace.CASCADE : Trace.CURRENT;\n            LOGGER.debug(\"trigger trace, trace={}\", trace);\n            actionLog.trace = trace;\n        }\n    }\n\n    // for long process, use this guidance to determine whether continue to do more work\n    @Nullable\n    public static Duration remainingProcessTime() {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return null;\n        return Duration.ofNanos(actionLog.remainingProcessTimeInNano());\n    }\n}\n```\n\nErrorCode.java\n```java\npackage core.framework.log;\n\n/**\n * @author neo\n */\npublic interface ErrorCode {\n    String errorCode();\n\n    default Severity severity() {\n        return Severity.ERROR;\n    }\n}\n```\n\nIOWarning.java\n```java\npackage core.framework.log;\n\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\n@Repeatable(IOWarnings.class)\npublic @interface IOWarning {   // currently only supports WS/Controller and MessageHandler methods, and Executor task inherits from parent\n    String operation();\n\n    int maxOperations() default -1;     // total times called by one action, if exceeds, it indicates bad practice (not CD friendly), better change design or split into multiple actions\n\n    int maxElapsedInMs() default -1;    // max elapsed of one operation\n\n    int maxReads() default -1;          // number of rows/entries returned by one query\n\n    int maxTotalReads() default -1;     // total entries read by one action\n\n    int maxTotalWrites() default -1;    // total entries updated by one action\n}\n```\n\nIOWarnings.java\n```java\npackage core.framework.log;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface IOWarnings {\n    IOWarning[] value();\n}\n```\n\nLogAppender.java\n```java\npackage core.framework.log;\n\nimport core.framework.log.message.ActionLogMessage;\nimport core.framework.log.message.StatMessage;\n\n/**\n * @author neo\n */\npublic interface LogAppender {\n    void append(ActionLogMessage message);\n\n    void append(StatMessage message);\n}\n```\n\nMarkers.java\n```java\npackage core.framework.log;\n\nimport core.framework.internal.log.marker.ErrorCodeMarker;\nimport org.slf4j.Marker;\n\n/**\n * @author neo\n */\npublic final class Markers {\n    public static Marker errorCode(String code) {\n        return new ErrorCodeMarker(code);\n    }\n}\n```\n\nActionLogMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport javax.annotation.Nullable;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class ActionLogMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"host\")\n    public String host;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"action\")\n    public String action;\n    @Property(name = \"correlation_ids\")\n    public List<String> correlationIds;\n    @Property(name = \"clients\")\n    public List<String> clients;\n    @Property(name = \"ref_ids\")\n    public List<String> refIds;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"elapsed\")\n    public Long elapsed;\n    @Property(name = \"context\")\n    public Map<String, List<String>> context;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"perf_stats\")\n    public Map<String, PerformanceStatMessage> performanceStats;\n    @Property(name = \"info\")\n    public Map<String, List<String>> info;\n    @Property(name = \"trace_log\")\n    public String traceLog;\n\n    @Nullable\n    public String firstContextValue(String key) {\n        List<String> values = context.get(key);\n        if (values == null) return null;\n        return values.get(0);\n    }\n}\n```\n\nEventMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class EventMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"received_time\")\n    public Instant receivedTime;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"action\")\n    public String action;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"context\")\n    public Map<String, String> context;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"info\")\n    public Map<String, String> info;\n    @Property(name = \"elapsed\")\n    public Long elapsed;\n}\n```\n\nLogTopics.java\n```java\npackage core.framework.log.message;\n\n/**\n * @author neo\n */\npublic final class LogTopics {\n    public static final String TOPIC_ACTION_LOG = \"action-log-v2\";\n    public static final String TOPIC_STAT = \"stat\";\n    public static final String TOPIC_EVENT = \"event\";\n}\n```\n\nPerformanceStatMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic class PerformanceStatMessage {\n    @Property(name = \"total_elapsed\")\n    public Long totalElapsed;\n    @Property(name = \"count\")\n    public Integer count;\n    @Property(name = \"read_entries\")\n    public Integer readEntries;\n    @Property(name = \"write_entries\")\n    public Integer writeEntries;\n}\n```\n\nStatMessage.java\n```java\npackage core.framework.log.message;\n\nimport core.framework.api.json.Property;\n\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class StatMessage {\n    @Property(name = \"id\")\n    public String id;\n    @Property(name = \"date\")\n    public Instant date;\n    @Property(name = \"app\")\n    public String app;\n    @Property(name = \"host\")\n    public String host;\n    @Property(name = \"result\")\n    public String result;\n    @Property(name = \"error_code\")\n    public String errorCode;\n    @Property(name = \"error_message\")\n    public String errorMessage;\n    @Property(name = \"stats\")\n    public Map<String, Double> stats;\n    @Property(name = \"info\")\n    public Map<String, String> info;\n}\n```\n\nSeverity.java\n```java\npackage core.framework.log;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic enum Severity {\n    @Property(name = \"WARN\")\n    WARN,\n\n    @Property(name = \"ERROR\")\n    ERROR\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package module."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.module:\n\nAccessConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.internal.web.http.IPv4Ranges;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class AccessConfig {\n    private final Logger logger = LoggerFactory.getLogger(AccessConfig.class);\n    private final ModuleContext context;\n\n    AccessConfig(ModuleContext context) {\n        this.context = context;\n    }\n\n    /**\n     * Set allowed cidr blocks, e.g. 192.168.0.1/24 or 192.168.1.1/32 for single ip\n     *\n     * @param cidrs cidr blocks\n     */\n    public void allow(List<String> cidrs) {\n        IPv4AccessControl accessControl = accessControl();\n        if (accessControl.allow != null) throw new Error(\"allowed cidrs is already configured\");\n\n        logger.info(\"allow http access, cidrs={}\", cidrsLogParam(cidrs, 5));\n        accessControl.allow = new IPv4Ranges(cidrs);\n    }\n\n    /**\n     * Set denied cidr blocks, e.g. 192.168.0.1/24 or 192.168.1.1/32 for single ip\n     *\n     * @param cidrs cidr blocks\n     */\n    public void deny(List<String> cidrs) {\n        IPv4AccessControl accessControl = accessControl();\n        if (accessControl.deny != null) throw new Error(\"denied cidrs is already configured\");\n\n        logger.info(\"deny http access, cidrs={}\", cidrsLogParam(cidrs, 5));\n        accessControl.deny = new IPv4Ranges(cidrs);\n    }\n\n    /**\n     * Set denied ip range list, one cidr per line, comment starts with '#'\n     *\n     * @param classpath cidr file\n     */\n    public void denyFromFile(String classpath) {\n        deny(new IPv4RangeFileParser(classpath).parse());\n    }\n\n    private IPv4AccessControl accessControl() {\n        if (context.httpServer.handler.accessControl == null) {\n            context.httpServer.handler.accessControl = new IPv4AccessControl();\n        }\n        return context.httpServer.handler.accessControl;\n    }\n\n    String cidrsLogParam(List<String> cidrs, int maxSize) {\n        if (cidrs.size() <= maxSize) return String.valueOf(cidrs);\n        return \"[\" + String.join(\", \", cidrs.subList(0, maxSize)) + \", ...]\";\n    }\n}\n```\n\nAPIClientConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.web.service.WebServiceClientInterceptor;\nimport core.framework.web.service.WebServiceClientProxy;\n\n/**\n * @author neo\n */\npublic final class APIClientConfig {     // returned from APIConfig, must be public to be called\n    private final WebServiceClientProxy client;\n\n    APIClientConfig(WebServiceClientProxy client) {\n        this.client = client;\n    }\n\n    public void intercept(WebServiceClientInterceptor interceptor) {\n        new InjectValidator(interceptor).validate();\n        client.intercept(interceptor);\n    }\n}\n```\n\nAPIConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.api.web.service.Path;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.bean.RequestBeanWriter;\nimport core.framework.internal.web.bean.ResponseBeanReader;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.internal.web.service.HTTPMethods;\nimport core.framework.internal.web.service.WebServiceClient;\nimport core.framework.internal.web.service.WebServiceClientBuilder;\nimport core.framework.internal.web.service.WebServiceControllerBuilder;\nimport core.framework.internal.web.service.WebServiceImplValidator;\nimport core.framework.internal.web.service.WebServiceInterfaceValidator;\nimport core.framework.util.ASCII;\nimport core.framework.web.Controller;\nimport core.framework.web.service.WebServiceClientProxy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.Method;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class APIConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(APIConfig.class);\n    ModuleContext context;\n    private HTTPClient httpClient;\n    private RequestBeanWriter writer;\n    private ResponseBeanReader reader;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        // default value is for internal api call only, targeting for kube env (with short connect timeout and more retries)\n        httpClient = HTTPClient.builder()\n            .userAgent(WebServiceClient.USER_AGENT)\n            .trustAll()\n            .connectTimeout(Duration.ofSeconds(2))\n            .timeout(Duration.ofSeconds(20))    // refer to: kube graceful shutdown period is 30s, db timeout is 15s\n            .keepAlive(Duration.ofMinutes(5))   // use longer keep alive timeout within cluster, to reduce connection creation overhead\n            .slowOperationThreshold(Duration.ofSeconds(10))\n            .maxRetries(5)\n            .build();\n        writer = new RequestBeanWriter();\n        reader = new ResponseBeanReader();\n    }\n\n    public <T> void service(Class<T> serviceInterface, T service) {\n        logger.info(\"create web service, interface={}\", serviceInterface.getCanonicalName());\n        var validator = new WebServiceInterfaceValidator(serviceInterface, context.beanClassValidator);\n        validator.requestBeanReader = context.httpServer.handler.requestBeanReader;\n        validator.responseBeanWriter = context.httpServer.handler.responseBeanWriter;\n        validator.validate();\n        new WebServiceImplValidator<>(serviceInterface, service).validate();\n        new InjectValidator(service).validate();\n        context.apiController.serviceInterfaces.add(serviceInterface);    // doesn't need to check duplicate, duplication will failed to register route\n\n        for (Method method : serviceInterface.getMethods()) {\n            HTTPMethod httpMethod = HTTPMethods.httpMethod(method);\n            String path = method.getDeclaredAnnotation(Path.class).value();\n            Controller controller = new WebServiceControllerBuilder<>(serviceInterface, service, method).build();\n            try {\n                Class<?> serviceClass = service.getClass();\n                Method targetMethod = serviceClass.getMethod(method.getName(), method.getParameterTypes());\n                String controllerInfo = serviceClass.getCanonicalName() + \".\" + targetMethod.getName();\n                String action = \"api:\" + ASCII.toLowerCase(httpMethod.name()) + \":\" + path;\n                context.httpServer.handler.route.add(httpMethod, path, new ControllerHolder(controller, targetMethod, controllerInfo, action, false));\n            } catch (NoSuchMethodException e) {\n                throw new Error(\"failed to find impl method\", e);\n            }\n        }\n    }\n\n    public <T> APIClientConfig client(Class<T> serviceInterface, String serviceURL) {\n        return client(serviceInterface, serviceURL, httpClient);\n    }\n\n    public <T> APIClientConfig client(Class<T> serviceInterface, String serviceURL, HTTPClient httpClient) {\n        T client = createClient(serviceInterface, serviceURL, httpClient);\n        context.beanFactory.bind(serviceInterface, null, client);\n        return new APIClientConfig((WebServiceClientProxy) client);\n    }\n\n    public <T> T createClient(Class<T> serviceInterface, String serviceURL, HTTPClient httpClient) {\n        logger.info(\"create web service client, interface={}, serviceURL={}\", serviceInterface.getCanonicalName(), serviceURL);\n        var validator = new WebServiceInterfaceValidator(serviceInterface, context.beanClassValidator);\n        validator.requestBeanWriter = writer;\n        validator.responseBeanReader = reader;\n        validator.validate();\n        return createWebServiceClient(serviceInterface, new WebServiceClient(serviceURL, httpClient, writer, reader));\n    }\n\n    <T> T createWebServiceClient(Class<T> serviceInterface, WebServiceClient webServiceClient) {\n        return new WebServiceClientBuilder<>(serviceInterface, webServiceClient).build();\n    }\n}\n```\n\nApp.java\n```java\npackage core.framework.module;\n\nimport com.sun.management.OperatingSystemMXBean;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.validate.Validator;\nimport core.framework.log.Markers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.management.ManagementFactory;\n\n/**\n * @author neo\n */\npublic abstract class App extends Module {\n    private final LogManager logManager = new LogManager();\n    private final Logger logger = LoggerFactory.getLogger(App.class);\n\n    public final void start() {\n        ActionLog actionLog = logManager.begin(\"=== startup begin ===\", null);\n        boolean failed = false;\n        try {\n            logContext(actionLog);\n            configure();\n            context.probe.check();    // readiness probe only needs to run on actual startup, not on test\n            logger.info(\"execute startup tasks\");\n            context.startupHook.initialize();\n            context.startupHook.start();\n            cleanup();\n            logger.info(\"startup completed, elapsed={}\", actionLog.elapsed());\n        } catch (Throwable e) {\n            logger.error(Markers.errorCode(\"FAILED_TO_START\"), \"app failed to start, error={}\", e.getMessage(), e);\n            failed = true;\n        } finally {\n            logManager.end(\"=== startup end ===\");\n        }\n        if (failed) {\n            System.exit(1);\n        }\n    }\n\n    void logContext(ActionLog actionLog) {\n        actionLog.action(\"app:start\");\n    }\n\n    public final void configure() {\n        logger.info(\"initialize framework\");\n        Runtime runtime = Runtime.getRuntime();\n        logger.info(\"availableProcessors={}, maxMemory={}\", runtime.availableProcessors(), ((OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()).getTotalMemorySize());\n        logger.info(\"jvmArgs={}\", String.join(\" \", ManagementFactory.getRuntimeMXBean().getInputArguments()));\n\n        context = new ModuleContext(logManager);\n        context.initialize();\n        runtime.addShutdownHook(new Thread(context.shutdownHook, \"shutdown\"));\n\n        logger.info(\"initialize application\");\n        initialize();\n        context.validate();\n    }\n\n    private void cleanup() {\n        // free static objects not used anymore\n        Validator.cleanup();\n        JSONMapper.cleanup();\n        if (!context.httpServer.siteManager.webDirectory.localEnv) {    // for local env, it may rebuild html template at runtime\n            DynamicInstanceBuilder.cleanup();\n        }\n    }\n}\n```\n\nCacheConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.cache.Cache;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.cache.CacheClassValidator;\nimport core.framework.internal.cache.CacheImpl;\nimport core.framework.internal.cache.CacheStore;\nimport core.framework.internal.cache.LocalCacheMetrics;\nimport core.framework.internal.cache.LocalCacheStore;\nimport core.framework.internal.cache.RedisCacheStore;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.internal.web.sys.CacheController;\nimport core.framework.util.ASCII;\nimport core.framework.util.Types;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class CacheConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(CacheConfig.class);\n    Map<String, CacheImpl<?>> caches;\n\n    private ModuleContext context;\n    private LocalCacheStore localCacheStore;\n    private CacheStore redisCacheStore;\n    private int maxLocalSize;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n\n        caches = new HashMap<>();\n        var controller = new CacheController(caches);\n        context.route(HTTPMethod.GET, \"/_sys/cache\", (LambdaController) controller::list, true);\n        context.route(HTTPMethod.GET, \"/_sys/cache/:name/:key\", (LambdaController) controller::get, true);\n        context.route(HTTPMethod.DELETE, \"/_sys/cache/:name/:key\", (LambdaController) controller::delete, true);\n    }\n\n    @Override\n    protected void validate() {\n        if (caches.isEmpty()) {\n            throw new Error(\"cache is configured but no cache added, please remove unnecessary config\");\n        }\n        // maxLocalSize() can be configured before localCacheStore is created, so set max size at end\n        if (maxLocalSize > 0 && localCacheStore != null) {\n            localCacheStore.maxSize = maxLocalSize;\n        }\n    }\n\n    public void local() {\n        if (localCacheStore != null || redisCacheStore != null) throw new Error(\"cache store is already configured, please configure only once\");\n        localCacheStore();\n    }\n\n    public void redis(String host) {\n        redis(host, null);\n    }\n\n    public void redis(String host, String password) {\n        if (localCacheStore != null || redisCacheStore != null) throw new Error(\"cache store is already configured, please configure only once\");\n        configureRedis(host, password);\n    }\n\n    public <T> CacheStoreConfig add(Class<T> cacheClass, Duration duration) {\n        if (localCacheStore == null && redisCacheStore == null) throw new Error(\"cache store is not configured, please configure first\");\n        logger.info(\"add cache, class={}, duration={}\", cacheClass.getCanonicalName(), duration);\n        new CacheClassValidator(cacheClass).validate();\n        String name = cacheName(cacheClass);\n        var cache = new CacheImpl<>(name, cacheClass, duration);\n        cache.cacheStore = redisCacheStore != null ? redisCacheStore : localCacheStore;\n        CacheImpl<?> previous = caches.putIfAbsent(name, cache);\n        if (previous != null) throw new Error(\"found duplicate cache name, name=\" + name);\n        context.beanFactory.bind(Types.generic(Cache.class, cacheClass), null, cache);\n\n        return new CacheStoreConfig(cache, this);\n    }\n\n    // number of objects to cache\n    public void maxLocalSize(int size) {\n        maxLocalSize = size;\n    }\n\n    String cacheName(Class<?> cacheClass) {\n        return ASCII.toLowerCase(cacheClass.getSimpleName());\n    }\n\n    void configureRedis(String host, String password) {\n        logger.info(\"create redis cache store, host={}\", host);\n\n        var redis = new RedisImpl(\"redis-cache\");\n        redis.host(host);\n        redis.password(password);\n        redis.timeout(Duration.ofSeconds(1));   // for cache, use shorter timeout than default redis config\n        context.probe.hostURIs.add(host);\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n        redisCacheStore = new RedisCacheStore(redis);\n    }\n\n    LocalCacheStore localCacheStore() {\n        if (localCacheStore == null) {\n            logger.info(\"create local cache store\");\n            var localCacheStore = new LocalCacheStore();\n            context.backgroundTask().scheduleWithFixedDelay(localCacheStore::cleanup, Duration.ofMinutes(5));\n            context.collector.metrics.add(new LocalCacheMetrics(localCacheStore));\n            this.localCacheStore = localCacheStore;\n        }\n        return localCacheStore;\n    }\n}\n```\n\nCacheStoreConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.cache.CacheImpl;\nimport core.framework.internal.cache.RedisCacheStore;\n\n/**\n * @author neo\n */\npublic class CacheStoreConfig {\n    private final CacheImpl<?> cache;\n    private final CacheConfig config;\n\n    CacheStoreConfig(CacheImpl<?> cache, CacheConfig config) {\n        this.cache = cache;\n        this.config = config;\n    }\n\n    // for rarely changed data, or stale data is tolerated\n    // or use kafka with custom groupId to evict keys\n    // otherwise refresh can also be done by restarting service if there is emergence\n    public void local() {\n        if (cache.cacheStore instanceof RedisCacheStore) {\n            cache.cacheStore = config.localCacheStore();\n        }\n    }\n}\n```\n\nCDNConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.ModuleContext;\n\n/**\n * @author neo\n */\npublic final class CDNConfig {\n    private final ModuleContext context;\n\n    CDNConfig(ModuleContext context) {\n        this.context = context;\n    }\n\n    public void host(String host) {\n        context.httpServer.siteManager.templateManager.cdnManager.host(host);\n    }\n}\n```\n\nDBConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.db.CloudAuthProvider;\nimport core.framework.db.Database;\nimport core.framework.db.IsolationLevel;\nimport core.framework.db.Repository;\nimport core.framework.internal.db.DatabaseImpl;\nimport core.framework.internal.db.cloud.AzureAuthProvider;\nimport core.framework.internal.db.cloud.GCloudAuthProvider;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.util.Lists;\nimport core.framework.util.Strings;\nimport core.framework.util.Types;\n\nimport java.time.Duration;\nimport java.util.List;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class DBConfig extends Config {\n    final List<Class<?>> entityClasses = Lists.newArrayList();\n    protected String name;\n    DatabaseImpl database;\n    private ModuleContext context;\n    private String url;\n    private boolean entityAdded;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n\n        var database = new DatabaseImpl(\"db\" + (name == null ? \"\" : \"-\" + name));\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> database.close());\n        context.backgroundTask().scheduleWithFixedDelay(database.pool::refresh, Duration.ofMinutes(10));\n        context.collector.metrics.add(new PoolMetrics(database.pool));\n        context.beanFactory.bind(Database.class, name, database);\n        this.database = database;\n    }\n\n    @Override\n    protected void validate() {\n        if (url == null) throw new Error(\"db url must be configured, name=\" + name);\n        if (!entityAdded)\n            throw new Error(\"db is configured but no repository/view added, please remove unnecessary config, name=\" + name);\n    }\n\n    public void url(String url) {\n        if (this.url != null) throw new Error(format(\"db url is already configured, name={}, url={}, previous={}\", name, url, this.url));\n        database.url(databaseURL(url));\n        this.url = url;\n    }\n\n    String databaseURL(String url) {\n        return url;\n    }\n\n    public void user(String user) {\n        if (user.startsWith(\"iam/\")) {\n            CloudAuthProvider provider = CloudAuthProvider.Provider.get();\n            if (provider == null) {\n                provider = provider(user);\n                CloudAuthProvider.Provider.set(provider);\n            }\n            database.authProvider = provider;\n            context.logManager.maskFields(\"access_token\");  // mask token from IAM http response, gcloud/azure all use JWT token\n        } else {\n            database.user = user;\n        }\n    }\n\n    CloudAuthProvider provider(String user) {\n        if (\"iam/gcloud\".equals(user)) {\n            return new GCloudAuthProvider();\n        } else if (user.startsWith(\"iam/azure/\")) {\n            String iamUser = user.substring(10);\n            if (Strings.isBlank(iamUser)) {\n                throw new Error(\"invalid azure iam user, user=\" + user);\n            }\n            return new AzureAuthProvider(iamUser);\n        }\n        throw new Error(\"unsupported cloud provider, value=\" + user);\n    }\n\n    public void password(String password) {\n        database.password = password;\n    }\n\n    public void poolSize(int minSize, int maxSize) {\n        database.pool.size(minSize, maxSize);\n    }\n\n    public void isolationLevel(IsolationLevel level) {\n        database.isolationLevel = level;\n    }\n\n    public void longTransactionThreshold(Duration threshold) {\n        database.operation.transactionManager.longTransactionThresholdInNanos = threshold.toNanos();\n    }\n\n    public void timeout(Duration timeout) {\n        database.timeout(timeout);\n    }\n\n    public void view(Class<?> viewClass) {\n        if (url == null) throw new Error(\"db url must be configured first, name=\" + name);\n        database.view(viewClass);\n        entityAdded = true;\n    }\n\n    public <T> Repository<T> repository(Class<T> entityClass) {\n        if (url == null) throw new Error(\"db url must be configured first, name=\" + name);\n        Repository<T> repository = database.repository(entityClass);\n        context.beanFactory.bind(Types.generic(Repository.class, entityClass), name, repository);\n        entityAdded = true;\n        entityClasses.add(entityClass);\n        return repository;\n    }\n}\n```\n\nHTTPConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.HTTPHost;\nimport core.framework.internal.web.HTTPIOHandler;\nimport core.framework.internal.web.bean.RequestBeanReader;\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.web.Controller;\nimport core.framework.web.ErrorHandler;\nimport core.framework.web.Interceptor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class HTTPConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(HTTPConfig.class);\n    ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n    }\n\n    public void route(HTTPMethod method, String path, Controller controller) {\n        if (HTTPIOHandler.HEALTH_CHECK_PATH.equals(path)) throw new Error(\"/health-check is reserved path\");\n        context.route(method, path, controller, false);\n    }\n\n    public void route(HTTPMethod method, String path, LambdaController controller) {\n        route(method, path, (Controller) controller);\n    }\n\n    public void bean(Class<?> beanClass) {\n        logger.info(\"register bean, class={}\", beanClass.getCanonicalName());\n        if (beanClass.isEnum()) {   // enum is usually declared to expose constants via /_sys/api, e.g. errorCodes, or pathParams used by controller directly\n//            context.beanClassValidator.beanClassNameValidator.validate(beanClass);\n            JSONClassValidator.validateEnum(beanClass);\n        } else {\n            registerBean(beanClass);\n        }\n        boolean added = context.apiController.beanClasses.add(beanClass);\n        if (!added) throw new Error(\"bean class is already registered, class=\" + beanClass.getCanonicalName());\n    }\n\n    // register http body bean and query param bean\n    private void registerBean(Class<?> beanClass) {\n        RequestBeanReader reader = context.httpServer.handler.requestBeanReader;\n        if (RequestBeanReader.isQueryParamBean(beanClass)) {\n            if (reader.containsQueryParam(beanClass)) {\n                throw new Error(\"query param bean class is already registered or referred by service interface, class=\" + beanClass.getCanonicalName());\n            }\n            reader.registerQueryParam(beanClass, context.beanClassValidator.beanClassNameValidator);\n        } else {\n            ResponseBeanWriter writer = context.httpServer.handler.responseBeanWriter;\n            if (reader.containsBean(beanClass) || writer.contains(beanClass)) {\n                throw new Error(\"bean class is already registered or referred by service interface, class=\" + beanClass.getCanonicalName());\n            }\n            reader.registerBean(beanClass, context.beanClassValidator);\n            writer.register(beanClass, context.beanClassValidator);\n        }\n    }\n\n    public void intercept(Interceptor interceptor) {\n        if (interceptor.getClass().isSynthetic())\n            throw new Error(\"interceptor class must not be anonymous class or lambda, please use static class, interceptorClass=\" + interceptor.getClass().getCanonicalName());\n        new InjectValidator(interceptor).validate();\n        context.httpServerConfig.interceptors.add(interceptor);\n    }\n\n    public void errorHandler(ErrorHandler handler) {\n        context.httpServer.handler.errorHandler.customErrorHandler = handler;\n    }\n\n    // host is in \"host:port\" or \"port\" format, e.g. 8080 or 127.0.0.1:8080\n    public void listenHTTP(String host) {\n        context.httpServerConfig.httpHost = HTTPHost.parse(host);\n    }\n\n    public void listenHTTPS(String host) {\n        context.httpServerConfig.httpsHost = HTTPHost.parse(host);\n    }\n\n    public LimitRateConfig limitRate() {\n        return context.config(LimitRateConfig.class, null);\n    }\n\n    /**\n     * Set max x-forwarded-for ips to prevent client ip spoofing, e.g. script clients send custom x-forwarded-for header to bypass rate limiting by ip.\n     * Default is 2 to fit common scenarios, e.g. Google LB(append 2 ips)->kube service, AWS->nginx->webapp\n     *\n     * @param maxIPs the max number for forwarded ips\n     */\n    public void maxForwardedIPs(int maxIPs) {\n        if (maxIPs < 1) throw new Error(\"maxIPs must be greater than 1, maxIPs=\" + maxIPs);\n        context.httpServer.handler.requestParser.clientIPParser.maxForwardedIPs = maxIPs;\n    }\n\n    public AccessConfig access() {\n        return new AccessConfig(context);\n    }\n\n    public void gzip() {\n        context.httpServerConfig.gzip = true;\n    }\n\n    // use backend timeout of cloud lb\n    public void maxProcessTime(Duration maxProcessTime) {\n        context.httpServer.handler.maxProcessTimeInNano = maxProcessTime.toNanos();\n    }\n\n    // to configure max body size for both regular post and multipart upload\n    public void maxEntitySize(long maxEntitySize) {\n        context.httpServerConfig.maxEntitySize = maxEntitySize;\n    }\n}\n```\n\nIPv4RangeFileParser.java\n```java\npackage core.framework.module;\n\nimport core.framework.util.ClasspathResources;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class IPv4RangeFileParser {\n    private final Logger logger = LoggerFactory.getLogger(IPv4RangeFileParser.class);\n    private final String classpath;\n\n    public IPv4RangeFileParser(String classpath) {\n        this.classpath = classpath;\n    }\n\n    // write cidr for each line\n    // comment line starts with '#'\n    public List<String> parse() {\n        logger.info(\"load ip range file, classpath={}\", classpath);\n\n        try (InputStream stream = ClasspathResources.stream(classpath);\n             var reader = new BufferedReader(new InputStreamReader(stream, UTF_8))) {\n            return reader.lines()\n                .filter(line -> !line.isBlank() && line.charAt(0) != '#')\n                .toList();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```\n\nIPv4RangePropertyValueParser.java\n```java\npackage core.framework.module;\n\nimport core.framework.util.Strings;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author neo\n */\npublic final class IPv4RangePropertyValueParser {\n    private final String value;\n\n    public IPv4RangePropertyValueParser(String value) {\n        this.value = value;\n    }\n\n    // support two formats,\n    // 1. cidr,cidr\n    // 2. name1: cidr, cidr; name2: cidr\n    public List<String> parse() {\n        if (Strings.isBlank(value)) return List.of();\n        if (value.indexOf(':') > 0) {\n            return parseSemicolonDelimited(value);\n        } else {\n            return parseCommaDelimited(value);\n        }\n    }\n\n    private List<String> parseCommaDelimited(String value) {\n        return Arrays.stream(Strings.split(value, ',')).map(String::strip).collect(Collectors.toList());\n    }\n\n    private List<String> parseSemicolonDelimited(String value) {\n        List<String> results = new ArrayList<>();\n        for (String item : Strings.split(value, ';')) {\n            if (Strings.isBlank(item)) continue;\n            int index = item.indexOf(':');\n            Arrays.stream(Strings.split(item.substring(index + 1), ','))\n                  .map(String::strip)\n                  .forEach(results::add);\n        }\n        return results;\n    }\n}\n```\n\nKafkaConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.kafka.KafkaURI;\nimport core.framework.internal.kafka.MessageListener;\nimport core.framework.internal.kafka.MessageProducer;\nimport core.framework.internal.kafka.MessagePublisherImpl;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.web.sys.KafkaController;\nimport core.framework.kafka.BulkMessageHandler;\nimport core.framework.kafka.MessageHandler;\nimport core.framework.kafka.MessagePublisher;\nimport core.framework.util.Types;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class KafkaConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(KafkaConfig.class);\n    String name;\n    MessageProducer producer;\n    private ModuleContext context;\n    private KafkaURI uri;\n    private MessageListener listener;\n    private boolean handlerAdded;\n    private int maxRequestSize = 1024 * 1024;   // default 1M, refer to org.apache.kafka.clients.producer.ProducerConfig.MAX_REQUEST_SIZE_CONFIG\n    private KafkaController controller;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n        controller = new KafkaController();\n    }\n\n    @Override\n    protected void validate() {\n        if (!handlerAdded)\n            throw new Error(\"kafka is configured, but no publisher/handler added, please remove unnecessary config, name=\" + name);\n        if (listener != null && listener.topics.isEmpty())\n            throw new Error(\"kafka listener is configured, but no handler added, please remove unnecessary config, name=\" + name);\n    }\n\n    public void uri(String uri) {\n        if (this.uri != null)\n            throw new Error(format(\"kafka uri is already configured, name={}, uri={}, previous={}\", name, uri, this.uri));\n        this.uri = new KafkaURI(uri);\n        // in kube env, it's ok to just check first pod dns of stateful set\n        context.probe.hostURIs.add(this.uri.bootstrapURIs.get(0));\n    }\n\n    // to make IoC simpler, each topic should have its own message class\n    public <T> MessagePublisher<T> publish(String topic, Class<T> messageClass) {\n        if (topic == null) throw new Error(\"topic must not be null\");\n        logger.info(\"publish, topic={}, messageClass={}, name={}\", topic, messageClass.getTypeName(), name);\n        if (uri == null) throw new Error(\"kafka uri must be configured first, name=\" + name);\n        context.beanClassValidator.validate(messageClass);\n        MessagePublisher<T> publisher = createMessagePublisher(topic, messageClass);\n        context.beanFactory.bind(Types.generic(MessagePublisher.class, messageClass), name, publisher);\n        context.apiController.topics.put(topic, messageClass);\n        handlerAdded = true;\n        return publisher;\n    }\n\n    <T> MessagePublisher<T> createMessagePublisher(String topic, Class<T> messageClass) {\n        if (producer == null) {\n            var producer = new MessageProducer(uri, name, maxRequestSize);\n            context.collector.metrics.add(producer.producerMetrics);\n            context.startupHook.initialize.add(producer::initialize);\n            context.shutdownHook.add(ShutdownHook.STAGE_4, producer::close);\n            controller.producer = producer;\n            context.route(HTTPMethod.POST, managementPathPattern(\"/topic/:topic/key/:key/publish\"), (LambdaController) controller::publish, true);\n            this.producer = producer;\n        }\n        return new MessagePublisherImpl<>(producer, topic, messageClass);\n    }\n\n    String managementPathPattern(String postfix) {\n        var builder = new StringBuilder(\"/_sys/kafka\");\n        if (name != null) builder.append('/').append(name);\n        builder.append(postfix);\n        return builder.toString();\n    }\n\n    public <T> void subscribe(String topic, Class<T> messageClass, MessageHandler<T> handler) {\n        subscribe(topic, messageClass, handler, null);\n    }\n\n    public <T> void subscribe(String topic, Class<T> messageClass, BulkMessageHandler<T> handler) {\n        subscribe(topic, messageClass, null, handler);\n    }\n\n    private <T> void subscribe(String topic, Class<T> messageClass, MessageHandler<T> handler, BulkMessageHandler<T> bulkHandler) {\n        if (handler == null && bulkHandler == null) throw new Error(\"handler must not be null\");\n        logger.info(\"subscribe, topic={}, messageClass={}, handlerClass={}, name={}\", topic, messageClass.getTypeName(), handler != null ? handler.getClass().getCanonicalName() : bulkHandler.getClass().getCanonicalName(), name);\n        context.beanClassValidator.validate(messageClass);\n        new InjectValidator(handler != null ? handler : bulkHandler).validate();\n        listener().subscribe(topic, messageClass, handler, bulkHandler);\n        handlerAdded = true;\n    }\n\n    private MessageListener listener() {\n        if (listener == null) {\n            if (uri == null) throw new Error(\"kafka uri must be configured first, name=\" + name);\n            var listener = new MessageListener(uri, name, context.logManager, context.shutdownHook.shutdownTimeoutInNano);\n            context.startupHook.start.add(listener::start);\n            context.shutdownHook.add(ShutdownHook.STAGE_0, timeout -> listener.shutdown());\n            context.shutdownHook.add(ShutdownHook.STAGE_1, listener::awaitTermination);\n            context.collector.metrics.add(listener.consumerMetrics);\n            controller.listener = listener;\n            context.route(HTTPMethod.POST, managementPathPattern(\"/topic/:topic/key/:key/handle\"), (LambdaController) controller::handle, true);\n            this.listener = listener;   // make lambda not refer to this class/field\n        }\n        return listener;\n    }\n\n    // by default listener use AppName as consumer group\n    // e.g. use Network.LOCAL_HOST_NAME to make every pod receives messages from topic, (local cache invalidation, web socket notification)\n    // use \"${service-name}-${label}\" to allow same service to be deployed for mutlitenancy\n    public void groupId(String groupId) {\n        listener().groupId = groupId;\n    }\n\n    public void concurrency(int concurrency) {\n        listener().concurrency = concurrency;\n    }\n\n    // to increase max message size, both producer and broker sides have size limitation\n    // for broker\n    // use \"--override message.max.bytes=size\", refer to https://kafka.apache.org/documentation/#message.max.bytes\n    // for producer\n    // refer to org.apache.kafka.clients.producer.ProducerConfig.MAX_REQUEST_SIZE_CONFIG\n    // producer checks uncompressed request size, broker checks compressed request (actual request) size\n    // if message size exceeds producer limit, it throws error within current action\n    // if exceeds broker limit, broker rejects the message, error only shows on KafkaCallback (console output on kafka producer thread), no warning on broker side\n    public void maxRequestSize(int size) {\n        if (size <= 0) throw new Error(\"max request size must be greater than 0, value=\" + size);\n        if (producer != null) throw new Error(\"kafka().maxRequestSize() must be configured before adding publisher\");\n        maxRequestSize = size;\n    }\n\n    public void longConsumerDelayThreshold(Duration threshold) {\n        listener().longConsumerDelayThresholdInNano = threshold.toNanos();\n    }\n\n    public void maxPoll(int maxRecords, int maxBytes) {\n        if (maxRecords <= 0) throw new Error(\"max poll records must be greater than 0, value=\" + maxRecords);\n        if (maxBytes <= 0) throw new Error(\"max poll bytes must be greater than 0, value=\" + maxBytes);\n        MessageListener listener = listener();\n        listener.maxPollRecords = maxRecords;\n        listener.maxPollBytes = maxBytes;\n    }\n\n    public void minPoll(int minBytes, Duration maxWaitTime) {\n        if (minBytes <= 0) throw new Error(\"min poll bytes must be greater than 0, value=\" + minBytes);\n        if (maxWaitTime == null || maxWaitTime.toMillis() <= 0) throw new Error(\"max wait time must be greater than 0, value=\" + maxWaitTime);\n        MessageListener listener = listener();\n        listener.minPollBytes = minBytes;\n        listener.maxWaitTime = maxWaitTime;\n    }\n}\n```\n\nLambdaController.java\n```java\npackage core.framework.module;\n\nimport core.framework.web.Controller;\n\nimport java.io.Serializable;\n\n/**\n * @author neo\n */\npublic interface LambdaController extends Controller, Serializable {\n    // due to in JDK, method reference does not have enclosing class/method info,\n    // and from JDK 12, ConstantPool can't be access unless run with \"--add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\"\n    // so here use another way to retrieve method reference controller info by serializing\n    // refer to ControllerInspector and git history for details\n}\n```\n\nLimitRateConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.LimitRateInterceptor;\nimport core.framework.internal.web.http.RateControl;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class LimitRateConfig extends Config {\n    private boolean rateControlGroupAdded;\n    private RateControl rateControl;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        rateControl = context.httpServer.handler.rateControl;\n        // save at max 5K group/ip combination per pod, about 800K memory, to adapt with more ips/cc attack, better defense with cloud infra based solution together\n        maxEntries(5000);\n        context.httpServerConfig.interceptors.add(new LimitRateInterceptor(rateControl));\n    }\n\n    @Override\n    protected void validate() {\n        if (!rateControlGroupAdded) {\n            throw new Error(\"limitRate is configured but no group added, please remove unnecessary config\");\n        }\n    }\n\n    // how many group/ip combinations to keep, 5000 is about 800K, 10K is about 1.8M\n    public void maxEntries(int entries) {\n        rateControl.maxEntries(entries);\n    }\n\n    // maintain maxPermits at most, fill permits by fillRate per interval\n    // e.g. add(\"group\", 10, 5, Duration.ofSeconds(1)) keeps 10 permits at most, fills 5 permits every second\n    // e.g. add(\"group\", 20, 10, Duration.ofMinutes(5)) keeps 20 permits at most, fills 10 permits every 5 minutes\n    public void add(String group, int maxPermits, int fillRate, Duration interval) {\n        rateControl.config(group, maxPermits, fillRate, interval);\n        rateControlGroupAdded = true;\n    }\n}\n```\n\nLogConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.kafka.KafkaURI;\nimport core.framework.internal.log.CollectStatTask;\nimport core.framework.internal.log.appender.ConsoleAppender;\nimport core.framework.internal.log.appender.KafkaAppender;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.log.LogAppender;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class LogConfig extends Config {\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n    }\n\n    public void appendToConsole() {\n        appender(new ConsoleAppender());\n    }\n\n    public void appendToKafka(String uri) {\n        var appender = new KafkaAppender(new KafkaURI(uri));\n        appender(appender);\n        context.startupHook.start.add(appender::start);\n        context.shutdownHook.add(ShutdownHook.STAGE_7, appender::stop);\n        context.collector.metrics.add(appender.producerMetrics);\n    }\n\n    public void appender(LogAppender appender) {\n        if (context.logManager.appender != null) throw new Error(\"log appender is already set, appender=\" + context.logManager.appender.getClass().getSimpleName());\n        context.logManager.appender = appender;\n        context.backgroundTask().scheduleWithFixedDelay(new CollectStatTask(appender, context.collector), Duration.ofSeconds(10));\n    }\n\n    public void maskFields(String... fields) {\n        context.logManager.maskFields(fields);\n    }\n}\n```\n\nModule.java\n```java\npackage core.framework.module;\n\nimport core.framework.async.Task;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Type;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic abstract class Module {\n    private final Logger logger = LoggerFactory.getLogger(Module.class);\n\n    protected ModuleContext context;\n\n    protected void load(Module module) {\n        logger.info(\"load module, module={}\", module.getClass().getName());\n        module.context = context;\n        module.initialize();\n    }\n\n    public void onShutdown(Task task) {\n        context.shutdownHook.add(ShutdownHook.STAGE_5, timeout -> task.execute());\n    }\n\n    public void onStartup(Task task) {\n        // put all custom startup task on start stage\n        context.startupHook.start.add(task);\n    }\n\n    public <T> T bind(Class<T> instanceClass) {\n        T instance = context.beanFactory.create(instanceClass);\n        return context.bind(instanceClass, null, instance);\n    }\n\n    public <T> T bind(T instance) {\n        return bind(instance.getClass(), null, instance);\n    }\n\n    public <T> T bind(Class<? super T> instanceClass, T instance) {\n        return bind(instanceClass, null, instance);\n    }\n\n    public <T> T bind(Type type, @Nullable String name, T instance) {\n        context.beanFactory.inject(instance);\n        return context.bind(type, name, instance);\n    }\n\n    public <T> T bean(Class<T> instanceClass) {\n        return bean(instanceClass, null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T bean(Type type, @Nullable String name) {\n        return (T) context.beanFactory.bean(type, name);\n    }\n\n    public void loadProperties(String classpath) {\n        logger.info(\"load properties, classpath={}\", classpath);\n        context.propertyManager.properties.load(classpath);\n    }\n\n    public Optional<String> property(String key) {\n        return context.property(key);\n    }\n\n    public String requiredProperty(String key) {\n        return property(key).orElseThrow(() -> new Error(\"property key not found, key=\" + key));\n    }\n\n    public LogConfig log() {\n        return context.config(LogConfig.class, null);\n    }\n\n    public HTTPConfig http() {\n        return context.config(HTTPConfig.class, null);\n    }\n\n    public WebSocketConfig ws() {\n        return context.config(WebSocketConfig.class, null);\n    }\n\n    public SiteConfig site() {\n        return context.config(SiteConfig.class, null);\n    }\n\n    public CacheConfig cache() {\n        return context.config(CacheConfig.class, null);\n    }\n\n    public SchedulerConfig schedule() {\n        return context.config(SchedulerConfig.class, null);\n    }\n\n    public APIConfig api() {\n        return context.config(APIConfig.class, null);\n    }\n\n    public DBConfig db() {\n        return db(null);\n    }\n\n    public DBConfig db(String name) {\n        return context.config(DBConfig.class, name);\n    }\n\n    public RedisConfig redis() {\n        return context.config(RedisConfig.class, null);\n    }\n\n    public RedisConfig redis(String name) {\n        return context.config(RedisConfig.class, name);\n    }\n\n    public KafkaConfig kafka() {\n        return kafka(null);\n    }\n\n    public KafkaConfig kafka(String name) {\n        return context.config(KafkaConfig.class, name);\n    }\n\n    public <T extends Config> T config(Class<T> configClass) {\n        return config(configClass, null);\n    }\n\n    public <T extends Config> T config(Class<T> configClass, String name) {\n        return context.config(configClass, name);\n    }\n\n    public void highCPUUsageThreshold(double threshold) {\n        context.collector.highCPUUsageThreshold = threshold;\n    }\n\n    public void highHeapUsageThreshold(double threshold) {\n        context.collector.highHeapUsageThreshold = threshold;\n    }\n\n    // monitor java process VmRSS / cgroup ram limit\n    public void highMemUsageThreshold(double threshold) {\n        context.collector.highMemUsageThreshold = threshold;\n    }\n\n    protected abstract void initialize();\n}\n```\n\nRedisConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.redis.Redis;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class RedisConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(RedisConfig.class);\n    private ModuleContext context;\n    private Redis redis;\n    private String name;\n    private String host;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        this.name = name;\n        redis = createRedis();\n        context.beanFactory.bind(Redis.class, name, redis);\n    }\n\n    @Override\n    protected void validate() {\n        if (host == null) throw new Error(\"redis host must be configured, name=\" + name);\n    }\n\n    Redis createRedis() {\n        logger.info(\"create redis client, name={}\", name);\n        var redis = new RedisImpl(\"redis\" + (name == null ? \"\" : \"-\" + name));\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n        return redis;\n    }\n\n    public void host(String host) {\n        setHost(host);\n        this.host = host;\n    }\n\n    void setHost(String host) {\n        RedisImpl redis = (RedisImpl) this.redis;\n        redis.host(host);\n        context.probe.hostURIs.add(host);\n    }\n\n    public void password(String password) {\n        RedisImpl redis = (RedisImpl) this.redis;\n        redis.password(password);\n    }\n\n    public void poolSize(int minSize, int maxSize) {\n        ((RedisImpl) redis).pool.size(minSize, maxSize);\n    }\n\n    public void timeout(Duration timeout) {\n        ((RedisImpl) redis).timeout(timeout);\n    }\n\n    public Redis client() {\n        return redis;\n    }\n}\n```\n\nSchedulerConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.scheduler.DailyTrigger;\nimport core.framework.internal.scheduler.HourlyTrigger;\nimport core.framework.internal.scheduler.MonthlyTrigger;\nimport core.framework.internal.scheduler.Scheduler;\nimport core.framework.internal.scheduler.WeeklyTrigger;\nimport core.framework.internal.web.sys.SchedulerController;\nimport core.framework.scheduler.Job;\nimport core.framework.scheduler.Trigger;\nimport core.framework.util.Strings;\n\nimport java.time.Clock;\nimport java.time.DayOfWeek;\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.time.ZoneId;\n\n/**\n * @author neo\n */\npublic final class SchedulerConfig extends Config {\n    private Scheduler scheduler;\n    private boolean triggerAdded;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        var scheduler = new Scheduler(context.logManager);\n        context.startupHook.start.add(scheduler::start);\n        context.shutdownHook.add(ShutdownHook.STAGE_0, timeout -> scheduler.shutdown());\n        context.shutdownHook.add(ShutdownHook.STAGE_1, scheduler::awaitTermination);\n\n        var schedulerController = new SchedulerController(scheduler);\n        context.route(HTTPMethod.GET, \"/_sys/job\", (LambdaController) schedulerController::jobs, true);\n        context.route(HTTPMethod.POST, \"/_sys/job/:job\", (LambdaController) schedulerController::triggerJob, true);\n\n        this.scheduler = scheduler; // make lambda not refer to this class/field\n    }\n\n    public void timeZone(ZoneId zoneId) {\n        if (triggerAdded) throw new Error(\"schedule().timeZone() must be configured before adding trigger\");\n        if (zoneId == null) throw new Error(\"zoneId must not be null\");\n        scheduler.clock = Clock.system(zoneId);\n    }\n\n    public void fixedRate(String name, Job job, Duration rate) {\n        validateJob(name, job);\n\n        scheduler.addFixedRateTask(name, job, rate);\n        triggerAdded = true;\n    }\n\n    public void hourlyAt(String name, Job job, int minute, int second) {\n        trigger(name, job, new HourlyTrigger(minute, second));\n    }\n\n    public void dailyAt(String name, Job job, LocalTime time) {\n        trigger(name, job, new DailyTrigger(time));\n    }\n\n    public void weeklyAt(String name, Job job, DayOfWeek dayOfWeek, LocalTime time) {\n        trigger(name, job, new WeeklyTrigger(dayOfWeek, time));\n    }\n\n    public void monthlyAt(String name, Job job, int dayOfMonth, LocalTime time) {\n        trigger(name, job, new MonthlyTrigger(dayOfMonth, time));\n    }\n\n    public void trigger(String name, Job job, Trigger trigger) {\n        validateJob(name, job);\n\n        scheduler.addTriggerTask(name, job, trigger);\n        triggerAdded = true;\n    }\n\n    void validateJob(String name, Job job) {\n        Class<? extends Job> jobClass = job.getClass();\n        if (jobClass.isSynthetic())\n            throw new Error(Strings.format(\"job class must not be anonymous class or lambda, please create static class, name={}, jobClass={}\", name, jobClass.getCanonicalName()));\n        new InjectValidator(job).validate();\n    }\n}\n```\n\nSessionConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.module.ShutdownHook;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.resource.PoolMetrics;\nimport core.framework.internal.web.session.LocalSessionStore;\nimport core.framework.internal.web.session.RedisSessionStore;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic class SessionConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(SessionConfig.class);\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        cookie(\"SessionId\", null);\n    }\n\n    public void timeout(Duration timeout) {\n        context.httpServer.siteManager.sessionManager.timeout(timeout);\n    }\n\n    public void cookie(String name, String domain) {\n        context.httpServer.siteManager.sessionManager.cookie(name, domain);\n        context.logManager.maskFields(name);\n    }\n\n    public void header(String name) {\n        context.httpServer.siteManager.sessionManager.header(name);\n        context.logManager.maskFields(name);\n    }\n\n    public void local() {\n        logger.info(\"create local session store\");\n        LocalSessionStore sessionStore = new LocalSessionStore();\n        context.backgroundTask().scheduleWithFixedDelay(sessionStore::cleanup, Duration.ofMinutes(30));\n        context.httpServer.siteManager.sessionManager.store(sessionStore);\n    }\n\n    public void redis(String host) {\n        logger.info(\"create redis session store, host={}\", host);\n\n        var redis = new RedisImpl(\"redis-session\");\n        redis.host(host);\n        context.backgroundTask().scheduleWithFixedDelay(redis.pool::refresh, Duration.ofMinutes(5));\n        context.collector.metrics.add(new PoolMetrics(redis.pool));\n\n        context.probe.hostURIs.add(host);\n        context.shutdownHook.add(ShutdownHook.STAGE_6, timeout -> redis.close());\n        context.httpServer.siteManager.sessionManager.store(new RedisSessionStore(redis));\n    }\n}\n```\n\nSiteConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.http.IPv4Ranges;\nimport core.framework.internal.web.site.MessageImpl;\nimport core.framework.internal.web.site.StaticContentController;\nimport core.framework.internal.web.site.StaticDirectoryController;\nimport core.framework.internal.web.site.StaticFileController;\nimport core.framework.internal.web.site.WebSecurityInterceptor;\nimport core.framework.web.site.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class SiteConfig extends Config {\n    private final Logger logger = LoggerFactory.getLogger(SiteConfig.class);\n    boolean messageConfigured;\n    private WebSecurityInterceptor webSecurityInterceptor;\n    private ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, String name) {\n        this.context = context;\n        context.httpServer.handler.requestParser.logSiteHeaders = true;\n    }\n\n    public SessionConfig session() {\n        return context.config(SessionConfig.class, null);\n    }\n\n    public CDNConfig cdn() {\n        return new CDNConfig(context);\n    }\n\n    public void message(List<String> paths, String... languages) {\n        if (messageConfigured) {\n            throw new Error(\"site().message() can only be configured once and must before adding template\");\n        }\n        messageConfigured = true;\n\n        context.httpServer.siteManager.message.load(paths, languages);\n        context.beanFactory.bind(Message.class, null, message(context.httpServer.siteManager.message));\n    }\n\n    Message message(MessageImpl message) {\n        return message;\n    }\n\n    public void template(String path, Class<?> modelClass) {\n        messageConfigured = true; // can not configure message() after adding template\n        context.httpServer.siteManager.templateManager.add(path, modelClass);\n    }\n\n    // this is only for POC or local testing, in cloud env, all static content should be served from LB + AWS S3/Google Storage/Azure Storage Account\n    public StaticContentConfig staticContent(String path) {\n        logger.info(\"add static content path, path={}\", path);\n        Path contentPath = context.httpServer.siteManager.webDirectory.path(path);\n        if (!Files.exists(contentPath, LinkOption.NOFOLLOW_LINKS)) throw new Error(\"path does not exist, path=\" + path);\n\n        StaticContentController controller;\n        if (Files.isDirectory(contentPath)) {\n            controller = new StaticDirectoryController(contentPath);\n            context.route(HTTPMethod.GET, path + \"/:path(*)\", controller, true);\n        } else {\n            controller = new StaticFileController(contentPath);\n            context.route(HTTPMethod.GET, path, controller, true);\n        }\n        return new StaticContentConfig(controller);\n    }\n\n    public WebSecurityConfig security() {\n        if (webSecurityInterceptor == null) {\n            webSecurityInterceptor = new WebSecurityInterceptor();\n            context.httpServerConfig.interceptors.add(webSecurityInterceptor);\n        }\n        return new WebSecurityConfig(webSecurityInterceptor);\n    }\n\n    public void allowAPI(List<String> cidrs) {\n        logger.info(\"allow /_sys/api access, cidrs={}\", cidrs);\n        context.apiController.accessControl.allow = new IPv4Ranges(cidrs);\n    }\n}\n```\n\nStaticContentConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.web.site.StaticContentController;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class StaticContentConfig {\n    private final StaticContentController controller;\n\n    StaticContentConfig(StaticContentController controller) {\n        this.controller = controller;\n    }\n\n    public void cache(Duration maxAge) {\n        if (maxAge == null || maxAge.getSeconds() <= 0) throw new Error(\"maxAge must be greater than 0, maxAge=\" + maxAge);\n        controller.cache(maxAge);\n    }\n}\n```\n\nSystemModule.java\n```java\npackage core.framework.module;\n\n/**\n * @author neo\n */\npublic final class SystemModule extends Module {\n    private final String propertyFileClasspath;\n\n    public SystemModule(String propertyFileClasspath) {\n        this.propertyFileClasspath = propertyFileClasspath;\n    }\n\n    @Override\n    protected void initialize() {\n        loadProperties(propertyFileClasspath);\n\n        configureHTTP();\n        configureCache();\n        configureLog();\n        property(\"sys.kafka.uri\").ifPresent(uri -> kafka().uri(uri));\n        configureDB();\n        property(\"sys.redis.host\").ifPresent(host -> redis().host(host));\n        configureSite();\n    }\n\n    private void configureCache() {\n        property(\"sys.cache.host\").ifPresent(host -> {\n            if (\"local\".equals(host)) {\n                cache().local();\n            } else {\n                cache().redis(host);\n            }\n        });\n    }\n\n    void configureSite() {\n        property(\"sys.session.host\").ifPresent(host -> {\n            if (\"local\".equals(host)) {\n                site().session().local();\n            } else {\n                site().session().redis(host);\n            }\n        });\n        property(\"sys.cdn.host\").ifPresent(host -> site().cdn().host(host));\n        property(\"sys.security.csp\").ifPresent(policy -> site().security().contentSecurityPolicy(policy));\n        property(\"sys.api.allowCIDR\").ifPresent(cidrs -> site().allowAPI(new IPv4RangePropertyValueParser(cidrs).parse()));\n    }\n\n    void configureHTTP() {\n        property(\"sys.http.listen\").ifPresent(host -> http().listenHTTP(host));\n        property(\"sys.https.listen\").ifPresent(host -> http().listenHTTPS(host));\n        property(\"sys.http.allowCIDR\").ifPresent(cidrs -> http().access().allow(new IPv4RangePropertyValueParser(cidrs).parse()));\n    }\n\n    private void configureLog() {\n        property(\"sys.log.appender\").ifPresent(appender -> {\n            if (\"console\".equals(appender)) {\n                log().appendToConsole();\n            } else {\n                log().appendToKafka(appender);\n            }\n        });\n    }\n\n    private void configureDB() {\n        property(\"sys.jdbc.url\").ifPresent(url -> db().url(url));\n        property(\"sys.jdbc.user\").ifPresent(user -> db().user(user));\n        property(\"sys.jdbc.password\").ifPresent(password -> db().password(password));\n    }\n}\n```\n\nWebSecurityConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.web.site.WebSecurityInterceptor;\n\n/**\n * @author neo\n */\npublic class WebSecurityConfig {\n    final WebSecurityInterceptor interceptor;\n\n    WebSecurityConfig(WebSecurityInterceptor interceptor) {\n        this.interceptor = interceptor;\n    }\n\n    public void contentSecurityPolicy(String policy) {\n        if (policy == null) throw new Error(\"policy must not be null\");\n        interceptor.contentSecurityPolicy = policy;\n    }\n}\n```\n\nWebSocketConfig.java\n```java\npackage core.framework.module;\n\nimport core.framework.internal.inject.InjectValidator;\nimport core.framework.internal.module.Config;\nimport core.framework.internal.module.ModuleContext;\nimport core.framework.internal.web.HTTPIOHandler;\nimport core.framework.internal.web.websocket.ChannelHandler;\nimport core.framework.internal.web.websocket.WebSocketHandler;\nimport core.framework.internal.web.websocket.WebSocketMetrics;\nimport core.framework.web.websocket.ChannelListener;\nimport core.framework.web.websocket.WebSocketContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class WebSocketConfig extends Config {\n    // use http().limitRate().add(WebSocketConfig.WS_OPEN_GROUP, ...) to configure rate limiting for ws connections\n    public static final String WS_OPEN_GROUP = \"ws:open\";\n\n    private final Logger logger = LoggerFactory.getLogger(WebSocketConfig.class);\n    ModuleContext context;\n\n    @Override\n    protected void initialize(ModuleContext context, @Nullable String name) {\n        this.context = context;\n    }\n\n    @Override\n    protected void validate() {\n        if (!context.httpServer.handler.rateControl.hasGroup(WS_OPEN_GROUP)) {\n            context.httpServer.handler.rateControl.config(WS_OPEN_GROUP, 10, 10, Duration.ofSeconds(30));\n        }\n    }\n\n    public <T, V> void listen(String path, Class<T> clientMessageClass, Class<V> serverMessageClass, ChannelListener<T, V> listener) {\n        if (HTTPIOHandler.HEALTH_CHECK_PATH.equals(path)) throw new Error(\"/health-check is reserved path\");\n        if (path.contains(\"/:\")) throw new Error(\"listener path must be static, path=\" + path);\n\n        if (listener.getClass().isSynthetic())\n            throw new Error(\"listener class must not be anonymous class or lambda, please create static class, listenerClass=\" + listener.getClass().getCanonicalName());\n        new InjectValidator(listener).validate();\n\n        logger.info(\"ws, path={}, clientMessageClass={}, serverMessageClass={}, listener={}\",\n            path, clientMessageClass.getCanonicalName(), serverMessageClass.getCanonicalName(), listener.getClass().getCanonicalName());\n\n        if (context.httpServer.handler.webSocketHandler == null) {\n            context.httpServer.handler.webSocketHandler = new WebSocketHandler(context.logManager, context.httpServer.siteManager.sessionManager, context.httpServer.handler.rateControl);\n            context.beanFactory.bind(WebSocketContext.class, null, context.httpServer.handler.webSocketHandler.context);\n\n            context.collector.metrics.add(new WebSocketMetrics(context.httpServer.handler.webSocketHandler));\n        }\n\n        context.beanClassValidator.validate(clientMessageClass);\n        context.beanClassValidator.validate(serverMessageClass);\n        context.apiController.beanClasses.add(clientMessageClass);\n        context.apiController.beanClasses.add(serverMessageClass);\n\n        var handler = new ChannelHandler<>(clientMessageClass, serverMessageClass, listener);\n        context.httpServer.handler.webSocketHandler.add(path, handler);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package redis."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.redis:\n\nRedis.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\n/**\n * @author neo\n */\npublic interface Redis {\n    @Nullable\n    String get(String key);\n\n    default void set(String key, String value) {\n        set(key, value, null, false);\n    }\n\n    default void set(String key, String value, Duration expiration) {\n        set(key, value, expiration, false);\n    }\n\n    boolean set(String key, String value, @Nullable Duration expiration, boolean onlyIfAbsent);\n\n    RedisSet set();\n\n    void expire(String key, Duration duration);\n\n    long del(String... keys);\n\n    long increaseBy(String key, long increment);\n\n    Map<String, String> multiGet(String... keys);\n\n    void multiSet(Map<String, String> values);\n\n    void forEach(String pattern, Consumer<String> consumer);\n\n    RedisHash hash();\n\n    RedisList list();\n\n    RedisSortedSet sortedSet();\n\n    RedisAdmin admin();\n\n    RedisHyperLogLog hyperLogLog();\n}\n```\n\nRedisAdmin.java\n```java\npackage core.framework.redis;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface RedisAdmin {\n    Map<String, String> info();\n}\n```\n\nRedisHash.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface RedisHash {\n    @Nullable\n    String get(String key, String field);\n\n    Map<String, String> getAll(String key);\n\n    void set(String key, String field, String value);\n\n    void multiSet(String key, Map<String, String> values);\n\n    long increaseBy(String key, String field, long increment);\n\n    long del(String key, String... fields);\n}\n```\n\nRedisHyperLogLog.java\n```java\npackage core.framework.redis;\n\n/**\n * @author tempo\n */\npublic interface RedisHyperLogLog {\n    boolean add(String key, String... values);\n\n    long count(String... keys);\n}\n```\n\nRedisList.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\n/**\n * @author rexthk\n */\npublic interface RedisList {\n    @Nullable\n    default String pop(String key) {\n        List<String> values = pop(key, 1);\n        return values.isEmpty() ? null : values.get(0);\n    }\n\n    List<String> pop(String key, int size);\n\n    // return the length of the list after the push operation\n    long push(String key, String... values);\n\n    default List<String> range(String key) {\n        return range(key, 0, -1);\n    }\n\n    List<String> range(String key, long start, long stop);\n\n    // trim the list, only keep most recent items\n    void trim(String key, int maxSize);\n}\n```\n\nRedisSet.java\n```java\npackage core.framework.redis;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic interface RedisSet {\n    long add(String key, String... values);\n\n    Set<String> members(String key);\n\n    boolean isMember(String key, String value);\n\n    long remove(String key, String... values);\n\n    // use pop(key, Long.MAX_VALUE) to pop all elements\n    Set<String> pop(String key, long count);\n\n    long size(String key);\n}\n```\n\nRedisSortedSet.java\n```java\npackage core.framework.redis;\n\nimport javax.annotation.Nullable;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * @author tempo\n */\npublic interface RedisSortedSet {\n    // use long as score to keep precision, redis uses float type for score\n    default boolean add(String key, String value, long score) {\n        return add(key, Map.of(value, score), false) == 1;\n    }\n\n    int add(String key, Map<String, Long> values, boolean onlyIfAbsent);\n\n    long increaseScoreBy(String key, String value, long increment);\n\n    default Map<String, Long> range(String key) {\n        return range(key, 0, -1);\n    }\n\n    Map<String, Long> range(String key, long start, long stop);\n\n    default Map<String, Long> rangeByScore(String key, long minScore, long maxScore) {\n        return rangeByScore(key, minScore, maxScore, -1);\n    }\n\n    Map<String, Long> rangeByScore(String key, long minScore, long maxScore, long limit);\n\n    default Map<String, Long> popByScore(String key, long minScore, long maxScore) {\n        return popByScore(key, minScore, maxScore, -1);\n    }\n\n    Map<String, Long> popByScore(String key, long minScore, long maxScore, long limit);\n\n    @Nullable\n    default String popMin(String key) {\n        Map<String, Long> values = popMin(key, 1);\n        Iterator<String> iterator = values.keySet().iterator();\n        if (iterator.hasNext()) return iterator.next();\n        return null;\n    }\n\n    Map<String, Long> popMin(String key, long limit);\n\n    long remove(String key, String... values);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package scheduler."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.scheduler:\n\nJob.java\n```java\npackage core.framework.scheduler;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Job {\n    void execute(JobContext context) throws Exception;\n}\n```\n\nJobContext.java\n```java\npackage core.framework.scheduler;\n\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\npublic class JobContext {\n    public final String name;\n    public final ZonedDateTime scheduledTime;\n\n    public JobContext(String name, ZonedDateTime scheduledTime) {\n        this.name = name;\n        this.scheduledTime = scheduledTime;\n    }\n}\n```\n\nTrigger.java\n```java\npackage core.framework.scheduler;\n\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Trigger {\n    ZonedDateTime next(ZonedDateTime previous);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package template."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.template:\n\nHTMLTemplateEngine.java\n```java\npackage core.framework.template;\n\nimport core.framework.internal.template.CDNManager;\nimport core.framework.internal.template.HTMLTemplate;\nimport core.framework.internal.template.HTMLTemplateBuilder;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.source.ClasspathTemplateSource;\nimport core.framework.internal.template.source.StringTemplateSource;\nimport core.framework.internal.template.source.TemplateSource;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class HTMLTemplateEngine {\n    private final Logger logger = LoggerFactory.getLogger(HTMLTemplateEngine.class);\n    private final Map<String, HTMLTemplate> templates = Maps.newConcurrentHashMap();\n    private final CDNManager cdnManager = new CDNManager();\n\n    public String process(String name, Object model) {\n        var watch = new StopWatch();\n        try {\n            HTMLTemplate template = templates.get(name);\n            if (template == null) throw new Error(\"template not found, name=\" + name);\n            TemplateContext context = new TemplateContext(model, cdnManager);\n            return template.process(context);\n        } finally {\n            logger.debug(\"process, name={}, elapsed={}\", name, watch.elapsed());\n        }\n    }\n\n    public void add(String name, String template, Class<?> modelClass) {\n        add(new StringTemplateSource(name, template), modelClass);\n    }\n\n    public void add(String classpath, Class<?> modelClass) {\n        add(new ClasspathTemplateSource(classpath), modelClass);\n    }\n\n    private void add(TemplateSource source, Class<?> modelClass) {\n        var watch = new StopWatch();\n        String name = source.name();\n        try {\n            HTMLTemplate previous = templates.putIfAbsent(name, new HTMLTemplateBuilder(source, modelClass).build());\n            if (previous != null) throw new Error(\"template is already added, name=\" + name);\n        } finally {\n            logger.info(\"add, name={}, modelClass={}, elapsed={}\", name, modelClass.getCanonicalName(), watch.elapsed());\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of core-ng package web."}, {"role": "assistant", "content": "Here is the source code of core-ng package core.framework.web:\n\nController.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Controller {\n    Response execute(Request request) throws Exception;\n}\n```\n\nCookieSpec.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.util.Objects;\n\n/**\n * @author neo\n */\npublic final class CookieSpec {\n    private static final Duration SESSION_SCOPE = Duration.ofSeconds(-1);\n\n    public final String name;\n    @Nullable\n    public String domain;\n    @Nullable\n    public String path;\n    public boolean httpOnly;\n    public boolean secure;\n    @Nullable\n    public Duration maxAge;\n    public boolean sameSite;\n\n    public CookieSpec(String name) {\n        this.name = name;\n    }\n\n    public CookieSpec httpOnly() {\n        httpOnly = true;\n        return this;\n    }\n\n    public CookieSpec domain(String domain) {\n        this.domain = domain;\n        return this;\n    }\n\n    public CookieSpec path(String path) {\n        this.path = path;\n        return this;\n    }\n\n    public CookieSpec secure() {\n        secure = true;\n        return this;\n    }\n\n    public CookieSpec maxAge(Duration maxAge) {\n        this.maxAge = maxAge;\n        return this;\n    }\n\n    public CookieSpec sessionScope() {\n        maxAge = SESSION_SCOPE;\n        return this;\n    }\n\n    public CookieSpec sameSite() {\n        sameSite = true;\n        return this;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null || getClass() != other.getClass()) return false;\n        CookieSpec spec = (CookieSpec) other;\n        return Objects.equals(name, spec.name)\n                && Objects.equals(domain, spec.domain)\n                && Objects.equals(path, spec.path);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, domain, path);\n    }\n}\n\n\n```\n\nErrorHandler.java\n```java\npackage core.framework.web;\n\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface ErrorHandler {\n    Optional<Response> handle(Request request, Throwable e);\n}\n```\n\nBadRequestException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.BAD_REQUEST)\npublic final class BadRequestException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = -2304226404736886782L;\n\n    private final String errorCode;\n\n    public BadRequestException(String message) {\n        super(message);\n        errorCode = \"BAD_REQUEST\";\n    }\n\n    public BadRequestException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public BadRequestException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nConflictException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.CONFLICT)\npublic final class ConflictException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 7787085179989898162L;\n\n    private final String errorCode;\n\n    public ConflictException(String message) {\n        super(message);\n        errorCode = \"CONFLICT\";\n    }\n\n    public ConflictException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public ConflictException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nForbiddenException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.FORBIDDEN)\npublic final class ForbiddenException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 5472429043879214361L;\n\n    private final String errorCode;\n\n    public ForbiddenException(String message) {\n        super(message);\n        errorCode = \"FORBIDDEN\";\n    }\n\n    public ForbiddenException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public ForbiddenException(String message, String errorCode, Throwable cause) {\n        super(message, cause);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nMethodNotAllowedException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.METHOD_NOT_ALLOWED)\npublic final class MethodNotAllowedException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 2349080664326196294L;\n\n    public MethodNotAllowedException(String message) {\n        super(message);\n    }\n\n    public MethodNotAllowedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"METHOD_NOT_ALLOWED\";\n    }\n}\n```\n\nNotFoundException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.NOT_FOUND)\npublic final class NotFoundException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 8663360723004690205L;\n\n    private final String errorCode;\n\n    public NotFoundException(String message) {\n        super(message);\n        errorCode = \"NOT_FOUND\";\n    }\n\n    public NotFoundException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```\n\nTooManyRequestsException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.TOO_MANY_REQUESTS)\npublic final class TooManyRequestsException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 6657854760603154454L;\n\n    public TooManyRequestsException(String message) {\n        super(message);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"TOO_MANY_REQUESTS\";\n    }\n}\n```\n\nUnauthorizedException.java\n```java\npackage core.framework.web.exception;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\n@ResponseStatus(HTTPStatus.UNAUTHORIZED)\npublic final class UnauthorizedException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = 5545181864430282120L;\n\n    public UnauthorizedException(String message) {\n        super(message);\n    }\n\n    public UnauthorizedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    @Override\n    public Severity severity() {\n        return Severity.WARN;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"UNAUTHORIZED\";\n    }\n}\n```\n\nInterceptor.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\n@FunctionalInterface\npublic interface Interceptor {\n    Response intercept(Invocation invocation) throws Exception;\n}\n```\n\nInvocation.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.lang.annotation.Annotation;\n\n/**\n * @author neo\n */\npublic interface Invocation {\n    @Nullable\n    <T extends Annotation> T annotation(Class<T> annotationClass);\n\n    WebContext context();\n\n    Response proceed() throws Exception;\n}\n```\n\nMultipartFile.java\n```java\npackage core.framework.web;\n\nimport java.nio.file.Path;\n\n/**\n * @author neo\n */\npublic final class MultipartFile {\n    public final Path path;\n    public final String fileName;\n    public final String contentType;\n\n    public MultipartFile(Path path, String fileName, String contentType) {\n        this.path = path;\n        this.fileName = fileName;\n        this.contentType = contentType;\n    }\n}\n```\n\nLimitRate.java\n```java\npackage core.framework.web.rate;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author neo\n */\n@Target({TYPE, METHOD})\n@Retention(RUNTIME)\npublic @interface LimitRate {\n    String value();\n}\n```\n\nRequest.java\n```java\npackage core.framework.web;\n\nimport core.framework.http.HTTPMethod;\n\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Request {\n    String requestURL();  // original request url without decoding\n\n    String scheme();\n\n    String hostname();\n\n    String path();      // original path without decoding\n\n    HTTPMethod method();\n\n    Optional<String> header(String name);\n\n    String pathParam(String name);\n\n    Map<String, String> queryParams();\n\n    Map<String, String> formParams();\n\n    Map<String, MultipartFile> files();\n\n    Optional<byte[]> body();\n\n    <T> T bean(Class<T> beanClass);\n\n    String clientIP();\n\n    Optional<String> cookie(CookieSpec spec);\n\n    Session session();\n}\n```\n\nResponse.java\n```java\npackage core.framework.web;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPHeaders;\nimport core.framework.internal.web.response.BeanBody;\nimport core.framework.internal.web.response.ByteArrayBody;\nimport core.framework.internal.web.response.FileBody;\nimport core.framework.internal.web.response.ResponseImpl;\nimport core.framework.internal.web.response.TemplateBody;\nimport core.framework.internal.web.response.TextBody;\n\nimport javax.annotation.Nullable;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Response {\n    static Response text(String text) {\n        return new ResponseImpl(new TextBody(text))\n                .contentType(ContentType.TEXT_PLAIN);\n    }\n\n    static Response bean(Object bean) {\n        if (bean == null) throw new Error(\"bean must not be null\");\n        return new ResponseImpl(new BeanBody(bean))\n                .contentType(ContentType.APPLICATION_JSON);\n    }\n\n    static Response html(String templatePath, Object model) {\n        return html(templatePath, model, null);\n    }\n\n    static Response html(String templatePath, Object model, @Nullable String language) {\n        return new ResponseImpl(new TemplateBody(templatePath, model, language))\n                .contentType(ContentType.TEXT_HTML);\n    }\n\n    static Response empty() {\n        return new ResponseImpl(new ByteArrayBody(new byte[0])).status(HTTPStatus.NO_CONTENT);\n    }\n\n    static Response bytes(byte[] bytes) {\n        return new ResponseImpl(new ByteArrayBody(bytes))\n                .contentType(ContentType.APPLICATION_OCTET_STREAM);\n    }\n\n    static Response file(Path path) {\n        return new ResponseImpl(new FileBody(path));\n    }\n\n    static Response redirect(String url) {\n        return redirect(url, HTTPStatus.SEE_OTHER);\n    }\n\n    static Response redirect(String url, HTTPStatus redirectStatus) {\n        if (redirectStatus != HTTPStatus.SEE_OTHER\n                && redirectStatus != HTTPStatus.MOVED_PERMANENTLY\n                && redirectStatus != HTTPStatus.PERMANENT_REDIRECT\n                && redirectStatus != HTTPStatus.TEMPORARY_REDIRECT)\n            throw new Error(\"invalid redirect status, status=\" + redirectStatus);\n\n        return new ResponseImpl(new ByteArrayBody(new byte[0]))\n                .header(HTTPHeaders.LOCATION, url)\n                .status(redirectStatus);\n    }\n\n    HTTPStatus status();\n\n    Response status(HTTPStatus status);\n\n    Optional<String> header(String name);\n\n    Response header(String name, @Nullable String value);\n\n    Optional<ContentType> contentType();\n\n    Response contentType(ContentType contentType);\n\n    Response cookie(CookieSpec spec, @Nullable String value);\n}\n```\n\nRemoteServiceException.java\n```java\npackage core.framework.web.service;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\n\n/**\n * @author neo\n */\npublic final class RemoteServiceException extends RuntimeException implements ErrorCode {\n    private static final long serialVersionUID = 6935063785656278927L;\n\n    public final HTTPStatus status;\n    private final Severity severity;\n    private final String errorCode;\n\n    public RemoteServiceException(String message, Severity severity, String errorCode, HTTPStatus status) {\n        super(message);\n        this.severity = severity;\n        this.errorCode = errorCode;\n        this.status = status;\n    }\n\n    public RemoteServiceException(String message, Severity severity, String errorCode, HTTPStatus status, Throwable cause) {\n        super(message, cause);\n        this.severity = severity;\n        this.errorCode = errorCode;\n        this.status = status;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n\n    @Override\n    public Severity severity() {\n        return severity;\n    }\n}\n```\n\nWebServiceClientInterceptor.java\n```java\npackage core.framework.web.service;\n\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\n\n/**\n * @author neo\n */\npublic interface WebServiceClientInterceptor {\n    default void onRequest(HTTPRequest request) {\n    }\n\n    default void onResponse(HTTPResponse response) {\n    }\n}\n```\n\nWebServiceClientProxy.java\n```java\npackage core.framework.web.service;\n\n/**\n * @author neo\n */\npublic interface WebServiceClientProxy {    // all dynamic webservice clients will impl this interface to support extension\n    void intercept(WebServiceClientInterceptor interceptor);\n}\n```\n\nSession.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface Session {\n    Optional<String> get(String key);\n\n    void set(String key, @Nullable String value); // set value to null to remove key\n\n    void invalidate();\n}\n```\n\nSessionContext.java\n```java\npackage core.framework.web;\n\n/**\n * @author neo\n */\npublic interface SessionContext {\n    // invalidate all session matches key=value\n    void invalidate(String key, String value);\n}\n```\n\nMessage.java\n```java\npackage core.framework.web.site;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface Message {\n    String get(String key, @Nullable String language);\n\n    default String get(String key) {\n        return get(key, null);\n    }\n}\n```\n\nWebDirectory.java\n```java\npackage core.framework.web.site;\n\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * @author neo\n */\npublic final class WebDirectory {\n    private final Logger logger = LoggerFactory.getLogger(WebDirectory.class);\n\n    private final Path root;\n    public boolean localEnv;\n\n    public WebDirectory() {\n        this.root = locateRootDirectory();\n    }\n\n    private Path locateRootDirectory() {\n        String value = System.getProperty(\"core.webPath\");\n        if (value != null) {\n            Path path = Paths.get(value).toAbsolutePath();\n            if (Files.isDirectory(path)) {\n                logger.info(\"found -Dcore.webPath as web directory, path={}\", path);\n                return path;\n            }\n        } else {\n            Path path = findLocalRootDirectory();\n            if (path != null) {\n                logger.info(\"found local web directory, this should only happen in local dev env or test, path={}\", path);\n                localEnv = true;\n                try {\n                    return path.toRealPath();\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n        }\n        logger.info(\"can not locate web directory\");\n        return null;\n    }\n\n    private Path findLocalRootDirectory() {\n        Path path = Paths.get(\"./src/main/dist/web\");\n        if (Files.isDirectory(path)) return path;\n        return null;\n    }\n\n    public Path path(String path) {\n        if (!Strings.startsWith(path, '/')) throw new Error(\"path must start with '/', path=\" + path);\n        return root().resolve(path.substring(1)).toAbsolutePath();\n    }\n\n    public Path root() {\n        if (root == null)\n            throw new Error(\"can not find web path, set working dir to module dir for local dev env, or check -Dcore.webPath for server env, workingDir=\" + System.getProperty(\"user.dir\"));\n        return root;\n    }\n}\n```\n\nWebContext.java\n```java\npackage core.framework.web;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface WebContext {\n    Object get(String key);     // context is used to pass value from interceptor to controller/ws, key will be static and deterministic, that's why here is designed to return Object, not Optional<T>\n\n    void put(String key, Object value);\n\n    Request request();\n\n    // to let ws assign cookie to response\n    void responseCookie(CookieSpec spec, @Nullable String value);\n}\n```\n\nChannel.java\n```java\npackage core.framework.web.websocket;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic interface Channel<V> {\n    void send(V message);\n\n    Context context();\n\n    void close();\n\n    void join(String room);\n\n    void leave(String room);\n\n    interface Context {\n        @Nullable\n        Object get(String key); // channel is stateful, context key usually be static put onConnect, so in most of the cases get(key) expects result, that's why here is designed to return Object, not Optional<T>\n\n        void put(String key, @Nullable Object value);\n    }\n}\n```\n\nChannelListener.java\n```java\npackage core.framework.web.websocket;\n\nimport core.framework.web.Request;\n\n/**\n * @author neo\n */\npublic interface ChannelListener<T, V> {\n    default void onConnect(Request request, Channel<V> channel) {\n    }\n\n    void onMessage(Channel<V> channel, T message);\n\n    default void onClose(Channel<V> channel, int code, String reason) {\n    }\n}\n```\n\nWebSocketContext.java\n```java\npackage core.framework.web.websocket;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic interface WebSocketContext {\n    <V> List<Channel<V>> all();\n\n    <V> List<Channel<V>> room(String name);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CodeBuilder.java."}, {"role": "assistant", "content": "The source code of java class CodeBuilder.java:\n```java\npackage core.framework.internal.asm;\n\nimport core.framework.util.Strings;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class CodeBuilder {\n    private final StringBuilder builder = new StringBuilder(256);\n\n    public CodeBuilder append(String text) {\n        builder.append(text);\n        return this;\n    }\n\n    public CodeBuilder append(char ch) {\n        builder.append(ch);\n        return this;\n    }\n\n    public CodeBuilder append(Object object) {\n        builder.append(object);\n        return this;\n    }\n\n    public CodeBuilder append(String pattern, Object... params) {\n        builder.append(Strings.format(pattern, params));\n        return this;\n    }\n\n    public CodeBuilder appendCommaSeparatedValues(List<String> values) {\n        int index = 0;\n        for (String value : values) {\n            if (index > 0) builder.append(\", \");\n            builder.append(value);\n            index++;\n        }\n        return this;\n    }\n\n    public CodeBuilder indent(int indent) {\n        for (int i = 0; i < indent; i++)\n            builder.append(\"    \");\n        return this;\n    }\n\n    public String build() {\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DynamicInstanceBuilder.java."}, {"role": "assistant", "content": "The source code of java class DynamicInstanceBuilder.java:\n```java\npackage core.framework.internal.asm;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtField;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class DynamicInstanceBuilder<T> {\n    private static AtomicInteger index = new AtomicInteger();\n    private static ClassPool pool;\n\n    static {\n        pool = new ClassPool(null);\n        pool.appendSystemPath();\n    }\n\n    public static void cleanup() {\n        pool = null;\n        index = null;\n    }\n\n    private final CtClass classBuilder;\n    private final Class<? super T> interfaceClass;\n    private Class<?>[] constructorParamClasses;\n    private final SourceCode sourceCode = new SourceCode();\n\n    // with java modules, the generated class must be within same package of lookup class\n    // refer to javassist.util.proxy.DefineClassHelper.toClass(java.lang.Class<?>, byte[])\n    // so here it will always use interfaceClass as prefix of generated class name, and append name\n    public DynamicInstanceBuilder(Class<? super T> interfaceClass, String name) {\n        if (!interfaceClass.isInterface())\n            throw new Error(\"class must be interface, class=\" + interfaceClass.getCanonicalName());\n\n        this.interfaceClass = interfaceClass;\n        sourceCode.interfaceClass = interfaceClass;\n        var className = new StringBuilder(interfaceClass.getName());    // must not use canonical name, as it turn nested class into dot, which confuse package name\n        if (name != null) className.append('$').append(name);\n        sourceCode.classNameReference = className.toString();\n        // can only be used during config time within module, App will run cleanup after startup\n        classBuilder = pool.makeClass(className.append('$').append(index.getAndIncrement()).toString());\n\n        try {\n            classBuilder.addInterface(pool.get(interfaceClass.getName()));\n            var constructor = new CtConstructor(null, classBuilder);\n            constructor.setBody(\";\");\n            classBuilder.addConstructor(constructor);\n        } catch (NotFoundException | CannotCompileException e) {\n            throw new Error(e);\n        }\n    }\n\n    public void constructor(Class<?>[] constructorParamClasses, String body) {\n        if (this.constructorParamClasses != null)\n            throw new Error(\"dynamic class must not have more than one custom constructor\");\n\n        sourceCode.constructorParamClasses = constructorParamClasses;\n        sourceCode.constructorBody = body;\n\n        try {\n            this.constructorParamClasses = constructorParamClasses;\n            var params = new CtClass[constructorParamClasses.length];\n            for (int i = 0; i < constructorParamClasses.length; i++) {\n                Class<?> paramClass = constructorParamClasses[i];\n                params[i] = pool.getCtClass(paramClass.getName());\n            }\n            var constructor = new CtConstructor(params, classBuilder);\n            constructor.setBody(body);\n            classBuilder.addConstructor(constructor);\n        } catch (CannotCompileException | NotFoundException e) {\n            throw new Error(format(\"{}, source:\\n{}\", e.getMessage(), body), e);\n        }\n    }\n\n    public void addInterface(Class<?> interfaceClass) {\n        try {\n            classBuilder.addInterface(pool.get(interfaceClass.getName()));\n        } catch (NotFoundException e) {\n            throw new Error(e);\n        }\n    }\n\n    public void addMethod(String method) {\n        sourceCode.methods.add(method);\n        try {\n            classBuilder.addMethod(CtMethod.make(method, classBuilder));\n        } catch (CannotCompileException e) {\n            throw new Error(format(\"{}, source:\\n{}\", e.getMessage(), method), e);\n        }\n    }\n\n    public void addField(String pattern, Object... argument) {\n        String field = format(pattern, argument);\n        sourceCode.fields.add(field);\n        try {\n            classBuilder.addField(CtField.make(field, classBuilder));\n        } catch (CannotCompileException e) {\n            throw new Error(format(\"{}, source:\\n{}\", e.getMessage(), field), e);\n        }\n    }\n\n    public T build(Object... constructorParams) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            Class<T> targetClass = (Class<T>) classBuilder.toClass(interfaceClass);\n            classBuilder.detach();\n            return targetClass.getDeclaredConstructor(constructorParamClasses).newInstance(constructorParams);\n        } catch (CannotCompileException | ReflectiveOperationException e) {\n            throw new Error(e);\n        }\n    }\n\n    public String sourceCode() {\n        return sourceCode.build();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Literal.java."}, {"role": "assistant", "content": "The source code of java class Literal.java:\n```java\npackage core.framework.internal.asm;\n\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.util.Types;\n\nimport java.lang.reflect.Type;\n\n/**\n * @author neo\n */\npublic final class Literal {\n    public static String type(Class<?> value) {\n        return value.getCanonicalName();\n    }\n\n    public static String variable(Enum<?> value) {\n        return value.getDeclaringClass().getCanonicalName() + \".\" + value.name();\n    }\n\n    public static String variable(Type type) {\n        if (GenericTypes.isList(type)) {\n            return Types.class.getCanonicalName() + \".list(\" + GenericTypes.listValueClass(type).getCanonicalName() + \".class)\";\n        } else if (GenericTypes.isOptional(type)) {\n            return Types.class.getCanonicalName() + \".optional(\" + GenericTypes.optionalValueClass(type).getCanonicalName() + \".class)\";\n        } else {\n            return GenericTypes.rawClass(type).getCanonicalName() + \".class\";\n        }\n    }\n\n    public static String variable(String text) {\n        if (text == null) return \"null\";\n\n        var builder = new StringBuilder(\"\\\"\");\n        int length = text.length();\n        for (int i = 0; i < length; i++) {\n            char ch = text.charAt(i);\n            switch (ch) {\n                case '\\n' -> builder.append(\"\\\\n\");\n                case '\\r' -> builder.append(\"\\\\r\");\n                case '\"' -> builder.append(\"\\\\\\\"\");\n                case '\\\\' -> builder.append(\"\\\\\\\\\");\n                default -> builder.append(ch);\n            }\n        }\n        builder.append('\\\"');\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SourceCode.java."}, {"role": "assistant", "content": "The source code of java class SourceCode.java:\n```java\npackage core.framework.internal.asm;\n\nimport core.framework.util.Lists;\n\nimport java.util.List;\n\nimport static core.framework.internal.asm.Literal.type;\n\n/**\n * @author neo\n */\nfinal class SourceCode {\n    final List<String> fields = Lists.newArrayList();\n    final List<String> methods = Lists.newArrayList();\n    Class<?> interfaceClass;\n    String classNameReference;   // SourceCode is only used on test/verification purpose, the actual className generated by DynamicInstanceBuilder has dynamic numeric postfix\n    Class<?>[] constructorParamClasses;\n    String constructorBody;\n\n    public String build() {\n        var builder = new CodeBuilder();\n        String classSimpleName = classNameReference.substring(classNameReference.lastIndexOf('.') + 1);\n        builder.append(\"public class {} implements {} {\\n\", classSimpleName, type(interfaceClass));\n        for (String field : fields) {\n            builder.indent(1).append(field);\n            builder.append(\"\\n\\n\");\n        }\n        if (constructorParamClasses != null) {\n            buildConstructor(builder, classSimpleName);\n            builder.append(\"\\n\\n\");\n        }\n        for (String method : methods) {\n            addMethod(builder, method);\n            builder.append(\"\\n\\n\");\n        }\n        builder.append(\"}\\n\");\n        return builder.build();\n    }\n\n    private void addMethod(CodeBuilder builder, String method) {\n        builder.append(\"    \");\n        int length = method.length();\n        for (int i = 0; i < length; i++) {\n            char ch = method.charAt(i);\n            if (ch == '\\n') builder.append(\"\\n    \"); // indent method\n            else builder.append(ch);\n        }\n    }\n\n    private void buildConstructor(CodeBuilder builder, String classSimpleName) {\n        builder.indent(1).append(\"public {}(\", classSimpleName);\n        for (int i = 0; i < constructorParamClasses.length; i++) {\n            Class<?> paramClass = constructorParamClasses[i];\n            if (i > 0) builder.append(\", \");\n            builder.append(\"{} ${}\", type(paramClass), i + 1);\n        }\n        builder.append(\") {\\n\");\n        builder.indent(2).append(constructorBody).append(\"\\n\")\n               .indent(1).append('}');\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CallableTask.java."}, {"role": "assistant", "content": "The source code of java class CallableTask.java:\n```java\npackage core.framework.internal.async;\n\nimport core.framework.async.Task;\n\nimport java.util.concurrent.Callable;\n\n/**\n * @author neo\n */\npublic record CallableTask(Task task) implements Callable<Void> {\n    static Class<?> taskClass(Callable<?> task) {\n        // task can only be Callable or Task\n        if (task instanceof CallableTask callableTask) return callableTask.task.getClass();\n        return task.getClass();\n    }\n\n    @Override\n    public Void call() throws Exception {\n        task.execute();\n        return null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CancelledFuture.java."}, {"role": "assistant", "content": "The source code of java class CancelledFuture.java:\n```java\npackage core.framework.internal.async;\n\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author neo\n */\nclass CancelledFuture<T> implements Future<T> {\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        return true;\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return true;\n    }\n\n    @Override\n    public boolean isDone() {\n        return false;\n    }\n\n    @Override\n    public T get() {\n        throw new CancellationException();\n    }\n\n    @Override\n    public T get(long timeout, TimeUnit unit) {\n        throw new CancellationException();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExecutorImpl.java."}, {"role": "assistant", "content": "The source code of java class ExecutorImpl.java:\n```java\npackage core.framework.internal.async;\n\nimport core.framework.async.Executor;\nimport core.framework.async.Task;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.util.Sets;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class ExecutorImpl implements Executor {\n    private final Logger logger = LoggerFactory.getLogger(ExecutorImpl.class);\n    private final ExecutorService executor;\n    private final LogManager logManager;\n    private final long maxProcessTimeInNano;\n    private final ReentrantLock lock = new ReentrantLock();\n    private final Set<String> runningTasks = Sets.newConcurrentHashSet();     // track running tasks, used to print tasks failed to complete on shutdown\n\n    volatile ScheduledExecutorService scheduler;\n\n    public ExecutorImpl(ExecutorService executor, LogManager logManager, long maxProcessTimeInNano) {\n        this.executor = executor;\n        this.logManager = logManager;\n        this.maxProcessTimeInNano = maxProcessTimeInNano;\n    }\n\n    public void shutdown() {\n        logger.info(\"shutting down executor\");\n        lock.lock();\n        try {\n            if (scheduler != null) {\n                List<Runnable> canceledTasks = scheduler.shutdownNow(); // drop all delayed tasks\n                if (!canceledTasks.isEmpty()) {\n                    logger.warn(errorCode(\"TASK_REJECTED\"), \"delayed tasks are canceled due to server is shutting down, tasks={}\", canceledTasks);\n                }\n            }\n            executor.shutdown();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void awaitTermination(long timeoutInMs) throws InterruptedException {\n        boolean success = executor.awaitTermination(timeoutInMs, TimeUnit.MILLISECONDS);\n        if (!success) {\n            executor.shutdownNow();\n            if (!runningTasks.isEmpty()) {\n                logger.error(errorCode(\"FAILED_TO_STOP\"), \"failed to terminate executor, canceledTasks={}\", runningTasks);\n            }\n        }\n        logger.info(\"executor stopped\");\n    }\n\n    @Override\n    public <T> Future<T> submit(String action, Callable<T> task) {\n        var now = Instant.now();\n        String actionId = LogManager.ID_GENERATOR.next(now);\n        logger.debug(\"submit task, action={}, id={}, taskClass={}\", action, actionId, CallableTask.taskClass(task).getName());\n        ExecutorTask<T> execution = execution(actionId, action, now, task);\n        return submitTask(execution);\n    }\n\n    @Override\n    public Future<Void> submit(String action, Task task) {\n        // wrap task with class (rather than lambda), to preserve task class info\n        return submit(action, new CallableTask(task));\n    }\n\n    @Override\n    public void submit(String action, Task task, Duration delay) {\n        lock.lock();\n        try {\n            if (executor.isShutdown()) {\n                logger.warn(errorCode(\"TASK_REJECTED\"), \"reject task due to server is shutting down, action={}\", action);    // with current executor impl, rejection only happens when shutdown\n                return;\n            }\n            if (scheduler == null) {\n                scheduler = ThreadPools.singleThreadScheduler(\"executor-scheduler-\");\n            }\n        } finally {\n            lock.unlock();\n        }\n        scheduleDelayedTask(action, task, delay);\n    }\n\n    boolean scheduleDelayedTask(String action, Task task, Duration delay) {\n        var now = Instant.now();\n        String actionId = LogManager.ID_GENERATOR.next(now);\n        logger.debug(\"submit delayed task, action={}, id={}, delay={}\", action, actionId, delay);\n\n        // construct execution outside scheduler thread, to obtain parent action log\n        ExecutorTask<Void> execution = execution(actionId, action, now.plus(delay), new CallableTask(task));\n        try {\n            scheduler.schedule(new DelayedTask(execution), delay.toMillis(), TimeUnit.MILLISECONDS);\n            return true;\n        } catch (RejectedExecutionException e) {    // with current executor impl, rejection only happens when shutdown\n            logger.warn(errorCode(\"TASK_REJECTED\"), \"reject task due to server is shutting down, action={}\", action, e);\n        }\n        return false;\n    }\n\n    private <T> Future<T> submitTask(ExecutorTask<T> execution) {\n        String task = execution.toString();     // task is action:actionId which is unique\n        try {\n            runningTasks.add(task);\n            return executor.submit(execution);\n        } catch (RejectedExecutionException e) {    // with current executor impl, rejection only happens when shutdown\n            logger.warn(errorCode(\"TASK_REJECTED\"), \"reject task due to server is shutting down, action={}\", execution.action(), e);\n            runningTasks.remove(task);\n            return new CancelledFuture<>();\n        }\n    }\n\n    private <T> ExecutorTask<T> execution(String actionId, String action, Instant startTime, Callable<T> task) {\n        var context = new ExecutorTask.TaskContext(actionId, action, startTime, maxProcessTimeInNano, runningTasks);\n        ActionLog parentActionLog = LogManager.CURRENT_ACTION_LOG.get();\n        return new ExecutorTask<>(task, logManager, context, parentActionLog);\n    }\n\n    class DelayedTask implements Callable<Void> {\n        final ExecutorTask<Void> execution;\n\n        DelayedTask(ExecutorTask<Void> execution) {\n            this.execution = execution;\n        }\n\n        @Override\n        public Void call() {\n            try {\n                submitTask(execution);\n            } catch (Throwable e) {\n                logger.error(e.getMessage(), e);    // in scheduler.schedule exception will be swallowed, here is to log if any\n            }\n            return null;\n        }\n\n        // used to print all canceled tasks during shutdown\n        @Override\n        public String toString() {\n            return execution.toString();\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExecutorTask.java."}, {"role": "assistant", "content": "The source code of java class ExecutorTask.java:\n```java\npackage core.framework.internal.async;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.PerformanceWarning;\nimport core.framework.internal.log.Trace;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\n\n/**\n * @author neo\n */\nclass ExecutorTask<T> implements Callable<T> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExecutorTask.class);\n\n    private final Callable<T> task;\n    private final LogManager logManager;\n    private final TaskContext context;\n\n    private final String rootAction;\n    private final String correlationId;\n    private final String refId;\n    private final Trace trace;\n    @Nullable\n    private final PerformanceWarning[] warnings;\n\n    ExecutorTask(Callable<T> task, LogManager logManager, TaskContext context, ActionLog parentActionLog) {\n        this.task = task;\n        this.logManager = logManager;\n        this.context = context;\n        if (parentActionLog != null) {  // only keep info needed by call(), so parentActionLog can be GCed sooner\n            List<String> parentActionContext = parentActionLog.context.get(\"root_action\");\n            rootAction = parentActionContext != null ? parentActionContext.getFirst() : parentActionLog.action;\n            correlationId = parentActionLog.correlationId();\n            refId = parentActionLog.id;\n            trace = parentActionLog.trace == Trace.CASCADE ? Trace.CASCADE : null;  // trace only with parent.cascade\n            warnings = parentActionLog.warnings();\n        } else {\n            rootAction = null;\n            correlationId = null;\n            refId = null;\n            trace = null;\n            warnings = null;\n        }\n    }\n\n    @Override\n    public T call() throws Exception {\n        VirtualThread.COUNT.increase();\n        ActionLog actionLog = logManager.begin(\"=== task execution begin ===\", context.actionId);\n        try {\n            actionLog.action(action());\n            actionLog.warningContext.maxProcessTimeInNano(context.maxProcessTimeInNano);\n            // here doesn't log task class, due to task usually is lambda or method reference, it's expensive to inspect, refer to ControllerInspector\n            if (rootAction != null) { // if rootAction != null, then all parent info are available\n                actionLog.context(\"root_action\", rootAction);\n                LOGGER.debug(\"correlationId={}\", correlationId);\n                actionLog.correlationIds = List.of(correlationId);\n                LOGGER.debug(\"refId={}\", refId);\n                actionLog.refIds = List.of(refId);\n                if (trace != null) actionLog.trace = trace;\n                if (warnings != null) actionLog.initializeWarnings(warnings);\n            }\n            LOGGER.debug(\"taskClass={}\", CallableTask.taskClass(task).getName());\n            Duration delay = Duration.between(context.startTime, actionLog.date);\n            LOGGER.debug(\"taskDelay={}\", delay);\n            actionLog.stats.put(\"task_delay\", (double) delay.toNanos());\n            actionLog.context.put(\"thread\", List.of(Thread.currentThread().getName()));\n            return task.call();\n        } catch (Throwable e) {\n            logManager.logError(e);\n            throw new TaskException(Strings.format(\"task failed, action={}, id={}, error={}\", context.action, context.actionId, e.getMessage()), e);\n        } finally {\n            logManager.end(\"=== task execution end ===\");\n            context.runningTasks.remove(toString());\n            VirtualThread.COUNT.decrease();\n        }\n    }\n\n    String action() {\n        return rootAction == null ? \"task:\" + context.action : rootAction + \":task:\" + context.action;\n    }\n\n    // used to print all canceled tasks during shutdown, used by both ScheduledExecutorService and VirtualThreadExecutor\n    @Override\n    public String toString() {\n        return action() + \":\" + context.actionId;\n    }\n\n    record TaskContext(String actionId, String action, Instant startTime, long maxProcessTimeInNano, Set<String> runningTasks) {\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TaskException.java."}, {"role": "assistant", "content": "The source code of java class TaskException.java:\n```java\npackage core.framework.internal.async;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\npublic class TaskException extends Exception {\n    @Serial\n    private static final long serialVersionUID = -5143310703118077256L;\n\n    public TaskException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ThreadPools.java."}, {"role": "assistant", "content": "The source code of java class ThreadPools.java:\n```java\npackage core.framework.internal.async;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\n\n/**\n * @author neo\n */\npublic final class ThreadPools {\n    static {\n        // increase parallelism to allow more virtual thread unfriendly tasks to run\n        // refer to java.lang.VirtualThread.createDefaultScheduler\n        if (System.getProperty(\"jdk.virtualThreadScheduler.parallelism\") == null) {\n            int parallelism = Math.max(Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors() * 8);\n            System.setProperty(\"jdk.virtualThreadScheduler.parallelism\", String.valueOf(parallelism));\n        }\n    }\n\n    public static ExecutorService virtualThreadExecutor(String prefix) {\n        ThreadFactory factory = Thread.ofVirtual().name(prefix, 0).factory();\n        return Executors.newThreadPerTaskExecutor(factory);\n    }\n\n    public static ScheduledExecutorService singleThreadScheduler(String prefix) {\n        ThreadFactory factory = Thread.ofPlatform().name(prefix, 0).factory();\n        var scheduler = new ScheduledThreadPoolExecutor(1, factory);\n        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n        scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n        return scheduler;\n    }\n\n    // start all virtual thread creation from here to make sure static block above run first\n    public static Thread.Builder.OfVirtual virtualThreadBuilder(String prefix) {\n        return Thread.ofVirtual().name(prefix, 0);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class VirtualThread.java."}, {"role": "assistant", "content": "The source code of java class VirtualThread.java:\n```java\npackage core.framework.internal.async;\n\nimport core.framework.internal.stat.Counter;\n\npublic class VirtualThread {\n    public static final Counter COUNT = new Counter();\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanClassNameValidator.java."}, {"role": "assistant", "content": "The source code of java class BeanClassNameValidator.java:\n```java\npackage core.framework.internal.bean;\n\nimport core.framework.internal.reflect.Classes;\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class BeanClassNameValidator {\n    final Map<String, Class<?>> beanClasses = Maps.newHashMap();\n\n    public void validate(Class<?> beanClass) {\n        beanClasses.compute(Classes.className(beanClass), (key, previous) -> {\n            if (previous != null && !previous.equals(beanClass))\n                throw new Error(format(\"found bean class with duplicate name which can be confusing, please use different class name, previousClass={}, class={}\",\n                    previous.getCanonicalName(), beanClass.getCanonicalName()));\n            return beanClass;\n        });\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanClassValidator.java."}, {"role": "assistant", "content": "The source code of java class BeanClassValidator.java:\n```java\npackage core.framework.internal.bean;\n\nimport core.framework.internal.json.JSONClassValidator;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic final class BeanClassValidator { // bean is used by both web service request/response bean and kafka message class\n    public final BeanClassNameValidator beanClassNameValidator = new BeanClassNameValidator();\n    private final Set<Class<?>> validatedBeanClasses = new HashSet<>();\n\n    public void validate(Class<?> beanClass) {\n        boolean added = validatedBeanClasses.add(beanClass);\n        if (!added) return;\n\n        var validator = new JSONClassValidator(beanClass)/* {\n            @Override\n            public void visitClass(Class<?> objectClass, String path) {\n                super.visitClass(objectClass, path);\n                beanClassNameValidator.validate(objectClass);\n            }\n\n            @Override\n            public void visitEnum(Class<?> enumClass) {\n                super.visitEnum(enumClass);\n                beanClassNameValidator.validate(enumClass);\n            }\n        }*/;\n        validator.validate();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CacheClassValidator.java."}, {"role": "assistant", "content": "The source code of java class CacheClassValidator.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.internal.validate.ClassValidator;\n\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic final class CacheClassValidator {\n    private final ClassValidator validator;\n\n    public CacheClassValidator(Class<?> cacheClass) {\n        // cache class validator accepts all json types without @Property annotation checking\n        validator = new ClassValidator(cacheClass);\n        validator.allowedValueClasses = Set.of(String.class, Boolean.class,\n            Integer.class, Long.class, Double.class, BigDecimal.class,\n            LocalDate.class, LocalDateTime.class, ZonedDateTime.class, Instant.class, LocalTime.class);\n    }\n\n    public void validate() {\n        validator.validate();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CacheContext.java."}, {"role": "assistant", "content": "The source code of java class CacheContext.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.Validator;\n\n/**\n * @author neo\n */\npublic class CacheContext<T> {\n    final JSONReader<T> reader;\n    final JSONWriter<T> writer;\n    // only validate when retrieve cache from store, in case data in cache store is stale, e.g. the class structure is changed but still got old data from cache\n    // it's opposite as DB, which only validate on save\n    final Validator<T> validator;\n\n    CacheContext(Class<T> cacheClass) {\n        reader = JSONMapper.reader(cacheClass);\n        writer = JSONMapper.writer(cacheClass);\n        validator = Validator.of(cacheClass);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CacheImpl.java."}, {"role": "assistant", "content": "The source code of java class CacheImpl.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.cache.Cache;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.util.Maps;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\n\n/**\n * @author neo\n */\npublic class CacheImpl<T> implements Cache<T> {\n    public final String name;\n    public final Class<T> cacheClass;\n    public final Duration duration;\n\n    final CacheContext<T> context;\n    private final Logger logger = LoggerFactory.getLogger(CacheImpl.class);\n\n    public CacheStore cacheStore;\n\n    public CacheImpl(String name, Class<T> cacheClass, Duration duration) {\n        this.name = name;\n        this.cacheClass = cacheClass;\n        this.duration = duration;\n        context = new CacheContext<>(cacheClass);\n    }\n\n    @Override\n    public T get(String key, Function<String, T> loader) {\n        String cacheKey = cacheKey(key);\n        T cacheValue = cacheStore.get(cacheKey, context);\n        if (cacheValue != null) {\n            stat(\"cache_hits\", 1);\n            return cacheValue;\n        }\n\n        logger.debug(\"load value, key={}\", key);\n        T value = load(loader, key);\n        cacheStore.put(cacheKey, value, duration, context);\n        stat(\"cache_misses\", 1);\n        return value;\n    }\n\n    public Optional<T> get(String key) {\n        T result = cacheStore.get(cacheKey(key), context);\n        if (result == null) return Optional.empty();\n        return Optional.of(result);\n    }\n\n    @Override\n    public Map<String, T> getAll(Collection<String> keys, Function<String, T> loader) {\n        int size = keys.size();\n        int index = 0;\n        String[] cacheKeys = cacheKeys(keys);\n        Map<String, T> values = Maps.newHashMapWithExpectedSize(size);\n        List<CacheStore.Entry<T>> newValues = new ArrayList<>(size);\n        Map<String, T> cacheValues = cacheStore.getAll(cacheKeys, context);\n        stat(\"cache_hits\", cacheValues.size());\n        for (String key : keys) {\n            String cacheKey = cacheKeys[index];\n            T result = cacheValues.get(cacheKey);\n            if (result == null) {\n                logger.debug(\"load value, key={}\", key);\n                result = load(loader, key);\n                newValues.add(new CacheStore.Entry<>(cacheKey, result));\n            }\n            values.put(key, result);\n            index++;\n        }\n        if (!newValues.isEmpty()) {\n            cacheStore.putAll(newValues, duration, context);\n            stat(\"cache_misses\", newValues.size());\n        }\n        return values;\n    }\n\n    @Override\n    public void put(String key, T value) {\n        cacheStore.put(cacheKey(key), value, duration, context);\n    }\n\n    @Override\n    public void putAll(Map<String, T> values) {\n        List<CacheStore.Entry<T>> cacheValues = new ArrayList<>(values.size());\n        for (Map.Entry<String, T> entry : values.entrySet()) {\n            cacheValues.add(new CacheStore.Entry<>(cacheKey(entry.getKey()), entry.getValue()));\n        }\n        cacheStore.putAll(cacheValues, duration, context);\n    }\n\n    @Override\n    public void evict(String key) {\n        cacheStore.delete(cacheKey(key));\n    }\n\n    @Override\n    public void evictAll(Collection<String> keys) {\n        String[] cacheKeys = cacheKeys(keys);\n        cacheStore.delete(cacheKeys);\n    }\n\n    private String[] cacheKeys(Collection<String> keys) {\n        String[] cacheKeys = new String[keys.size()];\n        int index = 0;\n        for (String key : keys) {\n            cacheKeys[index] = cacheKey(key);\n            index++;\n        }\n        return cacheKeys;\n    }\n\n    private String cacheKey(String key) {\n        return name + \":\" + key;\n    }\n\n    private T load(Function<String, T> loader, String key) {\n        T value = loader.apply(key);\n        if (value == null) throw new Error(\"value must not be null, key=\" + key);\n        return value;\n    }\n\n    // set to actionLog directly to keep trace log concise\n    private void stat(String key, double value) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.stats.compute(key, (k, oldValue) -> (oldValue == null) ? value : oldValue + value);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CacheStore.java."}, {"role": "assistant", "content": "The source code of java class CacheStore.java:\n```java\npackage core.framework.internal.cache;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface CacheStore {   // all keys here are direct cacheKey, not the key passed to Cache<T>\n    <T> T get(String key, CacheContext<T> context);\n\n    <T> Map<String, T> getAll(String[] keys, CacheContext<T> context);\n\n    <T> void put(String key, T value, Duration expiration, CacheContext<T> context);\n\n    <T> void putAll(List<Entry<T>> values, Duration expiration, CacheContext<T> context);\n\n    boolean delete(String... keys);\n\n    record Entry<T>(String key, T value) {\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LocalCacheMetrics.java."}, {"role": "assistant", "content": "The source code of java class LocalCacheMetrics.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\n\n/**\n * @author neo\n */\npublic class LocalCacheMetrics implements Metrics {\n    private final LocalCacheStore cacheStore;\n\n    public LocalCacheMetrics(LocalCacheStore cacheStore) {\n        this.cacheStore = cacheStore;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        stats.put(\"cache_size\", cacheStore.caches.size());\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LocalCacheStore.java."}, {"role": "assistant", "content": "The source code of java class LocalCacheStore.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.util.Maps;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * @author neo\n */\npublic class LocalCacheStore implements CacheStore {\n    final Map<String, CacheItem<?>> caches = Maps.newConcurrentHashMap();\n    private final Logger logger = LoggerFactory.getLogger(LocalCacheStore.class);\n    public int maxSize = 10000;  // 10000 simple objects roughly takes 1M-10M heap + hashmap overhead\n\n    @Override\n    public <T> T get(String key, CacheContext<T> context) {\n        logger.debug(\"get, key={}\", key);\n        return get(key, System.currentTimeMillis());\n    }\n\n    private <T> T get(String key, long now) {\n        @SuppressWarnings(\"unchecked\")\n        CacheItem<T> item = (CacheItem<T>) caches.get(key);\n        if (item == null) return null;\n        if (item.expired(now)) {\n            caches.remove(key);\n            return null;\n        }\n        item.hits++;\n        return item.value;\n    }\n\n    @Override\n    public <T> Map<String, T> getAll(String[] keys, CacheContext<T> context) {\n        logger.debug(\"getAll, keys={}\", new ArrayLogParam(keys));\n        long now = System.currentTimeMillis();\n        Map<String, T> results = Maps.newHashMapWithExpectedSize(keys.length);\n        for (String key : keys) {\n            T value = get(key, now);\n            if (value != null) results.put(key, value);\n        }\n        return results;\n    }\n\n    @Override\n    public <T> void put(String key, T value, Duration expiration, CacheContext<T> context) {\n        logger.debug(\"put, key={}, expiration={}\", key, expiration);\n        long expirationTime = System.currentTimeMillis() + expiration.toMillis();\n        caches.put(key, new CacheItem<>(value, expirationTime));\n    }\n\n    @Override\n    public <T> void putAll(List<Entry<T>> values, Duration expiration, CacheContext<T> context) {\n        logger.debug(\"putAll, keys={}, expiration={}\", new ArrayLogParam(keys(values)), expiration);\n        long expirationTime = System.currentTimeMillis() + expiration.toMillis();\n        for (Entry<T> value : values) {\n            caches.put(value.key(), new CacheItem<>(value.value(), expirationTime));\n        }\n    }\n\n    private <T> String[] keys(List<Entry<T>> values) {\n        String[] keys = new String[values.size()];\n        int index = 0;\n        for (Entry<T> value : values) {\n            keys[index] = value.key();\n            index++;\n        }\n        return keys;\n    }\n\n    @Override\n    public boolean delete(String... keys) {\n        logger.debug(\"delete, keys={}\", new ArrayLogParam(keys));\n        boolean deleted = false;\n        for (String key : keys) {\n            CacheItem<?> previous = caches.remove(key);\n            if (!deleted && previous != null) deleted = true;\n        }\n        return deleted;\n    }\n\n    public void cleanup() {    // cleanup is only called by background thread with fixed delay, not need to synchronize\n        logger.info(\"clean up local cache store\");\n        long now = System.currentTimeMillis();\n        caches.values().removeIf(item -> item.expired(now));\n        int size = caches.size();\n        if (size > maxSize) {\n            logger.info(\"evict least frequently used cache items, currentSize={}, maxSize={}\", size, maxSize);\n            int evictSize = size - maxSize;\n            evictLeastFrequentlyUsedItems(evictSize);\n        }\n    }\n\n    // use LFU to trade off between simplicity and access efficiency,\n    // assume local cache is only used for rarely changed items, and tolerate stale data, or use message to notify updates\n    // cleanup is running in background thread, it maintains approximate maxSize loosely\n    private void evictLeastFrequentlyUsedItems(int evictSize) {\n        Map<Integer, Integer> sizes = new TreeMap<>();\n        for (CacheItem<?> item : caches.values()) {\n            int hits = item.hits;\n            int size = sizes.getOrDefault(hits, 0);\n            sizes.put(hits, size + 1);\n        }\n        int minHits = 0;\n        int currentEvictSize = 0;\n        for (Map.Entry<Integer, Integer> entry : sizes.entrySet()) {\n            currentEvictSize += entry.getValue();\n            if (currentEvictSize >= evictSize) {\n                minHits = entry.getKey();\n                break;\n            }\n        }\n        int targetHits = minHits;\n        caches.values().removeIf(item -> item.hits <= targetHits);\n    }\n\n    public void clear() {\n        caches.clear();\n    }\n\n    static class CacheItem<T> {\n        final T value;\n        final long expirationTime;\n        int hits;\n\n        CacheItem(T value, long expirationTime) {\n            this.value = value;\n            this.expirationTime = expirationTime;\n        }\n\n        boolean expired(long now) {\n            return now >= expirationTime;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisCacheStore.java."}, {"role": "assistant", "content": "The source code of java class RedisCacheStore.java:\n```java\npackage core.framework.internal.cache;\n\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.redis.RedisException;\nimport core.framework.internal.redis.RedisImpl;\nimport core.framework.internal.validate.Validator;\nimport core.framework.util.Maps;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic class RedisCacheStore implements CacheStore {\n    private final Logger logger = LoggerFactory.getLogger(RedisCacheStore.class);\n\n    private final RedisImpl redis;\n\n    public RedisCacheStore(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public <T> T get(String key, CacheContext<T> context) {\n        try {\n            byte[] value = redis.getBytes(key);\n            if (value == null) return null;\n            return deserialize(value, context.reader, context.validator);\n        } catch (UncheckedIOException | RedisException e) {\n            logger.warn(errorCode(\"CACHE_STORE_FAILED\"), \"failed to connect to redis, error={}\", e.getMessage(), e);\n            return null;\n        }\n    }\n\n    @Override\n    public <T> Map<String, T> getAll(String[] keys, CacheContext<T> context) {\n        try {\n            Map<String, byte[]> redisValues = redis.multiGetBytes(keys);\n            Map<String, T> values = Maps.newHashMapWithExpectedSize(redisValues.size());\n            for (Map.Entry<String, byte[]> entry : redisValues.entrySet()) {\n                T value = deserialize(entry.getValue(), context.reader, context.validator);\n                if (value != null) {\n                    values.put(entry.getKey(), value);\n                }\n            }\n            return values;\n        } catch (UncheckedIOException | RedisException e) {\n            logger.warn(errorCode(\"CACHE_STORE_FAILED\"), \"failed to connect to redis, error={}\", e.getMessage(), e);\n            return Map.of();\n        }\n    }\n\n    private <T> T deserialize(byte[] value, JSONReader<T> reader, Validator<T> validator) {\n        try {\n            T result = reader.fromJSON(value);\n            if (result == null) return null;\n\n            Map<String, String> errors = validator.errors(result, false);\n            if (errors != null) {\n                logger.warn(errorCode(\"INVALID_CACHE_DATA\"), \"failed to validate value from cache, will reload, errors={}\", errors);\n                return null;\n            }\n\n            return result;\n        } catch (IOException e) {\n            logger.warn(errorCode(\"INVALID_CACHE_DATA\"), \"failed to deserialize value from cache, will reload, error={}\", e.getMessage(), e);\n            return null;\n        }\n    }\n\n    @Override\n    public <T> void put(String key, T value, Duration expiration, CacheContext<T> context) {\n        try {\n            redis.set(key, context.writer.toJSON(value), expiration, false);\n        } catch (UncheckedIOException | RedisException e) {\n            logger.warn(errorCode(\"CACHE_STORE_FAILED\"), \"failed to connect to redis, error={}\", e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public <T> void putAll(List<Entry<T>> values, Duration expiration, CacheContext<T> context) {\n        Map<String, byte[]> cacheValues = Maps.newHashMapWithExpectedSize(values.size());\n        for (Entry<T> value : values) {\n            cacheValues.put(value.key(), context.writer.toJSON(value.value()));\n        }\n        try {\n            redis.multiSet(cacheValues, expiration);\n        } catch (UncheckedIOException | RedisException e) {\n            logger.warn(errorCode(\"CACHE_STORE_FAILED\"), \"failed to connect to redis, error={}\", e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean delete(String... keys) {\n        try {\n            long deletedKeys = redis.del(keys);\n            return deletedKeys > 0;\n        } catch (UncheckedIOException | RedisException e) {\n            logger.warn(errorCode(\"CACHE_STORE_FAILED\"), \"failed to connect to redis, error={}\", e.getMessage(), e);\n            return false;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class AzureAuthProvider.java."}, {"role": "assistant", "content": "The source code of java class AzureAuthProvider.java:\n```java\npackage core.framework.internal.db.cloud;\n\nimport core.framework.db.CloudAuthProvider;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\nimport core.framework.util.Files;\nimport core.framework.util.Strings;\n\nimport java.nio.file.Path;\nimport java.time.Duration;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * @author miller\n * This provider is designed for use in the AKS environment.\n */\npublic class AzureAuthProvider implements CloudAuthProvider {\n    private static final String AZURE_AUTHORITY_HOST = \"AZURE_AUTHORITY_HOST\";\n    private static final String AZURE_CLIENT_ID = \"AZURE_CLIENT_ID\";\n    private static final String AZURE_TENANT_ID = \"AZURE_TENANT_ID\";\n    private static final String AZURE_FEDERATED_TOKEN_FILE = \"AZURE_FEDERATED_TOKEN_FILE\";\n    //refers to com.azure.identity.extensions.implementation.token.AccessTokenResolverOptions\n    private static final Map<String, String> OSS_RDBMS_SCOPE_MAP = Map.of(\n        \"https://login.microsoftonline.com/\", \"https://ossrdbms-aad.database.windows.net/.default\",\n        \"https://login.chinacloudapi.cn/\", \"https://ossrdbms-aad.database.chinacloudapi.cn/.default\",\n        \"https://login.microsoftonline.de/\", \"https://ossrdbms-aad.database.cloudapi.de/.default\",\n        \"https://login.microsoftonline.us/\", \"https://ossrdbms-aad.database.usgovcloudapi.net/.default\");\n    private final HTTPClient httpClient = HTTPClient.builder()\n        .connectTimeout(Duration.ofMillis(500))\n        .timeout(Duration.ofSeconds(1))\n        .maxRetries(3)\n        .retryWaitTime(Duration.ofMillis(50))\n        .build();\n    private final String user;\n    String accessToken;\n    long expirationTime;\n\n    public AzureAuthProvider(String user) {\n        this.user = user;\n    }\n\n    @Override\n    public String user() {\n        return user;\n    }\n\n    @Override\n    public String accessToken() {\n        if (accessToken != null && System.currentTimeMillis() < expirationTime) {\n            return accessToken;\n        }\n\n        long now = System.currentTimeMillis();  // record current time, to make sure expire time is always earlier than metadata side\n        String tokenJSON = exchangeToken();\n        accessToken = parseAccessToken(tokenJSON);\n        // token will be refreshed 300s before expiration, and connected connection will not be invalidated\n        // set expirationTime after access token, to handle multi thread conditions\n        expirationTime = now + (parseExpirationTimeInSec(tokenJSON) - 300) * 1_000L;\n        return accessToken;\n    }\n\n    String exchangeToken() {\n        HTTPRequest httpRequest = exchangeRequest();\n        HTTPResponse response = httpClient.execute(httpRequest);\n        if (response.statusCode != 200) {\n            throw new Error(\"failed to exchange Azure accessToken, status=\" + response.statusCode + \", response=\" + response.text());\n        }\n        return response.text();\n    }\n\n    HTTPRequest exchangeRequest() {\n        String azureAuthorityHost = env(AZURE_AUTHORITY_HOST);\n        String azureClientId = env(AZURE_CLIENT_ID);\n        String azureTenantId = env(AZURE_TENANT_ID);\n        String azureAuthorityURL = Strings.format(\"{}{}/oauth2/v2.0/token\", azureAuthorityHost, azureTenantId);\n        String azureFederatedTokenFilePath = env(AZURE_FEDERATED_TOKEN_FILE);\n\n        String scope = OSS_RDBMS_SCOPE_MAP.get(azureAuthorityHost);\n        String federatedToken = azureFederatedToken(azureFederatedTokenFilePath);\n        Map<String, String> form = new LinkedHashMap<>();\n        form.put(\"client_assertion\", federatedToken);\n        form.put(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n        form.put(\"client_id\", azureClientId);\n        form.put(\"grant_type\", \"client_credentials\");\n        form.put(\"scope\", scope);\n\n        var request = new HTTPRequest(HTTPMethod.POST, azureAuthorityURL);\n        request.form(form);\n        return request;\n    }\n\n    private String parseAccessToken(String tokenJSON) {\n        int startIndex = tokenJSON.indexOf(\"\\\"access_token\\\":\\\"\") + 16;\n        int endIndex = tokenJSON.indexOf('\"', startIndex);\n        return tokenJSON.substring(startIndex, endIndex);\n    }\n\n    int parseExpirationTimeInSec(String tokenJSON) {\n        int startIndex = tokenJSON.indexOf(\"\\\"expires_in\\\":\") + 13;\n        int endIndex = tokenJSON.indexOf(',', startIndex);\n        return Integer.parseInt(tokenJSON.substring(startIndex, endIndex));\n    }\n\n    String env(String name) {\n        return System.getenv(name);\n    }\n\n    String azureFederatedToken(String azureFederatedTokenFilePath) {\n        return Files.text(Path.of(azureFederatedTokenFilePath));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class GCloudAuthProvider.java."}, {"role": "assistant", "content": "The source code of java class GCloudAuthProvider.java:\n```java\npackage core.framework.internal.db.cloud;\n\nimport core.framework.db.CloudAuthProvider;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class GCloudAuthProvider implements CloudAuthProvider {\n    // for timeout settings, refer to gcloud sdk com.google.auth.oauth2.ComputeEngineCredentials#runningOnComputeEngine\n    private final HTTPClient httpClient = HTTPClient.builder()\n        .connectTimeout(Duration.ofMillis(500))\n        .timeout(Duration.ofSeconds(1))\n        .maxRetries(3)\n        .retryWaitTime(Duration.ofMillis(50))\n        .build();\n\n    String user;    // iam user, won't change once pod is created\n    String accessToken;\n    long expirationTime;\n\n    @Override\n    public String user() {\n        // email won't change once pod created\n        if (user == null) {\n            user = parseUser(metadata(\"email\"));\n        }\n        return user;\n    }\n\n    @Override\n    public String accessToken() {\n        if (accessToken != null && System.currentTimeMillis() < expirationTime) {\n            return accessToken;\n        }\n\n        long now = System.currentTimeMillis();  // record current time, to make sure expire time is always earlier than metadata side\n        String tokenJSON = metadata(\"token\");\n        accessToken = parseAccessToken(tokenJSON);\n        // token will be refreshed 300s before expiration, and connected connection will not be invalidated\n        // set expirationTime after access token, to handle multi thread conditions\n        expirationTime = now + (parseExpirationTimeInSec(tokenJSON) - 300) * 1_000L;\n        return accessToken;\n    }\n\n    private String parseUser(String email) {\n        int index = email.indexOf('@');\n        return email.substring(0, index);\n    }\n\n    private String parseAccessToken(String tokenJSON) {\n        // use fastest way to parse to reduce overhead\n        // example value: {\"access_token\":\"ya29.c.b0AXv0zTNPzp_Hl__8DJzw1KHKq_B9vhP7eHbRz18ar38gl_hbPt5YugF_2P7WOaqXPIM9JkllokdupT3vs7-rCssMoK0x2eguM8KG_wuOcDCJkUHNcDxriip6hq2Ww8FvE_XIlHivxMO607P1wIHIyv0kOV0iorcJ-G-1oEO4Pa5Rq9x1lQNXY2O3CoEjA4d8tFB0LPfkvfOOQpqpdwbww5LFiAFWy6OJzZphxxXisXaS_AIurTNduA0BQJViwprb8awSrUDbB3owais8wadFrZ-GV09aMqHvaORsydFb12T5TRhpzdqFSRr__H734VBH_if3XzbW5o2oqPUP9Ye3ynE9WYZqhBDHV7y0nqeNm5c2qD7KmRizO2ZdMzPxRVmQeafyOJEwb67H3vX3Cc6Wmz7Orujcas8R9UNNXDEPVy0GJdIlIXXFZJvwq0h95g.........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\",\"expires_in\":3561,\"token_type\":\"Bearer\"}\n        int index = tokenJSON.indexOf('\"', 17);\n        return tokenJSON.substring(17, index);\n    }\n\n    int parseExpirationTimeInSec(String tokenJSON) {\n        int startIndex = tokenJSON.indexOf(\"\\\"expires_in\\\":\") + 13;\n        int endIndex = tokenJSON.indexOf(',', startIndex);\n        return Integer.parseInt(tokenJSON.substring(startIndex, endIndex));\n    }\n\n    String metadata(String attribute) {\n        // 169.254.169.254 is metadata.google.internal, use ip to save dns query\n        var request = new HTTPRequest(HTTPMethod.GET, \"http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/\" + attribute);\n        request.headers.put(\"Metadata-Flavor\", \"Google\");\n        HTTPResponse response = httpClient.execute(request);\n        if (response.statusCode != 200) throw new Error(\"failed to fetch gcloud iam metadata, status=\" + response.statusCode);\n        return response.text();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Connections.java."}, {"role": "assistant", "content": "The source code of java class Connections.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.internal.resource.PoolItem;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.SQLTimeoutException;\n\n/**\n * @author neo\n */\nfinal class Connections {\n    static void checkConnectionState(PoolItem<Connection> connection, SQLException e) {\n        String state = e.getSQLState();\n        // for state starts with \"08\"\n        // refer to com.mysql.jdbc.integration.c3p0.MysqlConnectionTester, and standard sql state list:\n        // http://dev.mysql.com/doc/connector-j/en/connector-j-reference-error-sqlstates.html\n        //\n        // for state: S1009\n        // refer to com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException() and com.mysql.cj.exceptions.MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT\n        // MySQL jdbc connector will translate \"statement is closed\" and other errors to \"S1009\"\n        if (state != null && (state.startsWith(\"08\") || \"S1009\".equals(state))) {\n            connection.broken = true;\n        }\n\n        // if query timeout, com.mysql.cj.CancelQueryTaskImpl sends \"KILL QUERY\" to mysql server in cancel task thread\n        // and as result, in current thread it triggers com.mysql.cj.jdbc.ConnectionImpl.handleCleanup with whyCleanedUp = com.mysql.cj.exceptions.CJCommunicationsException: Communications link failure, The last packet successfully received from the server was x milliseconds ago.\n        // so for query timeout, the connection needs to be marked as broken and close,\n        // otherwise when other thread retrieves this connection, will encounter \"statement is already closed\" exception\n        if (e instanceof SQLTimeoutException) {\n            connection.broken = true;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DatabaseClassValidator.java."}, {"role": "assistant", "content": "The source code of java class DatabaseClassValidator.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.NotNull;\nimport core.framework.db.Column;\nimport core.framework.db.DBEnumValue;\nimport core.framework.db.PrimaryKey;\nimport core.framework.db.Table;\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.validate.ClassValidatorSupport;\nimport core.framework.util.Sets;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\nimport java.util.List;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nfinal class DatabaseClassValidator {\n    private final ClassValidatorSupport support = new ClassValidatorSupport();\n    private final Class<?> entityClass;\n    private final Set<Class<?>> allowedValueClasses = Set.of(String.class, Boolean.class,\n        Integer.class, Long.class, Double.class, BigDecimal.class,\n        LocalDate.class, LocalDateTime.class, ZonedDateTime.class);\n    private final Set<String> columns = Sets.newHashSet();\n    private final boolean isView;\n    private boolean foundPrimaryKey;\n    private boolean foundAutoIncrementalPrimaryKey;\n    private Object defaultObject;\n\n    DatabaseClassValidator(Class<?> entityClass, boolean isView) {\n        this.entityClass = entityClass;\n        this.isView = isView;\n    }\n\n    void validate() {\n        support.validateClass(entityClass);\n\n        boolean foundTable = entityClass.isAnnotationPresent(Table.class);\n        if (isView && foundTable)\n            throw new Error(\"db view class must not have @Table, class=\" + entityClass.getCanonicalName());\n        else if (!isView && !foundTable)\n            throw new Error(\"db entity class must have @Table, class=\" + entityClass.getCanonicalName());\n\n        initializeDefaultObject();\n\n        validateFields();\n\n        if (!isView && !foundPrimaryKey)\n            throw new Error(\"db entity class must have @PrimaryKey, class=\" + entityClass.getCanonicalName());\n    }\n\n    private void initializeDefaultObject() {\n        try {\n            defaultObject = entityClass.getDeclaredConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new Error(e);\n        }\n    }\n\n    private void validateFields() {\n        for (Field field : support.declaredFields(entityClass)) {\n            Column column = validateAnnotations(field);\n            if (column.json()) {\n                validateJSONField(field);\n            } else {\n                validateValueField(field);\n            }\n\n            try {\n                // entity constructed by \"new\" with default value will break partialUpdate accidentally, due to fields are not null will be updated to db\n                if (!isView && field.get(defaultObject) != null)\n                    throw new Error(\"db entity field must not have default value, field=\" + Fields.path(field));\n            } catch (ReflectiveOperationException e) {\n                throw new Error(e);\n            }\n        }\n    }\n\n    private Column validateAnnotations(Field field) {\n        Column column = field.getDeclaredAnnotation(Column.class);\n        if (column == null) throw new Error(\"db entity field must have @Column, field=\" + Fields.path(field));\n\n        Property property = field.getDeclaredAnnotation(Property.class);\n        if (property != null)\n            throw new Error(\"db entity field must not have json annotation, please separate view and entity, field=\" + Fields.path(field));\n\n        boolean added = columns.add(column.name());\n        if (!added) {\n            throw new Error(format(\"found duplicate column, field={}, column={}\", Fields.path(field), column.name()));\n        }\n\n        PrimaryKey primaryKey = field.getDeclaredAnnotation(PrimaryKey.class);\n        if (primaryKey != null) {\n            if (isView) throw new Error(\"db view field must not have @PrimaryKey, field=\" + Fields.path(field));\n            foundPrimaryKey = true;\n            validatePrimaryKey(primaryKey, field.getType(), field);\n        }\n\n        return column;\n    }\n\n    private void validateJSONField(Field field) {\n        Type fieldType = field.getGenericType();\n        if (GenericTypes.isList(fieldType)) {\n            if (!GenericTypes.isGenericList(fieldType))\n                throw new Error(\"db json list field must be List<T> and T must be enum or value class, field=\" + Fields.path(field));\n\n            Class<?> valueClass = GenericTypes.listValueClass(fieldType);\n            if (valueClass.isEnum()) {\n                JSONClassValidator.validateEnum(valueClass);\n                return;\n            }\n            // use db.allowedValues not json.allowedValues to keep json db field consistent with db entity\n            if (allowedValueClasses.contains(valueClass)) return;\n\n            throw new Error(\"db json list field must be List<T> and T must be enum or value class, field=\" + Fields.path(field));\n        } else {\n            Class<?> fieldClass = GenericTypes.rawClass(fieldType);\n            if (fieldClass.isEnum() || allowedValueClasses.contains(fieldClass))\n                throw new Error(\"db json field must be bean or list, field=\" + Fields.path(field));\n            new JSONClassValidator(fieldClass).validate();\n        }\n    }\n\n    private void validateValueField(Field field) {\n        Class<?> fieldClass = field.getType();\n\n        if (fieldClass.isEnum()) {  // enum is allowed value type\n            validateEnum(fieldClass);\n            return;\n        }\n\n        if (allowedValueClasses.contains(fieldClass)) return;\n\n        if (fieldClass.getPackageName().startsWith(\"java\"))\n            throw new Error(format(\"field class is not supported, class={}, field={}\", fieldClass.getCanonicalName(), Fields.path(field)));\n\n        throw new Error(format(\"child object is not allowed, do you mean @Column(json=true), class={}, field={}\", fieldClass.getCanonicalName(), Fields.path(field)));\n    }\n\n    private void validatePrimaryKey(PrimaryKey primaryKey, Class<?> fieldClass, Field field) {\n        if (primaryKey.autoIncrement()) {\n            if (foundAutoIncrementalPrimaryKey) throw new Error(\"db entity must not have more than one auto incremental primary key, field=\" + Fields.path(field));\n            foundAutoIncrementalPrimaryKey = true;\n        }\n\n        if (foundAutoIncrementalPrimaryKey && !(Integer.class.equals(fieldClass) || Long.class.equals(fieldClass))) {\n            throw new Error(\"auto increment or sequence primary key must be Integer or Long, field=\" + Fields.path(field));\n        }\n\n        NotNull notNull = field.getDeclaredAnnotation(NotNull.class);\n        if (notNull != null)\n            throw new Error(\"db @PrimaryKey field must not have @NotNull, field=\" + Fields.path(field));\n    }\n\n    private void validateEnum(Class<?> enumClass) {\n        Set<String> enumValues = Sets.newHashSet();\n        List<Field> fields = Classes.enumConstantFields(enumClass);\n        for (Field field : fields) {\n            DBEnumValue enumValue = field.getDeclaredAnnotation(DBEnumValue.class);\n            if (enumValue == null)\n                throw new Error(\"db enum must have @DBEnumValue, field=\" + Fields.path(field));\n\n            boolean added = enumValues.add(enumValue.value());\n            if (!added)\n                throw new Error(format(\"found duplicate db enum value, field={}, value={}\", Fields.path(field), enumValue.value()));\n\n            Property property = field.getDeclaredAnnotation(Property.class);\n            if (property != null)\n                throw new Error(\"db enum must not have json annotation, please separate view and entity, field=\" + Fields.path(field));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DatabaseImpl.java."}, {"role": "assistant", "content": "The source code of java class DatabaseImpl.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.CloudAuthProvider;\nimport core.framework.db.Database;\nimport core.framework.db.IsolationLevel;\nimport core.framework.db.Repository;\nimport core.framework.db.Transaction;\nimport core.framework.db.UncheckedSQLException;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.resource.Pool;\nimport core.framework.util.ASCII;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.time.Duration;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\n/**\n * @author neo\n */\npublic final class DatabaseImpl implements Database {\n    static {\n        // disable unnecessary mysql connection cleanup thread to reduce overhead, refer to PropertyDefinitions.SYSP_disableAbandonedConnectionCleanup\n        System.setProperty(\"com.mysql.cj.disableAbandonedConnectionCleanup\", \"true\");\n    }\n\n    public final Pool<Connection> pool;\n    public final DatabaseOperation operation;\n    private final Logger logger = LoggerFactory.getLogger(DatabaseImpl.class);\n    private final Map<Class<?>, RowMapper<?>> rowMappers = new HashMap<>(32);\n\n    public String user;\n    public String password;\n    public CloudAuthProvider authProvider;\n    public IsolationLevel isolationLevel;\n\n    private String url;\n    private Properties driverProperties;\n    private Duration timeout;\n    private Driver driver;\n    private Dialect dialect;\n\n    public DatabaseImpl(String name) {\n        initializeRowMappers();\n\n        pool = new Pool<>(this::createConnection, name);\n        pool.size(5, 50);    // default optimization for AWS medium/large instances\n        pool.maxIdleTime = Duration.ofHours(2);  // make sure db server does not kill connection shorter than this, e.g. MySQL default wait_timeout is 8 hours\n        pool.validator(connection -> connection.isValid(1), Duration.ofSeconds(30));\n\n        operation = new DatabaseOperation(pool);\n        timeout(Duration.ofSeconds(15));\n    }\n\n    private void initializeRowMappers() {\n        rowMappers.put(String.class, new RowMapper.StringRowMapper());\n        rowMappers.put(Integer.class, new RowMapper.IntegerRowMapper());\n        rowMappers.put(Long.class, new RowMapper.LongRowMapper());\n        rowMappers.put(Double.class, new RowMapper.DoubleRowMapper());\n        rowMappers.put(BigDecimal.class, new RowMapper.BigDecimalRowMapper());\n        rowMappers.put(Boolean.class, new RowMapper.BooleanRowMapper());\n        rowMappers.put(LocalDateTime.class, new RowMapper.LocalDateTimeRowMapper());\n        rowMappers.put(LocalDate.class, new RowMapper.LocalDateRowMapper());\n        rowMappers.put(ZonedDateTime.class, new RowMapper.ZonedDateTimeRowMapper());\n    }\n\n    private Connection createConnection() {\n        if (url == null) throw new Error(\"url must not be null\");\n        Properties driverProperties = this.driverProperties;\n        if (driverProperties == null) {\n            driverProperties = driverProperties(url);\n            this.driverProperties = driverProperties;\n        }\n        if (authProvider != null) {\n            // properties are thread safe, it's ok to set user/password with multiple threads\n            driverProperties.setProperty(\"user\", authProvider.user());\n            driverProperties.setProperty(\"password\", authProvider.accessToken());\n        }\n        Connection connection = null;\n        try {\n            connection = driver.connect(url, driverProperties);\n            if (isolationLevel != null) connection.setTransactionIsolation(isolationLevel.level);\n            return connection;\n        } catch (SQLException e) {\n            Pool.closeQuietly(connection);\n            throw new UncheckedSQLException(e);\n        }\n    }\n\n    Properties driverProperties(String url) {\n        var properties = new Properties();\n        if (authProvider == null && user != null) properties.setProperty(\"user\", user);\n        if (authProvider == null && password != null) properties.setProperty(\"password\", password);\n        if (url.startsWith(\"jdbc:mysql:\")) {\n            // refer to https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html\n            properties.setProperty(\"connectTimeout\", String.valueOf(timeout.toMillis()));\n            // add 10s for socket timeout which is read timeout, as all queries have queryTimeout, MySQL will send \"KILL QUERY\" command to MySQL server\n            // otherwise we will see socket timeout exception (com.mysql.cj.exceptions.StatementIsClosedException: No operations allowed after statement closed)\n            // refer to com.mysql.cj.CancelQueryTaskImpl\n            properties.setProperty(\"socketTimeout\", String.valueOf(timeout.toMillis() + 10_000));\n            // refer to https://dev.mysql.com/doc/c-api/8.0/en/mysql-affected-rows.html\n            // refer to https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-connection.html#cj-conn-prop_useAffectedRows\n            // Don't set the CLIENT_FOUND_ROWS flag when connecting to the server (not JDBC-compliant, will break most applications that rely on \"found\" rows vs. \"affected rows\" for DML statements),\n            // but does cause \"correct\" update counts from \"INSERT ... ON DUPLICATE KEY UPDATE\" statements to be returned by the server.\n            properties.setProperty(\"useAffectedRows\", \"true\");\n            // refer to com.mysql.cj.protocol.a.NativeProtocol.configureTimeZone,\n            // force to UTC, generally on cloud it defaults to UTC, this setting is to make local match cloud\n            properties.setProperty(\"connectionTimeZone\", \"UTC\");\n            properties.setProperty(\"rewriteBatchedStatements\", \"true\");\n            properties.setProperty(\"logger\", \"Slf4JLogger\");\n            properties.setProperty(\"cachePrepStmts\", \"true\");\n\n            int index = url.indexOf('?');\n            // mysql with ssl has overhead, usually we ensure security on arch level, e.g. gcloud sql proxy or firewall rule\n            // with gcloud/azure iam / clear_text_password plugin, ssl is required\n            // refer to https://cloud.google.com/sql/docs/mysql/authentication\n            if (authProvider != null) {\n                properties.setProperty(\"sslMode\", \"PREFERRED\");\n                properties.setProperty(CloudAuthProvider.Provider.CLOUD_AUTH, \"true\");\n            } else if (index == -1 || url.indexOf(\"sslMode=\", index + 1) == -1) {\n                properties.setProperty(\"sslMode\", \"DISABLED\");\n            }\n            // refer to https://dev.mysql.com/doc/connector-j/en/connector-j-reference-charsets.html\n            if (index == -1 || url.indexOf(\"characterEncoding=\", index + 1) == -1)\n                properties.setProperty(\"characterEncoding\", \"utf-8\");\n        } else if (url.startsWith(\"jdbc:postgresql:\")) {\n            // refer to org.postgresql.PGProperty\n            properties.setProperty(\"connectTimeout\", String.valueOf(timeout.toSeconds()));\n            properties.setProperty(\"socketTimeout\", String.valueOf(timeout.toSeconds()));\n            properties.setProperty(\"reWriteBatchedInserts\", \"true\");\n        }\n        return properties;\n    }\n\n    public void close() {\n        logger.info(\"close database client, url={}\", url);\n        pool.close();\n    }\n\n    public void timeout(Duration timeout) {\n        this.timeout = timeout;\n        operation.queryTimeoutInSeconds = (int) timeout.getSeconds();\n        pool.checkoutTimeout(timeout);\n    }\n\n    public void url(String url) {\n        if (!url.startsWith(\"jdbc:\")) throw new Error(\"jdbc url must start with \\\"jdbc:\\\", url=\" + url);\n        logger.info(\"set database connection url, url={}\", url);\n        this.url = url;\n        driver = driver(url);\n    }\n\n    private Driver driver(String url) {\n        if (url.startsWith(\"jdbc:mysql:\")) {\n            dialect = Dialect.MYSQL;\n            return createDriver(\"com.mysql.cj.jdbc.Driver\");\n        } else if (url.startsWith(\"jdbc:postgresql:\")) {\n            dialect = Dialect.POSTGRESQL;\n            return createDriver(\"org.postgresql.Driver\");\n        } else if (url.startsWith(\"jdbc:hsqldb:\")) {\n            dialect = Dialect.MYSQL;    // unit test use mysql dialect\n            return createDriver(\"org.hsqldb.jdbc.JDBCDriver\");\n        } else {\n            throw new Error(\"not supported database, url=\" + url);\n        }\n    }\n\n    private Driver createDriver(String driverClass) {\n        try {\n            return Class.forName(driverClass).asSubclass(Driver.class).getDeclaredConstructor().newInstance();\n        } catch (ReflectiveOperationException e) {\n            throw new Error(e);\n        }\n    }\n\n    public <T> void view(Class<T> viewClass) {\n        var watch = new StopWatch();\n        try {\n            new DatabaseClassValidator(viewClass, true).validate();\n            registerViewClass(viewClass);\n        } finally {\n            logger.info(\"register db view, viewClass={}, elapsed={}\", viewClass.getCanonicalName(), watch.elapsed());\n        }\n    }\n\n    public <T> Repository<T> repository(Class<T> entityClass) {\n        var watch = new StopWatch();\n        try {\n            new DatabaseClassValidator(entityClass, false).validate();\n            registerViewClass(entityClass);\n            return new RepositoryImpl<>(this, entityClass, dialect);\n        } finally {\n            logger.info(\"register db entity, entityClass={}, elapsed={}\", entityClass.getCanonicalName(), watch.elapsed());\n        }\n    }\n\n    @Override\n    public Transaction beginTransaction() {\n        return operation.transactionManager.beginTransaction();\n    }\n\n    @Override\n    public <T> List<T> select(String sql, Class<T> viewClass, Object... params) {\n        var watch = new StopWatch();\n        validateSQL(sql);\n        int returnedRows = 0;\n        try {\n            List<T> results = operation.select(sql, rowMapper(viewClass), params);\n            returnedRows = results.size();\n            return results;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"select, sql={}, params={}, returnedRows={}, elapsed={}\", sql, new SQLParams(operation.enumMapper, params), returnedRows, elapsed);\n            track(elapsed, returnedRows, 0, 1);   // check after sql debug log, to make log easier to read\n        }\n    }\n\n    @Override\n    public <T> Optional<T> selectOne(String sql, Class<T> viewClass, Object... params) {\n        var watch = new StopWatch();\n        validateSQL(sql);\n        int returnedRows = 0;\n        try {\n            Optional<T> result = operation.selectOne(sql, rowMapper(viewClass), params);\n            if (result.isPresent()) returnedRows = 1;\n            return result;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"selectOne, sql={}, params={}, returnedRows={}, elapsed={}\", sql, new SQLParams(operation.enumMapper, params), returnedRows, elapsed);\n            track(elapsed, returnedRows, 0, 1);\n        }\n    }\n\n    @Override\n    public int execute(String sql, Object... params) {\n        var watch = new StopWatch();\n        validateSQL(sql);\n        int affectedRows = 0;\n        try {\n            affectedRows = operation.update(sql, params);\n            return affectedRows;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"execute, sql={}, params={}, affectedRows={}, elapsed={}\", sql, new SQLParams(operation.enumMapper, params), affectedRows, elapsed);\n            track(elapsed, 0, affectedRows, 1);\n        }\n    }\n\n    @Override\n    public int[] batchExecute(String sql, List<Object[]> params) {\n        var watch = new StopWatch();\n        validateSQL(sql);\n        if (params.isEmpty()) throw new Error(\"params must not be empty\");\n        int affectedRows = 0;\n        try {\n            int[] results = operation.batchUpdate(sql, params);\n            for (int result : results) {\n                // with batchInsert, mysql returns -2 if insert succeeds, for batch only\n                // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executeBatchedInserts\n                if (result == Statement.SUCCESS_NO_INFO) affectedRows++;\n                if (result > 0) affectedRows += result;\n            }\n            return results;\n        } finally {\n            long elapsed = watch.elapsed();\n            int size = params.size();\n            logger.debug(\"batchExecute, sql={}, params={}, size={}, affectedRows={}, elapsed={}\", sql, new SQLBatchParams(operation.enumMapper, params), size, affectedRows, elapsed);\n            track(elapsed, 0, affectedRows, size);\n        }\n    }\n\n    private <T> RowMapper<T> rowMapper(Class<T> viewClass) {\n        @SuppressWarnings(\"unchecked\")\n        RowMapper<T> mapper = (RowMapper<T>) rowMappers.get(viewClass);\n        if (mapper == null)\n            throw new Error(\"view class is not registered, please register in module by db().view(), viewClass=\" + viewClass.getCanonicalName());\n        return mapper;\n    }\n\n    private <T> void registerViewClass(Class<T> viewClass) {\n        if (rowMappers.containsKey(viewClass)) {\n            throw new Error(\"found duplicate view class, viewClass=\" + viewClass.getCanonicalName());\n        }\n        RowMapper<T> mapper = new RowMapperBuilder<>(viewClass, operation.enumMapper).build();\n        rowMappers.put(viewClass, mapper);\n    }\n\n    void track(long elapsed, int readRows, int writeRows, int queries) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog != null) {\n            actionLog.stats.compute(\"db_queries\", (k, oldValue) -> (oldValue == null) ? queries : oldValue + queries);\n            actionLog.track(\"db\", elapsed, readRows, writeRows);\n        }\n    }\n\n    void validateSQL(String sql) {\n        // validate asterisk\n        // execute() could have select part, e.g. insert into select\n        int index = sql.indexOf('*');\n        while (index > -1) {   // check whether it's wildcard or multiply operator\n            int length = sql.length();\n            char ch = 0;\n            index++;\n            for (; index < length; index++) {\n                ch = sql.charAt(index);\n                if (ch != ' ') break;   // seek to next non-whitespace\n            }\n            if (ch == ','\n                || index == length  // sql ends with *\n                || index + 4 <= length && ASCII.toUpperCase(ch) == 'F' && \"FROM\".equals(ASCII.toUpperCase(sql.substring(index, index + 4))))\n                throw new Error(\"sql must not contain wildcard(*), please only select columns needed, sql=\" + sql);\n            index = sql.indexOf('*', index + 1);\n        }\n\n        // validate string value\n        // by this way, it also disallows functions with string values, e.g. IFNULL(column, 'value'), but it usually can be prevented by different design,\n        // and we prefer to simplify db usage if possible, and shift complexity to application layer\n        if (sql.indexOf('\\'') != -1)\n            throw new Error(\"sql must not contain single quote('), please use prepared statement and question mark(?), sql=\" + sql);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DatabaseOperation.java."}, {"role": "assistant", "content": "The source code of java class DatabaseOperation.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.QueryDiagnostic;\nimport core.framework.db.UncheckedSQLException;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.resource.Pool;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.util.Lists;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\n\nimport static core.framework.log.Markers.errorCode;\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class DatabaseOperation {\n    private final Logger logger = LoggerFactory.getLogger(DatabaseOperation.class);\n\n    public final TransactionManager transactionManager;\n    final EnumDBMapper enumMapper = new EnumDBMapper();\n    int queryTimeoutInSeconds;\n\n    DatabaseOperation(Pool<Connection> pool) {\n        transactionManager = new TransactionManager(pool);\n    }\n\n    // as for the boilerplate code, it is mainly for performance and maintainability purpose, as framework code it's more important to keep straightforward than DRY\n    // it's harder to trace and read if creating a lot of lambda or template pattern, also impact the mem usage and GC\n    int update(String sql, Object... params) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = connection.resource.prepareStatement(sql)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            setParams(statement, params);\n            int result = statement.executeUpdate();\n            logSlowQuery(statement);\n            return result;\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    // mysql jdbc driver will adjust batch size according to max_allowed_packet param, check this value by \"SHOW VARIABLES LIKE '%max_allowed_packet'\"\n    // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executeBatchedInserts, com.mysql.cj.AbstractPreparedQuery.computeBatchSize\n    int[] batchUpdate(String sql, List<Object[]> params) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = connection.resource.prepareStatement(sql)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            for (Object[] batchParams : params) {\n                setParams(statement, batchParams);\n                statement.addBatch();\n            }\n            int[] results = statement.executeBatch();\n            logSlowQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    <T> Optional<T> selectOne(String sql, RowMapper<T> mapper, Object... params) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = connection.resource.prepareStatement(sql)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            setParams(statement, params);\n            return fetchOne(statement, mapper);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    <T> List<T> select(String sql, RowMapper<T> mapper, Object... params) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = connection.resource.prepareStatement(sql)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            setParams(statement, params);\n            return fetch(statement, mapper);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    OptionalLong insert(String sql, Object[] params, String generatedColumn) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = insertStatement(connection.resource, sql, generatedColumn)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            setParams(statement, params);\n            statement.executeUpdate();\n            if (generatedColumn == null) return OptionalLong.empty();\n            return fetchGeneratedKey(statement);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    Optional<long[]> batchInsert(String sql, List<Object[]> params, String generatedColumn) {\n        PoolItem<Connection> connection = transactionManager.getConnection();\n        try (PreparedStatement statement = insertStatement(connection.resource, sql, generatedColumn)) {\n            statement.setQueryTimeout(queryTimeoutInSeconds);\n            for (Object[] batchParams : params) {\n                setParams(statement, batchParams);\n                statement.addBatch();\n            }\n            statement.executeBatch();\n            if (generatedColumn != null) {\n                long[] results = fetchGeneratedKeys(statement, params.size());\n                return Optional.of(results);\n            }\n            return Optional.empty();\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            transactionManager.returnConnection(connection);\n        }\n    }\n\n    private PreparedStatement insertStatement(Connection connection, String sql, String generatedColumn) throws SQLException {\n        if (generatedColumn == null) return connection.prepareStatement(sql);\n        return connection.prepareStatement(sql, new String[]{generatedColumn});\n    }\n\n    private <T> Optional<T> fetchOne(PreparedStatement statement, RowMapper<T> mapper) throws SQLException {\n        try (ResultSet resultSet = statement.executeQuery()) {\n            logSlowQuery(statement);\n\n            T result = null;\n            if (resultSet.next()) {\n                result = mapper.map(new ResultSetWrapper(resultSet));\n                if (resultSet.next())\n                    throw new Error(\"more than one row returned\");\n            }\n            return Optional.ofNullable(result);\n        }\n    }\n\n    private <T> List<T> fetch(PreparedStatement statement, RowMapper<T> mapper) throws SQLException {\n        try (ResultSet resultSet = statement.executeQuery()) {\n            logSlowQuery(statement);\n\n            var wrapper = new ResultSetWrapper(resultSet);\n            List<T> results = Lists.newArrayList();\n            while (resultSet.next()) {\n                T result = mapper.map(wrapper);\n                results.add(result);\n            }\n            return results;\n        }\n    }\n\n    // the LAST_INSERT_ID() function of mysql returns BIGINT, so here it uses Long\n    // http://dev.mysql.com/doc/refman/5.7/en/information-functions.html\n    private OptionalLong fetchGeneratedKey(PreparedStatement statement) throws SQLException {\n        try (ResultSet keys = statement.getGeneratedKeys()) {\n            if (keys != null && keys.next()) {\n                return OptionalLong.of(keys.getLong(1));\n            }\n        }\n        return OptionalLong.empty();\n    }\n\n    private long[] fetchGeneratedKeys(PreparedStatement statement, int size) throws SQLException {\n        long[] results = new long[size];\n        int index = 0;\n        try (ResultSet keys = statement.getGeneratedKeys()) {\n            if (keys != null) {\n                while (keys.next()) {\n                    results[index++] = keys.getLong(1);\n                }\n            }\n        }\n        return results;\n    }\n\n    private void setParams(PreparedStatement statement, Object... params) throws SQLException {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                setParam(statement, i + 1, params[i]);\n            }\n        }\n    }\n\n    private void setParam(PreparedStatement statement, int index, Object param) throws SQLException {\n        switch (param) {\n            case String value -> statement.setString(index, value);\n            case Enum<?> value -> statement.setString(index, enumMapper.getDBValue(value));\n            case LocalDate value -> statement.setObject(index, value, Types.DATE);\n            case LocalDateTime value -> statement.setObject(index, value, Types.TIMESTAMP);\n            case ZonedDateTime value -> {\n                // https://dev.mysql.com/doc/refman/8.0/en/datetime.html,\n                // TIMESTAMP has a range of '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.\n                // for timestamp column type, there is year 2038 issue\n                // for datetime column type, jdbc will save UTC values\n\n                // with insert ignore, out of range timestamp param will be converted to \"0000-00-00 00:00:00\" into db, and will trigger \"Zero date value prohibited\" error on read\n                // refer to https://dev.mysql.com/doc/refman/8.0/en/insert.html\n                // Data conversions that would trigger errors abort the statement if IGNORE is not specified. With IGNORE, invalid values are adjusted to the closest values and inserted; warnings are produced but the statement does not abort.\n\n                // here only to check > 0, make trade off between validating TIMESTAMP column type and keeping compatible with DATETIME column type\n                // most likely the values we deal with from external systems are lesser (e.g. nodejs default year is 1900, it converts 0 into 1900/01/01 00:00:00)\n                // if it passes timestamp after 2038-01-19 03:14:07 (Instant.ofEpochSecond(Integer.MAX_VALUE)), it will still trigger this issue on MySQL\n                // so on application level, if you can not ensure the range of input value, write its own utils to check\n                Instant instant = value.toInstant();\n                if (instant.getEpochSecond() <= 0) throw new Error(\"timestamp must be after 1970-01-01 00:00:00, value=\" + param);\n                statement.setObject(index, instant, Types.TIMESTAMP);\n            }\n            case Boolean value -> statement.setBoolean(index, value);\n            case Integer value -> statement.setInt(index, value);\n            case Long value -> statement.setLong(index, value);\n            case Double value -> statement.setDouble(index, value);\n            case BigDecimal value -> statement.setBigDecimal(index, value);\n            case null -> statement.setNull(index, Types.NULL);   // both mysql/hsql driver are not using sqlType param\n            default -> throw new Error(format(\"unsupported param type, type={}, value={}\", param.getClass().getCanonicalName(), param));\n        }\n    }\n\n    void logSlowQuery(PreparedStatement statement) {\n        if (statement instanceof QueryDiagnostic diagnostic) {\n            boolean noIndexUsed = diagnostic.noIndexUsed();\n            boolean badIndexUsed = diagnostic.noGoodIndexUsed();\n            if (!noIndexUsed && !badIndexUsed) return;\n\n            ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n            boolean warning = actionLog == null || !actionLog.warningContext.suppressSlowSQLWarning;\n            String message = noIndexUsed ? \"no index used\" : \"bad index used\";\n            String sqlValue = diagnostic.sql();\n            if (warning) {\n                logger.warn(errorCode(\"SLOW_SQL\"), \"{}, sql={}\", message, sqlValue);\n            } else {\n                logger.debug(\"{}, sql={}\", message, sqlValue);\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DBEnumMapper.java."}, {"role": "assistant", "content": "The source code of java class DBEnumMapper.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.DBEnumValue;\nimport core.framework.internal.reflect.Enums;\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nfinal class DBEnumMapper<T extends Enum<T>> {\n    private final Class<T> enumClass;\n    private final Map<String, T> mappings;\n\n    DBEnumMapper(Class<T> enumClass) {\n        this.enumClass = enumClass;\n        mappings = mappings(enumClass);\n    }\n\n    // used by generated code, must be public\n    public T getEnum(String value) {\n        if (value == null) return null;\n        T enumValue = mappings.get(value);\n        if (enumValue == null)\n            throw new Error(format(\"can not parse value to enum, enumClass={}, value={}\", enumClass.getCanonicalName(), value));\n        return enumValue;\n    }\n\n    private Map<String, T> mappings(Class<T> enumClass) {\n        T[] constants = enumClass.getEnumConstants();\n        Map<String, T> mapping = Maps.newHashMapWithExpectedSize(constants.length);\n        for (T constant : constants) {\n            String dbValue = Enums.constantAnnotation(constant, DBEnumValue.class).value();\n            mapping.put(dbValue, constant);\n        }\n        return mapping;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DeleteQueryBuilder.java."}, {"role": "assistant", "content": "The source code of java class DeleteQueryBuilder.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Column;\nimport core.framework.db.PrimaryKey;\nimport core.framework.db.Table;\nimport core.framework.internal.reflect.Classes;\n\nimport java.lang.reflect.Field;\n\n/**\n * @author neo\n */\nfinal class DeleteQueryBuilder {\n    static String build(Class<?> entityClass) {\n        Table table = entityClass.getDeclaredAnnotation(Table.class);\n        var builder = new StringBuilder(\"DELETE FROM \").append(table.name()).append(\" WHERE \");\n        int index = 0;\n        for (Field field : Classes.instanceFields(entityClass)) {\n            if (field.isAnnotationPresent(PrimaryKey.class)) {\n                Column column = field.getDeclaredAnnotation(Column.class);\n                if (index > 0) builder.append(\" AND \");\n                builder.append(column.name()).append(\" = ?\");\n                index++;\n            }\n        }\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Dialect.java."}, {"role": "assistant", "content": "The source code of java class Dialect.java:\n```java\npackage core.framework.internal.db;\n\n/**\n * @author neo\n */\npublic enum Dialect {\n    MYSQL, POSTGRESQL\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class EnumDBMapper.java."}, {"role": "assistant", "content": "The source code of java class EnumDBMapper.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.DBEnumValue;\nimport core.framework.internal.reflect.Enums;\nimport core.framework.util.Maps;\n\nimport java.util.EnumMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\nfinal class EnumDBMapper {\n    private final Map<Class<? extends Enum<?>>, Map<Enum<?>, String>> mappings = Maps.newHashMap();\n\n    <T extends Enum<?>> void registerEnumClass(Class<T> enumClass) {\n        if (!mappings.containsKey(enumClass)) {\n            @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n            Map<Enum<?>, String> mapping = new EnumMap(enumClass);\n            T[] constants = enumClass.getEnumConstants();\n            for (T constant : constants) {\n                String dbValue = Enums.constantAnnotation(constant, DBEnumValue.class).value();\n                mapping.put(constant, dbValue);\n            }\n            mappings.put(enumClass, mapping);\n        }\n    }\n\n    String getDBValue(Enum<?> value) {\n        Class<? extends Enum<?>> enumClass = value.getDeclaringClass();\n        Map<Enum<?>, String> mapping = mappings.get(enumClass);\n        if (mapping == null)\n            throw new Error(\"enum class is not registered, register in module by db().view() or db().repository(), enumClass=\" + enumClass.getCanonicalName());\n        return mapping.get(value);  // this won't return null since all fields of enum are registered\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InsertQuery.java."}, {"role": "assistant", "content": "The source code of java class InsertQuery.java:\n```java\npackage core.framework.internal.db;\n\n/**\n * @author neo\n */\nfinal class InsertQuery<T> {\n    final String insertSQL;\n    final String insertIgnoreSQL;\n    final String upsertSQL;\n    final String generatedColumn;\n    private final InsertQueryParamBuilder<T> paramBuilder;\n\n    InsertQuery(String insertSQL, String insertIgnoreSQL, String upsertSQL, String generatedColumn, InsertQueryParamBuilder<T> paramBuilder) {\n        this.insertSQL = insertSQL;\n        this.insertIgnoreSQL = insertIgnoreSQL;\n        this.upsertSQL = upsertSQL;\n        this.generatedColumn = generatedColumn;\n        this.paramBuilder = paramBuilder;\n    }\n\n    Object[] params(T entity) {\n        return paramBuilder.params(entity);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InsertQueryBuilder.java."}, {"role": "assistant", "content": "The source code of java class InsertQueryBuilder.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Column;\nimport core.framework.db.PrimaryKey;\nimport core.framework.db.Table;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.util.Lists;\nimport core.framework.util.Strings;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static core.framework.internal.asm.Literal.type;\n\n/**\n * @author neo\n */\nclass InsertQueryBuilder<T> {\n    final DynamicInstanceBuilder<InsertQueryParamBuilder<T>> builder;\n    private final Class<T> entityClass;\n    private final Dialect dialect;\n    private final List<String> primaryKeyFieldNames = Lists.newArrayList();\n\n    private String generatedColumn;\n    private List<ParamField> paramFields;\n    private String insertSQL;\n    private String insertIgnoreSQL;\n    private String upsertSQL;\n\n    InsertQueryBuilder(Class<T> entityClass, Dialect dialect) {\n        this.entityClass = entityClass;\n        this.dialect = dialect;\n        builder = new DynamicInstanceBuilder<>(InsertQueryParamBuilder.class, entityClass.getSimpleName());\n    }\n\n    InsertQuery<T> build() {\n        buildSQL();\n        builder.addMethod(applyMethod());\n        InsertQueryParamBuilder<T> paramBuilder = builder.build();\n        return new InsertQuery<>(insertSQL, insertIgnoreSQL, upsertSQL, generatedColumn, paramBuilder);\n    }\n\n    private void buildSQL() {\n        List<Field> fields = Classes.instanceFields(entityClass);\n        int size = fields.size();\n        paramFields = new ArrayList<>(size);\n        List<String> columns = new ArrayList<>(size);\n        List<String> params = new ArrayList<>(size);\n        List<String> updates = new ArrayList<>(size);\n        for (Field field : fields) {\n            PrimaryKey primaryKey = field.getDeclaredAnnotation(PrimaryKey.class);\n            Column column = field.getDeclaredAnnotation(Column.class);\n            String columnName = column.name();\n            if (primaryKey != null) {\n                if (primaryKey.autoIncrement()) {\n                    generatedColumn = columnName;\n                    continue;\n                }\n                primaryKeyFieldNames.add(field.getName());    // pk fields is only needed for assigned id\n            } else {\n                if (dialect == Dialect.MYSQL) {\n                    // VALUES(column) syntax is deprecated since MySQL 8.0.20, this is to keep compatible with old MySQL (gcloud still has 8.0.18)\n                    // will update to new syntax in future\n                    updates.add(Strings.format(\"{} = VALUES({})\", columnName, columnName));\n                } else if (dialect == Dialect.POSTGRESQL) {\n                    updates.add(Strings.format(\"{} = EXCLUDED.{}\", columnName, columnName));\n                }\n            }\n            paramFields.add(new ParamField(field.getName(), column.json()));\n            columns.add(columnName);\n            params.add(\"?\");\n        }\n\n        var builder = new CodeBuilder()\n            .append(\"INSERT INTO {} (\", entityClass.getDeclaredAnnotation(Table.class).name())\n            .appendCommaSeparatedValues(columns)\n            .append(\") VALUES (\")\n            .appendCommaSeparatedValues(params)\n            .append(')');\n        insertSQL = builder.build();\n\n        if (generatedColumn != null) return;  // auto-increment entity doesn't need insert ignore and upsert, refer to core.framework.internal.db.RepositoryImpl.insertIgnore\n\n        if (dialect == Dialect.MYSQL) {\n            insertIgnoreSQL = new StringBuilder(insertSQL).insert(6, \" IGNORE\").toString();\n        } else if (dialect == Dialect.POSTGRESQL) {\n            insertIgnoreSQL = insertSQL + \" ON CONFLICT DO NOTHING\";\n        }\n\n        if (dialect == Dialect.MYSQL) {\n            builder.append(\" ON DUPLICATE KEY UPDATE \")\n                .appendCommaSeparatedValues(updates);\n        } else {\n            builder.append(\" ON CONFLICT (\").appendCommaSeparatedValues(primaryKeyFieldNames).append(\") DO UPDATE SET \")\n                .appendCommaSeparatedValues(updates);\n        }\n        upsertSQL = builder.build();\n    }\n\n    private String applyMethod() {\n        var builder = new CodeBuilder();\n\n        String entityClassLiteral = type(entityClass);\n        builder.append(\"public Object[] params(Object value) {\\n\")\n            .indent(1).append(\"{} entity = ({}) value;\\n\", entityClassLiteral, entityClassLiteral);\n\n        if (generatedColumn == null) {\n            for (String name : primaryKeyFieldNames) {\n                builder.indent(1).append(\"if (entity.{} == null) throw new Error(\\\"primary key must not be null, field={}\\\");\\n\", name, name);\n            }\n        }\n\n        builder.indent(1).append(\"Object[] params = new Object[{}];\\n\", paramFields.size());\n        int index = 0;\n        for (ParamField field : paramFields) {\n            if (field.json) {\n                builder.indent(1).append(\"params[{}] = {}.toJSON(entity.{});\\n\", index, type(JSONHelper.class), field.name);\n            } else {\n                builder.indent(1).append(\"params[{}] = entity.{};\\n\", index, field.name);\n            }\n            index++;\n        }\n\n        builder.indent(1).append(\"return params;\\n\")\n            .append(\"}\");\n\n        return builder.build();\n    }\n\n    private record ParamField(String name, boolean json) {\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InsertQueryParamBuilder.java."}, {"role": "assistant", "content": "The source code of java class InsertQueryParamBuilder.java:\n```java\npackage core.framework.internal.db;\n\n/**\n * @author neo\n */\ninterface InsertQueryParamBuilder<T> {\n    Object[] params(T entity);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class JSONHelper.java."}, {"role": "assistant", "content": "The source code of java class JSONHelper.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.json.JSON;\n\nimport java.lang.reflect.Type;\n\n/**\n * @author neo\n */\npublic final class JSONHelper {\n    // support null, doesn't need validator, validation will be done by EntityClass validator (validator checks all cascaded fields)\n\n    // used by core.framework.internal.db.InsertQueryBuilder\n    // used by core.framework.internal.db.UpdateQueryBuilder\n    public static String toJSON(Object bean) {\n        if (bean == null) return null;\n        return JSON.toJSON(bean);\n    }\n\n    // used by core.framework.internal.db.RowMapperBuilder\n    public static Object fromJSON(String json, Type type) {\n        if (json == null) return null;\n        return JSON.fromJSON(type, json);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryImpl.java."}, {"role": "assistant", "content": "The source code of java class QueryImpl.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Query;\nimport core.framework.util.Lists;\nimport core.framework.util.Strings;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic class QueryImpl<T> implements Query<T> {\n    private final DatabaseImpl database;\n    private final Class<T> entityClass;\n    private final SelectQuery<T> selectQuery;\n    private final StringBuilder whereClause = new StringBuilder();\n    private final List<Object> params = Lists.newArrayList();\n    private String groupBy;\n    private String sort;\n    private Integer skip;\n    private Integer limit;\n\n    QueryImpl(DatabaseImpl database, Class<T> entityClass, SelectQuery<T> selectQuery) {\n        this.database = database;\n        this.entityClass = entityClass;\n        this.selectQuery = selectQuery;\n    }\n\n    @Override\n    public void where(String condition, Object... params) {\n        if (Strings.isBlank(condition)) throw new Error(\"condition must not be blank\");\n        if (whereClause.length() > 0) whereClause.append(\" AND \");\n        if (condition.contains(\" OR \") || condition.contains(\" or \")) { // fastest way to only cover common cases, ignore Or or oR\n            whereClause.append('(').append(condition).append(')');\n        } else {\n            whereClause.append(condition);\n        }\n        Collections.addAll(this.params, params);\n    }\n\n    @Override\n    public void orderBy(String sort) {\n        this.sort = sort;\n    }\n\n    @Override\n    public void groupBy(String groupBy) {\n        this.groupBy = groupBy;\n    }\n\n    @Override\n    public void skip(Integer skip) {\n        this.skip = skip;\n    }\n\n    @Override\n    public void limit(Integer limit) {\n        if (limit != null && limit <= 0) throw new Error(\"limit must be greater than 0, limit=\" + limit);\n        this.limit = limit;\n    }\n\n    @Override\n    public List<T> fetch() {\n        if (groupBy != null) throw new Error(\"fetch must not be used with groupBy, groupBy=\" + groupBy);\n        String sql = selectQuery.fetchSQL(whereClause, sort, skip, limit);\n        Object[] params = selectQuery.params(this.params, skip, limit);\n        return database.select(sql, entityClass, params);\n    }\n\n    @Override\n    public Optional<T> fetchOne() {\n        if (groupBy != null) throw new Error(\"fetch must not be used with groupBy, groupBy=\" + groupBy);\n        String sql = selectQuery.fetchSQL(whereClause, sort, skip, limit);\n        Object[] params = selectQuery.params(this.params, skip, limit);\n        return database.selectOne(sql, entityClass, params);\n    }\n\n    @Override\n    public <P> List<P> project(String projection, Class<P> viewClass) {\n        String sql = selectQuery.sql(projection, whereClause, groupBy, sort, skip, limit);\n        Object[] params = selectQuery.params(this.params, skip, limit);\n        return database.select(sql, viewClass, params);\n    }\n\n    @Override\n    public <P> Optional<P> projectOne(String projection, Class<P> viewClass) {\n        String sql = selectQuery.sql(projection, whereClause, groupBy, sort, skip, limit);\n        Object[] params = selectQuery.params(this.params, skip, limit);\n        return database.selectOne(sql, viewClass, params);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RepositoryImpl.java."}, {"role": "assistant", "content": "The source code of java class RepositoryImpl.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Query;\nimport core.framework.db.Repository;\nimport core.framework.internal.validate.Validator;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class RepositoryImpl<T> implements Repository<T> {\n    private final Logger logger = LoggerFactory.getLogger(RepositoryImpl.class);\n    private final DatabaseImpl database;\n    private final Validator<T> validator;\n    private final SelectQuery<T> selectQuery;\n    private final InsertQuery<T> insertQuery;\n    private final UpdateQuery<T> updateQuery;\n    private final String deleteSQL;\n    private final Class<T> entityClass;\n\n    RepositoryImpl(DatabaseImpl database, Class<T> entityClass, Dialect dialect) {\n        this.database = database;\n        validator = Validator.of(entityClass);\n        insertQuery = new InsertQueryBuilder<>(entityClass, dialect).build();\n        selectQuery = new SelectQuery<>(entityClass, dialect);\n        updateQuery = new UpdateQueryBuilder<>(entityClass).build();\n        deleteSQL = DeleteQueryBuilder.build(entityClass);\n        this.entityClass = entityClass;\n    }\n\n    @Override\n    public Query<T> select() {\n        return new QueryImpl<>(database, entityClass, selectQuery);\n    }\n\n    @Override\n    public Optional<T> get(Object... primaryKeys) {\n        if (primaryKeys.length != selectQuery.primaryKeyColumns)\n            throw new Error(Strings.format(\"the length of primary keys does not match columns, primaryKeys={}, columns={}\", selectQuery.primaryKeyColumns, primaryKeys.length));\n        return database.selectOne(selectQuery.getSQL, entityClass, primaryKeys);\n    }\n\n    @Override\n    public OptionalLong insert(T entity) {\n        var watch = new StopWatch();\n        validator.validate(entity, false);\n        String sql = insertQuery.insertSQL;\n        Object[] params = insertQuery.params(entity);\n        try {\n            return database.operation.insert(sql, params, insertQuery.generatedColumn);\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"insert, sql={}, params={}, elapsed={}\", sql, new SQLParams(database.operation.enumMapper, params), elapsed);\n            database.track(elapsed, 0, 1, 1);\n        }\n    }\n\n    @Override\n    public boolean insertIgnore(T entity) {\n        var watch = new StopWatch();\n        if (insertQuery.generatedColumn != null) throw new Error(\"entity must not have auto increment primary key, entityClass=\" + entityClass.getCanonicalName());\n        validator.validate(entity, false);\n        int insertedRows = 0;\n        String sql = insertQuery.insertIgnoreSQL;\n        Object[] params = insertQuery.params(entity);\n        try {\n            insertedRows = database.operation.update(sql, params);\n            return insertedRows == 1;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"insertIgnore, sql={}, params={}, inserted={}, elapsed={}\", sql, new SQLParams(database.operation.enumMapper, params), insertedRows == 1, elapsed);\n            database.track(elapsed, 0, insertedRows, 1);\n        }\n    }\n\n    @Override\n    public boolean upsert(T entity) {\n        var watch = new StopWatch();\n        if (insertQuery.generatedColumn != null) throw new Error(\"entity must not have auto increment primary key, entityClass=\" + entityClass.getCanonicalName());\n        validator.validate(entity, false);\n        int affectedRows = 0;\n        String sql = insertQuery.upsertSQL;\n        Object[] params = insertQuery.params(entity);\n        try {\n            affectedRows = database.operation.update(sql, params);\n            // refer to https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\n            // With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row, 2 if an existing row is updated, and 0 if an existing row is set to its current values.\n            return affectedRows == 1;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"upsert, sql={}, params={}, inserted={}, elapsed={}\", sql, new SQLParams(database.operation.enumMapper, params), affectedRows == 1, elapsed);\n            database.track(elapsed, 0, affectedRows == 0 ? 0 : 1, 1);\n        }\n    }\n\n    @Override\n    public boolean update(T entity) {\n        // return true if any column changed, false if no column changed or id not found\n        return update(entity, false, null, null);\n    }\n\n    private boolean update(T entity, boolean partial, String where, Object[] params) {\n        var watch = new StopWatch();\n        validator.validate(entity, partial);\n        UpdateQuery.Statement query = updateQuery.update(entity, partial, where, params);\n        int updatedRows = 0;\n        try {\n            updatedRows = database.operation.update(query.sql, query.params);\n            // refer to https://dev.mysql.com/doc/c-api/8.0/en/mysql-affected-rows.html\n            // if all columns updated to its current values, the affectedRows will be 0\n            return updatedRows == 1;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"update, sql={}, params={}, updatedRows={}, elapsed={}\", query.sql, new SQLParams(database.operation.enumMapper, query.params), updatedRows, elapsed);\n            database.track(elapsed, 0, updatedRows, 1);\n        }\n    }\n\n    @Override\n    public boolean partialUpdate(T entity) {\n        return update(entity, true, null, null);\n    }\n\n    @Override\n    public boolean partialUpdate(T entity, String where, Object... params) {\n        return update(entity, true, where, params);\n    }\n\n    @Override\n    public boolean delete(Object... primaryKeys) {\n        var watch = new StopWatch();\n        if (primaryKeys.length != selectQuery.primaryKeyColumns) {\n            throw new Error(Strings.format(\"the length of primary keys must match columns, primaryKeys={}, columns={}\", primaryKeys.length, selectQuery.primaryKeyColumns));\n        }\n        int affectedRows = 0;\n        try {\n            affectedRows = database.operation.update(deleteSQL, primaryKeys);\n            if (affectedRows != 1) logger.warn(errorCode(\"UNEXPECTED_UPDATE_RESULT\"), \"row is not deleted, result={}\", affectedRows);\n            return affectedRows == 1;\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"delete, sql={}, params={}, elapsed={}\", deleteSQL, new SQLParams(database.operation.enumMapper, primaryKeys), elapsed);\n            database.track(elapsed, 0, affectedRows, 1);\n        }\n    }\n\n    @Override\n    public Optional<long[]> batchInsert(List<T> entities) {\n        var watch = new StopWatch();\n        if (entities.isEmpty()) throw new Error(\"entities must not be empty\");\n        String sql = insertQuery.insertSQL;\n        List<Object[]> params = new ArrayList<>(entities.size());\n        for (T entity : entities) {\n            validator.validate(entity, false);\n            params.add(insertQuery.params(entity));\n        }\n        try {\n            return database.operation.batchInsert(sql, params, insertQuery.generatedColumn);\n        } finally {\n            long elapsed = watch.elapsed();\n            int size = entities.size();\n            logger.debug(\"batchInsert, sql={}, params={}, size={}, elapsed={}\", sql, new SQLBatchParams(database.operation.enumMapper, params), size, elapsed);\n            database.track(elapsed, 0, size, size);\n        }\n    }\n\n    @Override\n    public boolean batchInsertIgnore(List<T> entities) {\n        var watch = new StopWatch();\n        if (entities.isEmpty()) throw new Error(\"entities must not be empty\");\n        if (insertQuery.generatedColumn != null) throw new Error(\"entity must not have auto increment primary key, entityClass=\" + entityClass.getCanonicalName());\n        String sql = insertQuery.insertIgnoreSQL;\n        List<Object[]> params = new ArrayList<>(entities.size());\n        for (T entity : entities) {\n            validator.validate(entity, false);\n            params.add(insertQuery.params(entity));\n        }\n        boolean inserted = false;   // any row inserted\n        try {\n            int[] affectedRows = database.operation.batchUpdate(sql, params);\n            inserted = batchUpdated(affectedRows);\n            return inserted;\n        } finally {\n            long elapsed = watch.elapsed();\n            int size = entities.size();\n            logger.debug(\"batchInsertIgnore, sql={}, params={}, size={}, inserted={}, elapsed={}\", sql, new SQLBatchParams(database.operation.enumMapper, params), size, inserted, elapsed);\n            database.track(elapsed, 0, inserted ? size : 0, size);\n        }\n    }\n\n    @Override\n    public boolean batchUpsert(List<T> entities) {\n        var watch = new StopWatch();\n        if (entities.isEmpty()) throw new Error(\"entities must not be empty\");\n        if (insertQuery.generatedColumn != null) throw new Error(\"entity must not have auto increment primary key, entityClass=\" + entityClass.getCanonicalName());\n        String sql = insertQuery.upsertSQL;\n        List<Object[]> params = new ArrayList<>(entities.size());\n        for (T entity : entities) {\n            validator.validate(entity, false);\n            params.add(insertQuery.params(entity));\n        }\n        boolean updated = false;\n        try {\n            int[] affectedRows = database.operation.batchUpdate(sql, params);\n            updated = batchUpdated(affectedRows);\n            return updated;\n        } finally {\n            long elapsed = watch.elapsed();\n            int size = entities.size();\n            logger.debug(\"batchUpsert, sql={}, params={}, size={}, updated={}, elapsed={}\", sql, new SQLBatchParams(database.operation.enumMapper, params), size, updated, elapsed);\n            database.track(elapsed, 0, updated ? size : 0, size);\n        }\n    }\n\n    private boolean batchUpdated(int[] affectedRows) {\n        // refer to com.mysql.cj.jdbc.ClientPreparedStatement.executeBatchWithMultiValuesClause Line 612\n        // only need to check first value\n        // HSQL actually returns accurate affected rows for batch, so also check if > 0 to make unit test correct\n        for (int affectedRow : affectedRows) {\n            if (affectedRow == Statement.SUCCESS_NO_INFO) return true;\n            if (affectedRow > 0) return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean batchDelete(List<?> primaryKeys) {\n        var watch = new StopWatch();\n        if (primaryKeys.isEmpty()) throw new Error(\"primaryKeys must not be empty\");\n        List<Object[]> params = batchDeleteParams(primaryKeys);\n        int deletedRows = 0;\n        try {\n            int[] affectedRows = database.operation.batchUpdate(deleteSQL, params);\n            deletedRows = Arrays.stream(affectedRows).sum();\n            if (deletedRows != primaryKeys.size()) logger.warn(errorCode(\"UNEXPECTED_UPDATE_RESULT\"), \"some rows are not deleted, results={}\", Arrays.toString(affectedRows));\n            return deletedRows > 0;\n        } finally {\n            long elapsed = watch.elapsed();\n            int size = primaryKeys.size();\n            logger.debug(\"batchDelete, sql={}, params={}, size={}, elapsed={}\", deleteSQL, new SQLBatchParams(database.operation.enumMapper, params), size, elapsed);\n            database.track(elapsed, 0, deletedRows, size);\n        }\n    }\n\n    List<Object[]> batchDeleteParams(List<?> primaryKeys) {\n        List<Object[]> params = new ArrayList<>(primaryKeys.size());\n        for (Object primaryKey : primaryKeys) {\n            if (primaryKey instanceof final Object[] keys) {\n                if (selectQuery.primaryKeyColumns != keys.length)\n                    throw new Error(Strings.format(\"the length of primary keys must match columns, primaryKeys={}, columns={}\", keys.length, selectQuery.primaryKeyColumns));\n                params.add(keys);\n            } else {\n                if (selectQuery.primaryKeyColumns != 1)\n                    throw new Error(Strings.format(\"the length of primary keys must match columns, primaryKeys={}, columns={}\", 1, selectQuery.primaryKeyColumns));\n                params.add(new Object[]{primaryKey});\n            }\n        }\n        return params;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResultSetWrapper.java."}, {"role": "assistant", "content": "The source code of java class ResultSetWrapper.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.UncheckedSQLException;\nimport core.framework.util.ASCII;\nimport core.framework.util.Maps;\n\nimport java.math.BigDecimal;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.Map;\n\n/**\n * @author neo\n */\nfinal class ResultSetWrapper {\n    private final ResultSet resultSet;\n\n    // JDBC ResultSet doesn't support to ignore non-existed column, this to build index\n    private final Map<String, Integer> columnIndex;\n\n    ResultSetWrapper(ResultSet resultSet) {\n        this.resultSet = resultSet;\n        try {\n            columnIndex = columnIndex();\n        } catch (SQLException e) {\n            throw new UncheckedSQLException(e);\n        }\n    }\n\n    private Integer index(String column) {\n        return columnIndex.get(ASCII.toLowerCase(column));\n    }\n\n    // different db are using various of rules to return column name/label, some of reserved case, some does not\n    // here we have to make name/column case insensitive for view mapping\n    // http://hsqldb.org/doc/guide/databaseobjects-chapt.html#dbc_collations\n    private Map<String, Integer> columnIndex() throws SQLException {\n        ResultSetMetaData meta = resultSet.getMetaData();\n        int count = meta.getColumnCount();\n        Map<String, Integer> index = Maps.newHashMapWithExpectedSize(count);\n        for (int i = 1; i < count + 1; i++) {\n            String column = meta.getColumnLabel(i);\n            index.put(ASCII.toLowerCase(column), i);\n        }\n        return index;\n    }\n\n    int columnCount() {\n        return columnIndex.size();\n    }\n\n    Integer getInt(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getInt(index);\n    }\n\n    Integer getInt(int index) throws SQLException {\n        return resultSet.getObject(index, Integer.class);\n    }\n\n    Boolean getBoolean(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getBoolean(index);\n    }\n\n    Boolean getBoolean(int index) throws SQLException {\n        return resultSet.getObject(index, Boolean.class);\n    }\n\n    Long getLong(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getLong(index);\n    }\n\n    Long getLong(int index) throws SQLException {\n        return resultSet.getObject(index, Long.class);\n    }\n\n    Double getDouble(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getDouble(index);\n    }\n\n    Double getDouble(int index) throws SQLException {\n        return resultSet.getObject(index, Double.class);\n    }\n\n    String getString(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getString(index);\n    }\n\n    String getString(int index) throws SQLException {\n        return resultSet.getString(index);\n    }\n\n    BigDecimal getBigDecimal(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getBigDecimal(index);\n    }\n\n    BigDecimal getBigDecimal(int index) throws SQLException {\n        return resultSet.getBigDecimal(index);\n    }\n\n    LocalDateTime getLocalDateTime(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getLocalDateTime(index);\n    }\n\n    LocalDateTime getLocalDateTime(int index) throws SQLException {\n        return resultSet.getObject(index, LocalDateTime.class);\n    }\n\n    LocalDate getLocalDate(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getLocalDate(index);\n    }\n\n    LocalDate getLocalDate(int index) throws SQLException {\n        return resultSet.getObject(index, LocalDate.class);\n    }\n\n    ZonedDateTime getZonedDateTime(String column) throws SQLException {\n        Integer index = index(column);\n        if (index == null) return null;\n        return getZonedDateTime(index);\n    }\n\n    ZonedDateTime getZonedDateTime(int index) throws SQLException {\n        // in mysql driver, getObject(type) is faster than getTimestamp/getDate due to \"synchronized calendar\"\n        // hsql doesn't support ZonedDateTime, use OffsetDateTime for both mysql and hsql\n        OffsetDateTime time = resultSet.getObject(index, OffsetDateTime.class);\n        if (time == null) return null;\n        return time.atZoneSameInstant(ZoneId.systemDefault());\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RowMapper.java."}, {"role": "assistant", "content": "The source code of java class RowMapper.java:\n```java\npackage core.framework.internal.db;\n\nimport java.math.BigDecimal;\nimport java.sql.SQLException;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\n@FunctionalInterface\ninterface RowMapper<T> {\n    static void checkColumnCount(ResultSetWrapper resultSet) {\n        int count = resultSet.columnCount();\n        if (count > 1) throw new Error(\"returned column count must be one, count=\" + count);\n    }\n\n    T map(ResultSetWrapper resultSet) throws SQLException;\n\n    class StringRowMapper implements RowMapper<String> {\n        @Override\n        public String map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getString(1);\n        }\n    }\n\n    class IntegerRowMapper implements RowMapper<Integer> {\n        @Override\n        public Integer map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getInt(1);\n        }\n    }\n\n    class LongRowMapper implements RowMapper<Long> {\n        @Override\n        public Long map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getLong(1);\n        }\n    }\n\n    class DoubleRowMapper implements RowMapper<Double> {\n        @Override\n        public Double map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getDouble(1);\n        }\n    }\n\n    class BigDecimalRowMapper implements RowMapper<BigDecimal> {\n        @Override\n        public BigDecimal map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getBigDecimal(1);\n        }\n    }\n\n    class LocalDateTimeRowMapper implements RowMapper<LocalDateTime> {\n        @Override\n        public LocalDateTime map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getLocalDateTime(1);\n        }\n    }\n\n    class LocalDateRowMapper implements RowMapper<LocalDate> {\n        @Override\n        public LocalDate map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getLocalDate(1);\n        }\n    }\n\n    class ZonedDateTimeRowMapper implements RowMapper<ZonedDateTime> {\n        @Override\n        public ZonedDateTime map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getZonedDateTime(1);\n        }\n    }\n\n    class BooleanRowMapper implements RowMapper<Boolean> {\n        @Override\n        public Boolean map(ResultSetWrapper resultSet) throws SQLException {\n            checkColumnCount(resultSet);\n            return resultSet.getBoolean(1);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RowMapperBuilder.java."}, {"role": "assistant", "content": "The source code of java class RowMapperBuilder.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Column;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.internal.asm.Literal.variable;\n\n/**\n * @author neo\n */\nfinal class RowMapperBuilder<T> {\n    final DynamicInstanceBuilder<RowMapper<T>> builder;\n    private final Class<T> entityClass;\n    private final EnumDBMapper enumDBMapper;\n\n    RowMapperBuilder(Class<T> entityClass, EnumDBMapper enumDBMapper) {\n        this.entityClass = entityClass;\n        this.enumDBMapper = enumDBMapper;\n        builder = new DynamicInstanceBuilder<>(RowMapper.class, entityClass.getSimpleName());\n    }\n\n    RowMapper<T> build() {\n        builder.addMethod(mapMethod());\n        return builder.build();\n    }\n\n    private String mapMethod() {\n        var builder = new CodeBuilder().append(\"public Object map({} resultSet) {\\n\", type(ResultSetWrapper.class));\n        String entityClassLiteral = type(entityClass);\n        builder.indent(1).append(\"{} entity = new {}();\\n\", entityClassLiteral, entityClassLiteral);\n\n        for (Field field : Classes.instanceFields(entityClass)) {\n            String fieldName = field.getName();\n            Class<?> fieldClass = field.getType();\n            Column column = field.getDeclaredAnnotation(Column.class);\n            String columnName = column.name();\n\n            if (Integer.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getInt(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (String.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getString(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (Boolean.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getBoolean(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (Long.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getLong(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (LocalDateTime.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getLocalDateTime(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (LocalDate.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getLocalDate(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (ZonedDateTime.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getZonedDateTime(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (fieldClass.isEnum()) {\n                registerEnumClass(fieldClass);\n                this.builder.addField(\"private final {} {}Mappings = new {}({});\", type(DBEnumMapper.class), fieldName, type(DBEnumMapper.class), variable(fieldClass));\n                builder.indent(1).append(\"entity.{} = ({}){}Mappings.getEnum(resultSet.getString(\\\"{}\\\"));\\n\", fieldName, type(fieldClass), fieldName, columnName);\n            } else if (Double.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getDouble(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (BigDecimal.class.equals(fieldClass)) {\n                builder.indent(1).append(\"entity.{} = resultSet.getBigDecimal(\\\"{}\\\");\\n\", fieldName, columnName);\n            } else if (column.json()) {\n                builder.indent(1).append(\"entity.{} = ({}) {}.fromJSON(resultSet.getString(\\\"{}\\\"), {});\\n\", fieldName, type(field.getType()), type(JSONHelper.class), columnName, variable(field.getGenericType()));\n            }\n        }\n        builder.indent(1).append(\"return entity;\\n\");\n        builder.append(\"}\");\n\n        return builder.build();\n    }\n\n    private void registerEnumClass(Class<?> fieldClass) {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) fieldClass;\n        enumDBMapper.registerEnumClass(enumClass);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SelectQuery.java."}, {"role": "assistant", "content": "The source code of java class SelectQuery.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Column;\nimport core.framework.db.PrimaryKey;\nimport core.framework.db.Table;\nimport core.framework.internal.reflect.Classes;\n\nimport java.lang.reflect.Field;\nimport java.util.List;\n\n/**\n * @author neo\n */\nfinal class SelectQuery<T> {\n    final String getSQL;\n    final Dialect dialect;\n    private final String table;\n    private final String columns;\n    int primaryKeyColumns;\n\n    SelectQuery(Class<T> entityClass, Dialect dialect) {\n        table = entityClass.getDeclaredAnnotation(Table.class).name();\n        List<Field> fields = Classes.instanceFields(entityClass);\n        columns = columns(fields);\n        getSQL = getSQL(fields);\n        this.dialect = dialect;\n    }\n\n    private String getSQL(List<Field> fields) {\n        var builder = new StringBuilder(\"SELECT \").append(columns).append(\" FROM \").append(table).append(\" WHERE \");\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(PrimaryKey.class)) {\n                Column column = field.getDeclaredAnnotation(Column.class);\n                if (primaryKeyColumns > 0) builder.append(\" AND \");\n                builder.append(column.name()).append(\" = ?\");\n                primaryKeyColumns++;\n            }\n        }\n        return builder.toString();\n    }\n\n    private String columns(List<Field> fields) {\n        var builder = new StringBuilder();\n        int index = 0;\n        for (Field field : fields) {\n            Column column = field.getDeclaredAnnotation(Column.class);\n            if (index > 0) builder.append(\", \");\n            builder.append(column.name());\n            index++;\n        }\n        return builder.toString();\n    }\n\n    String fetchSQL(StringBuilder where, String sort, Integer skip, Integer limit) {\n        return sql(columns, where, null, sort, skip, limit);\n    }\n\n    String sql(String projection, StringBuilder where, String groupBy, String sort, Integer skip, Integer limit) {\n        var builder = new StringBuilder(\"SELECT \").append(projection).append(\" FROM \").append(table);\n        if (!where.isEmpty()) builder.append(\" WHERE \").append(where);\n        if (groupBy != null) builder.append(\" GROUP BY \").append(groupBy);\n        if (sort != null) builder.append(\" ORDER BY \").append(sort);\n        if (skip != null || limit != null) {\n            if (dialect == Dialect.MYSQL) {\n                builder.append(\" LIMIT ?,?\");\n            } else if (dialect == Dialect.POSTGRESQL) {\n                builder.append(\" OFFSET ? LIMIT ?\");\n            }\n        }\n        return builder.toString();\n    }\n\n    Object[] params(List<Object> params, Integer skip, Integer limit) {\n        if (skip != null && limit == null) throw new Error(\"limit must not be null if skip is not, skip=\" + skip);\n        if (skip == null && limit == null) return params.toArray();\n\n        Integer skipValue = skip == null ? Integer.valueOf(0) : skip;\n        if (params.isEmpty()) return new Object[]{skipValue, limit};\n        int length = params.size();\n        Object[] results = params.toArray(new Object[params.size() + 2]);\n        results[length] = skipValue;\n        results[length + 1] = limit;\n        return results;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SQLBatchParams.java."}, {"role": "assistant", "content": "The source code of java class SQLBatchParams.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.internal.log.filter.LogParam;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author neo\n */\nclass SQLBatchParams implements LogParam {\n    private final EnumDBMapper mapper;\n    private final List<Object[]> params;\n\n    SQLBatchParams(EnumDBMapper mapper, List<Object[]> params) {\n        this.mapper = mapper;\n        this.params = params;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        int maxLength = builder.length() + maxParamLength;\n        builder.append('[');\n        int index = 0;\n        for (Object[] batch : params) {\n            if (index > 0) builder.append(\", \");\n\n            builder.append('[');\n            int length = batch.length;\n            for (int i = 0; i < length; i++) {\n                if (i > 0) builder.append(\", \");\n                builder.append(SQLParams.value(batch[i], mapper));\n            }\n            builder.append(']');\n\n            if (builder.length() > maxLength) {\n                builder.setLength(maxLength);\n                builder.append(\"...(truncated)\");\n                return;\n            }\n\n            index++;\n        }\n        builder.append(']');\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SQLParams.java."}, {"role": "assistant", "content": "The source code of java class SQLParams.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.internal.log.filter.LogParam;\nimport core.framework.internal.log.filter.LogParamHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\nclass SQLParams implements LogParam {\n    private static final Logger LOGGER = LoggerFactory.getLogger(SQLParams.class);\n\n    static String value(Object param, EnumDBMapper mapper) {\n        if (param instanceof Enum<?> value) {\n            try {\n                return mapper.getDBValue(value);\n            } catch (Throwable e) {\n                LOGGER.warn(\"failed to get db enum value, error={}\", e.getMessage(), e);\n                return String.valueOf(param);\n            }\n        }\n        return String.valueOf(param);\n    }\n\n    private final EnumDBMapper mapper;\n    private final Object[] params;\n\n    SQLParams(EnumDBMapper mapper, Object... params) {\n        this.mapper = mapper;\n        this.params = params;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        if (params == null) {\n            builder.append(\"null\");\n        } else {\n            // roughly limit each string value to 1000 chars\n            int maxSQLParamLength = maxParamLength / 10;\n            builder.append('[');\n            int length = params.length;\n            for (int i = 0; i < length; i++) {\n                if (i > 0) builder.append(\", \");\n                String value = value(params[i], mapper);\n                LogParamHelper.append(builder, value, maxSQLParamLength);\n            }\n            builder.append(']');\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TransactionImpl.java."}, {"role": "assistant", "content": "The source code of java class TransactionImpl.java:\n```java\npackage core.framework.internal.db;\n\n\nimport core.framework.db.Transaction;\nimport core.framework.log.ActionLogContext;\nimport core.framework.log.Markers;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\nfinal class TransactionImpl implements Transaction {\n    private final Logger logger = LoggerFactory.getLogger(TransactionImpl.class);\n\n    private final TransactionManager transactionManager;\n    private final StopWatch watch = new StopWatch();\n    private final long longTransactionThresholdInNanos;\n\n    TransactionImpl(TransactionManager transactionManager, long longTransactionThresholdInNanos) {\n        logger.debug(\"begin transaction\");\n        this.transactionManager = transactionManager;\n        this.longTransactionThresholdInNanos = longTransactionThresholdInNanos;\n    }\n\n    @Override\n    public void rollback() {\n        var watch = new StopWatch();\n        try {\n            transactionManager.rollbackTransaction();\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"rollback transaction, elapsed={}\", elapsed);\n            ActionLogContext.track(\"db\", elapsed);\n        }\n    }\n\n    @Override\n    public void commit() {\n        var watch = new StopWatch();\n        try {\n            transactionManager.commitTransaction();\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"commit transaction, elapsed={}\", elapsed);\n            ActionLogContext.track(\"db\", elapsed);\n        }\n    }\n\n    @Override\n    public void close() {\n        try {\n            transactionManager.endTransaction();\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"end transaction, elapsed={}\", elapsed);\n            if (elapsed > longTransactionThresholdInNanos) {\n                logger.warn(Markers.errorCode(\"LONG_TRANSACTION\"), \"long db transaction, elapsed={}\", Duration.ofNanos(elapsed));\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TransactionManager.java."}, {"role": "assistant", "content": "The source code of java class TransactionManager.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Transaction;\nimport core.framework.db.UncheckedSQLException;\nimport core.framework.internal.resource.Pool;\nimport core.framework.internal.resource.PoolItem;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class TransactionManager {\n    private static final ThreadLocal<PoolItem<Connection>> CURRENT_CONNECTION = new ThreadLocal<>();\n    private static final ThreadLocal<TransactionState> CURRENT_TRANSACTION_STATE = new ThreadLocal<>();\n\n    private final Logger logger = LoggerFactory.getLogger(TransactionManager.class);\n    private final Pool<Connection> pool;\n    public long longTransactionThresholdInNanos = Duration.ofSeconds(5).toNanos();\n\n    TransactionManager(Pool<Connection> pool) {\n        this.pool = pool;\n    }\n\n    PoolItem<Connection> getConnection() {\n        PoolItem<Connection> connection = CURRENT_CONNECTION.get();\n        if (connection != null) {\n            TransactionState state = CURRENT_TRANSACTION_STATE.get();\n            if (state != TransactionState.START)\n                throw new Error(\"db access is not allowed after transaction ended, currentState=\" + state);\n            return connection;\n        }\n\n        return pool.borrowItem();\n    }\n\n    void returnConnection(PoolItem<Connection> connection) {\n        if (CURRENT_CONNECTION.get() == null)\n            returnConnectionToPool(connection, false);\n    }\n\n    Transaction beginTransaction() {\n        if (CURRENT_CONNECTION.get() != null) throw new Error(\"nested transaction is not supported\");\n\n        PoolItem<Connection> connection = pool.borrowItem();\n        try {\n            connection.resource.setAutoCommit(false);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        }\n\n        // set state after real operation done, to avoid ending up unexpected state if error occurs\n        CURRENT_TRANSACTION_STATE.set(TransactionState.START);\n        CURRENT_CONNECTION.set(connection);\n\n        return new TransactionImpl(this, longTransactionThresholdInNanos);\n    }\n\n    void commitTransaction() {\n        PoolItem<Connection> connection = CURRENT_CONNECTION.get();\n        try {\n            logger.debug(\"commit transaction\");\n            connection.resource.commit();\n            CURRENT_TRANSACTION_STATE.set(TransactionState.COMMIT);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        }\n    }\n\n    void rollbackTransaction() {\n        PoolItem<Connection> connection = CURRENT_CONNECTION.get();\n        try {\n            logger.debug(\"rollback transaction\");\n            connection.resource.rollback();\n            CURRENT_TRANSACTION_STATE.set(TransactionState.ROLLBACK);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        }\n    }\n\n    void endTransaction() {\n        PoolItem<Connection> connection = CURRENT_CONNECTION.get();\n        TransactionState state = CURRENT_TRANSACTION_STATE.get();\n        // cleanup state first, to avoid ending up with unexpected state\n        CURRENT_CONNECTION.remove();\n        CURRENT_TRANSACTION_STATE.remove();\n\n        try {\n            if (state == TransactionState.START) {\n                logger.warn(\"rollback transaction due to transaction.commit() was not called or exception occurred\");\n                connection.resource.rollback();\n            }\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            returnConnectionToPool(connection, true);\n        }\n    }\n\n    private void returnConnectionToPool(PoolItem<Connection> connection, boolean resetAutoCommit) {\n        try {\n            if (!connection.broken && resetAutoCommit)\n                connection.resource.setAutoCommit(true);\n        } catch (SQLException e) {\n            Connections.checkConnectionState(connection, e);\n            throw new UncheckedSQLException(e);\n        } finally {\n            pool.returnItem(connection);\n        }\n    }\n\n    private enum TransactionState {\n        START, COMMIT, ROLLBACK\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class UpdateQuery.java."}, {"role": "assistant", "content": "The source code of java class UpdateQuery.java:\n```java\npackage core.framework.internal.db;\n\n/**\n * @author neo\n */\npublic interface UpdateQuery<T> {\n    Statement update(T entity, boolean partial, String where, Object[] params);\n\n    class Statement {\n        final String sql;\n        final Object[] params;\n\n        Statement(String sql, Object... params) {\n            this.sql = sql;\n            this.params = params;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class UpdateQueryBuilder.java."}, {"role": "assistant", "content": "The source code of java class UpdateQueryBuilder.java:\n```java\npackage core.framework.internal.db;\n\nimport core.framework.db.Column;\nimport core.framework.db.PrimaryKey;\nimport core.framework.db.Table;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.util.Lists;\n\nimport java.lang.reflect.Field;\nimport java.util.List;\n\nimport static core.framework.internal.asm.Literal.type;\n\n/**\n * @author neo\n */\nclass UpdateQueryBuilder<T> {\n    final DynamicInstanceBuilder<UpdateQuery<T>> builder;\n    private final Class<T> entityClass;\n\n    UpdateQueryBuilder(Class<T> entityClass) {\n        this.entityClass = entityClass;\n        builder = new DynamicInstanceBuilder<>(UpdateQuery.class, entityClass.getSimpleName());\n    }\n\n    UpdateQuery<T> build() {\n        List<Field> primaryKeyFields = Lists.newArrayList();\n        List<Field> columnFields = Lists.newArrayList();\n        for (Field field : Classes.instanceFields(entityClass)) {\n            if (field.isAnnotationPresent(PrimaryKey.class)) {\n                primaryKeyFields.add(field);\n            } else if (field.isAnnotationPresent(Column.class)) {\n                columnFields.add(field);\n            }\n        }\n\n        builder.addMethod(updateMethod(entityClass, primaryKeyFields, columnFields));\n        return builder.build();\n    }\n\n    private String updateMethod(Class<T> entityClass, List<Field> primaryKeyFields, List<Field> columnFields) {\n        var builder = new CodeBuilder();\n        String entityClassLiteral = type(entityClass);\n        builder.append(\"public {} update(Object value, boolean partial, String where, Object[] whereParams) {\\n\", type(UpdateQuery.Statement.class))\n            .indent(1).append(\"{} entity = ({}) value;\\n\", entityClassLiteral, entityClassLiteral);\n\n        for (Field primaryKeyField : primaryKeyFields) {\n            builder.indent(1).append(\"if (entity.{} == null) throw new Error(\\\"primary key must not be null, field={}\\\");\\n\", primaryKeyField.getName(), primaryKeyField.getName());\n        }\n        builder.indent(1).append(\"StringBuilder sql = new StringBuilder(\\\"UPDATE {} SET \\\");\\n\", entityClass.getDeclaredAnnotation(Table.class).name());\n        builder.indent(1).append(\"java.util.List params = new java.util.ArrayList();\\n\");\n        builder.indent(1).append(\"int index = 0;\\n\");\n\n        for (Field field : columnFields) {\n            Column column = field.getDeclaredAnnotation(Column.class);\n            builder.indent(1).append(\"if (!partial || entity.{} != null) {\\n\", field.getName())\n                .indent(2).append(\"if (index > 0) sql.append(\\\", \\\");\\n\")\n                .indent(2).append(\"sql.append(\\\"{} = ?\\\");\\n\", column.name());\n\n            if (column.json()) {\n                builder.indent(2).append(\"params.add({}.toJSON(entity.{}));\\n\", type(JSONHelper.class), field.getName());\n            } else {\n                builder.indent(2).append(\"params.add(entity.{});\\n\", field.getName());\n            }\n\n            builder.indent(2).append(\"index++;\\n\")\n                .indent(1).append(\"}\\n\");\n        }\n\n        builder.indent(1).append(\"sql.append(\\\"\");\n        int index = 0;\n        for (Field primaryKeyField : primaryKeyFields) {\n            if (index == 0) {\n                builder.append(\" WHERE \");\n            } else {\n                builder.append(\" AND \");\n            }\n            builder.append(\"{} = ?\", primaryKeyField.getDeclaredAnnotation(Column.class).name());\n            index++;\n        }\n        builder.append(\"\\\");\\n\");\n        for (Field primaryKeyField : primaryKeyFields) {\n            builder.indent(1).append(\"params.add(entity.{});\\n\", primaryKeyField.getName());\n        }\n\n        builder.indent(1).append(\"if (where != null) {\\n\")\n            .indent(2).append(\"sql.append(\\\" AND (\\\").append(where).append(')');\\n\")\n            .indent(2).append(\"for (int i = 0; i< whereParams.length; i++) params.add(whereParams[i]);\\n\")\n            .indent(1).append(\"}\\n\");\n\n        builder.indent(1).append(\"return new {}(sql.toString(), params.toArray());\\n\", type(UpdateQuery.Statement.class))\n            .append(\"}\");\n        return builder.build();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BodyLogParam.java."}, {"role": "assistant", "content": "The source code of java class BodyLogParam.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.http.ContentType;\nimport core.framework.internal.log.filter.BytesLogParam;\n\nimport static core.framework.http.ContentType.APPLICATION_JSON;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class BodyLogParam {\n    public static Object of(byte[] body, ContentType contentType) {\n        if (contentType != null && (APPLICATION_JSON.mediaType.equals(contentType.mediaType)\n                || contentType.mediaType.contains(\"text\")\n                || contentType.mediaType.contains(\"xml\"))) {\n            return new BytesLogParam(body, contentType.charset().orElse(UTF_8));\n        }\n        // form is not handled here, for both http client and http server\n        return \"byte[\" + body.length + \"]\";\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CookieManager.java."}, {"role": "assistant", "content": "The source code of java class CookieManager.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.util.Maps;\nimport okhttp3.Cookie;\nimport okhttp3.CookieJar;\nimport okhttp3.HttpUrl;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class CookieManager implements CookieJar {\n    final Map<String, Cookie> store = Maps.newConcurrentHashMap();\n\n    @Override\n    public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n        for (Cookie cookie : cookies) {\n            String key = cookie.domain() + \":\" + cookie.path() + \":\" + cookie.name();\n            // refer to okhttp3.Cookie.parse(), with maxAge=0, it set expiresAt = Long.MIN_VALUE\n            if (cookie.expiresAt() == Long.MIN_VALUE && \"\".equals(cookie.value())) {\n                store.remove(key);\n            } else {\n                store.put(key, cookie);\n            }\n        }\n    }\n\n    @Override\n    public List<Cookie> loadForRequest(HttpUrl url) {\n        List<Cookie> matchingCookies = new ArrayList<>();\n        Iterator<Map.Entry<String, Cookie>> iterator = store.entrySet().iterator();\n        long now = System.currentTimeMillis();\n        while (iterator.hasNext()) {\n            Cookie cookie = iterator.next().getValue();\n            if (cookie.expiresAt() < now) {\n                iterator.remove();\n            } else if (cookie.matches(url)) {\n                matchingCookies.add(cookie);\n            }\n        }\n        return matchingCookies;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DefaultTrustManager.java."}, {"role": "assistant", "content": "The source code of java class DefaultTrustManager.java:\n```java\npackage core.framework.internal.http;\n\nimport javax.net.ssl.X509TrustManager;\nimport java.security.cert.X509Certificate;\n\n/**\n * @author neo\n */\npublic class DefaultTrustManager implements X509TrustManager {\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) {\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) {\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FallbackDNSCache.java."}, {"role": "assistant", "content": "The source code of java class FallbackDNSCache.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.util.Maps;\nimport okhttp3.Dns;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic class FallbackDNSCache implements Dns {\n    // usually http client only calls limited external domains, so here use unlimited cache\n    final Map<String, List<InetAddress>> cache = Maps.newConcurrentHashMap();\n\n    private final Logger logger = LoggerFactory.getLogger(FallbackDNSCache.class);\n\n    @Override\n    public List<InetAddress> lookup(String domain) throws UnknownHostException {\n        try {\n            List<InetAddress> addresses = Arrays.asList(InetAddress.getAllByName(domain));\n            cache.put(domain, addresses);\n            return addresses;\n        } catch (UnknownHostException e) {\n            List<InetAddress> addresses = cache.get(domain);\n            if (addresses != null) {\n                logger.warn(errorCode(\"DNS_FAILURE\"), \"failed to resolve domain, fallback to previous cached addresses, domain={}\", domain, e);\n                return addresses;\n            }\n            throw e;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPClientImpl.java."}, {"role": "assistant", "content": "The source code of java class HTTPClientImpl.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPClientException;\nimport core.framework.http.HTTPHeaders;\nimport core.framework.http.HTTPMethod;\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\nimport core.framework.internal.log.filter.FieldMapLogParam;\nimport core.framework.log.ActionLogContext;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Strings;\nimport okhttp3.Headers;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport static core.framework.log.Markers.errorCode;\nimport static java.lang.String.CASE_INSENSITIVE_ORDER;\n\n/**\n * @author neo\n */\npublic final class HTTPClientImpl implements HTTPClient {\n    private static final MediaType MEDIA_TYPE_APPLICATION_JSON = MediaType.get(ContentType.APPLICATION_JSON.toString());\n    public final long timeoutInNano;\n    private final Logger logger = LoggerFactory.getLogger(HTTPClientImpl.class);\n    private final String userAgent;\n    private final long slowOperationThresholdInNanos;\n    private final OkHttpClient client;\n\n    public HTTPClientImpl(OkHttpClient client, String userAgent, Duration slowOperationThreshold, Duration timeout) {\n        this.client = client;\n        this.userAgent = userAgent;\n        slowOperationThresholdInNanos = slowOperationThreshold.toNanos();\n        timeoutInNano = timeout.toNanos();\n    }\n\n    @Override\n    public HTTPResponse execute(HTTPRequest request) {\n        var watch = new StopWatch();\n        Request httpRequest = httpRequest(request);\n        int requestBodyLength = request.body == null ? 0 : request.body.length;\n        int responseBodyLength = 0;\n        try (Response httpResponse = client.newCall(httpRequest).execute()) {\n            HTTPResponse response = response(httpResponse);\n            responseBodyLength = response.body.length;\n            return response;\n        } catch (IOException e) {\n            throw new HTTPClientException(Strings.format(\"http request failed, uri={}, error={}\", request.uri, e.getMessage()), \"HTTP_REQUEST_FAILED\", e);\n        } finally {\n            long elapsed = watch.elapsed();\n            ActionLogContext.track(\"http\", elapsed, responseBodyLength, requestBodyLength);\n            logger.debug(\"execute, elapsed={}\", elapsed);\n            if (elapsed > slowOperationThresholdInNanos(request)) {\n                logger.warn(errorCode(\"SLOW_HTTP\"), \"slow http operation, method={}, uri={}, elapsed={}\", request.method, request.uri, Duration.ofNanos(elapsed));\n            }\n        }\n    }\n\n    long slowOperationThresholdInNanos(HTTPRequest request) {\n        if (request.slowOperationThreshold != null) return request.slowOperationThreshold.toNanos();\n        return slowOperationThresholdInNanos;\n    }\n\n    HTTPResponse response(Response httpResponse) throws IOException {\n        int statusCode = httpResponse.code();\n        logger.debug(\"[response] status={}\", statusCode);\n\n        Map<String, String> headers = new TreeMap<>(CASE_INSENSITIVE_ORDER);\n        Headers httpHeaders = httpResponse.headers();\n        for (int i = 0; i < httpHeaders.size(); i++) {\n            headers.put(httpHeaders.name(i), httpHeaders.value(i));\n        }\n        logger.debug(\"[response] headers={}\", new FieldMapLogParam(headers));\n\n        byte[] body;\n        if (statusCode == 204) {\n            // refer to https://tools.ietf.org/html/rfc7230#section-3.3.2, with 204, server won't send body and content-length, hence no need to read it, and body will be quietly closed by response.close()\n            body = new byte[0];\n        } else {\n            ResponseBody responseBody = httpResponse.body();\n            if (responseBody == null) throw new Error(\"unexpected response body\"); // refer to okhttp3.Response.body(), call.execute always return non-null body except for cachedResponse/networkResponse\n            body = responseBody.bytes();\n        }\n\n        var response = new HTTPResponse(statusCode, headers, body);\n        logger.debug(\"[response] body={}\", BodyLogParam.of(body, response.contentType));\n        return response;\n    }\n\n    Request httpRequest(HTTPRequest request) {\n        var builder = new Request.Builder();\n\n        try {\n            logger.debug(\"[request] method={}, uri={}\", request.method, request.uri);\n            // not log final uri with query params which may contain sensitive data, to simplify so no need to do additional masking\n            // the downside is the query param logged below may not appear in final requestURI if value is null or empty\n            builder.url(request.requestURI());\n        } catch (IllegalArgumentException e) {\n            throw new HTTPClientException(\"uri is invalid, uri=\" + request.uri, \"INVALID_URL\", e);\n        }\n\n        if (!request.params.isEmpty())\n            logger.debug(\"[request] params={}\", new FieldMapLogParam(request.params));   // due to null/empty will be serialized to empty value, so here to log actual params\n\n        request.headers.put(HTTPHeaders.USER_AGENT, userAgent);\n        for (Map.Entry<String, String> entry : request.headers.entrySet()) {\n            builder.addHeader(entry.getKey(), entry.getValue());\n        }\n        logger.debug(\"[request] headers={}\", new FieldMapLogParam(request.headers));\n\n        if (request.body != null) {\n            if (request.form != null) {\n                logger.debug(\"[request] form={}\", new FieldMapLogParam(request.form));\n            } else {\n                logger.debug(\"[request] body={}\", BodyLogParam.of(request.body, request.contentType));\n            }\n            MediaType contentType = mediaType(request.contentType);\n            builder.method(request.method.name(), RequestBody.create(request.body, contentType));\n        } else {\n            RequestBody body = request.method == HTTPMethod.GET || request.method == HTTPMethod.HEAD ? null : RequestBody.create(new byte[0], null);\n            builder.method(request.method.name(), body);\n        }\n\n        if (request.connectTimeout != null || request.timeout != null) {\n            logger.debug(\"[request] connectTimeout={}, timeout={}\", request.connectTimeout, request.timeout);\n            builder.tag(HTTPRequest.class, request);\n        }\n\n        return builder.build();\n    }\n\n    @Nullable\n    MediaType mediaType(ContentType contentType) {\n        if (contentType == null) return null;   // generally body is always set with valid content type, but in theory contentType=null is considered legitimate, so here to support such case\n        if (ContentType.APPLICATION_JSON.equals(contentType)) return MEDIA_TYPE_APPLICATION_JSON; // avoid parsing as application/json is most used type\n        return MediaType.get(contentType.toString());   // use get() not parse() to fail if passed invalid contentType\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPEventListenerFactory.java."}, {"role": "assistant", "content": "The source code of java class HTTPEventListenerFactory.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.log.ActionLogContext;\nimport okhttp3.Call;\nimport okhttp3.EventListener;\nimport okhttp3.Protocol;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class HTTPEventListenerFactory implements EventListener.Factory {\n    @Override\n    public EventListener create(Call call) {\n        return new Listener();\n    }\n\n    static class Listener extends EventListener {   // okHTTP create listener for each realCall, no threading issue\n        private static final Logger LOGGER = LoggerFactory.getLogger(Listener.class);\n        private long dnsStart;\n        private long connectStart;\n\n        // okHTTP uses URL Host/Address as key to acquire connection, refer to okhttp3.internal.connection.RealConnectionPool -> callAcquirePooledConnection\n        // if conn pool doesn't have matched connection, it creates new connection object, resolves dns(dnsStart/End), connects socket (connectStart/End)\n        // if conn pool has eligible connection, then reuses connection, dns/connect are skipped\n        @Override\n        public void dnsStart(Call call, String domain) {\n            dnsStart = System.nanoTime();\n        }\n\n        @Override\n        public void dnsEnd(Call call, String domain, List<InetAddress> addresses) {\n            long elapsed = System.nanoTime() - dnsStart;\n            LOGGER.debug(\"resolve domain, domain={}, addresses={}, elapsed={}\", domain, addresses, elapsed);\n            ActionLogContext.track(\"http_dns\", elapsed);\n        }\n\n        @Override\n        public void connectStart(Call call, InetSocketAddress address, Proxy proxy) {\n            connectStart = System.nanoTime();\n        }\n\n        @Override\n        public void connectEnd(Call call, InetSocketAddress address, Proxy proxy, Protocol protocol) {\n            long elapsed = System.nanoTime() - connectStart;\n            LOGGER.debug(\"create http connection, address={}, elapsed={}\", address, elapsed);\n            ActionLogContext.track(\"http_conn\", elapsed);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPRequestHelper.java."}, {"role": "assistant", "content": "The source code of java class HTTPRequestHelper.java:\n```java\npackage core.framework.internal.http;\n\nimport java.util.Map;\n\nimport static java.net.URLEncoder.encode;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class HTTPRequestHelper {\n    public static void urlEncoding(StringBuilder builder, Map<String, String> params) {\n        boolean added = false;\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String value = entry.getValue();\n            if (added) builder.append('&');\n            builder.append(encode(entry.getKey(), UTF_8)).append('=');\n            // url encoding doesn't differentiate null and empty, so treat null same as empty value\n            if (value != null && !value.isEmpty()) builder.append(encode(value, UTF_8));\n            added = true;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PEM.java."}, {"role": "assistant", "content": "The source code of java class PEM.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.util.Encodings;\n\nimport java.util.stream.Collectors;\n\n/**\n * @author neo\n */\npublic class PEM {\n    public static byte[] decode(String pem) {\n        String content = pem.lines().filter(line -> !line.startsWith(\"-----\"))\n                            .collect(Collectors.joining());\n        return Encodings.decodeBase64(content);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RetryInterceptor.java."}, {"role": "assistant", "content": "The source code of java class RetryInterceptor.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.util.Threads;\nimport okhttp3.Interceptor;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.internal.connection.RouteException;\nimport okhttp3.internal.http2.ConnectionShutdownException;\nimport okhttp3.internal.http2.ErrorCode;\nimport okhttp3.internal.http2.StreamResetException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.SSLException;\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.time.Duration;\n\nimport static core.framework.log.Markers.errorCode;\nimport static okhttp3.internal.Util.closeQuietly;\n\n/**\n * @author neo\n */\npublic class RetryInterceptor implements Interceptor {\n    private final Logger logger = LoggerFactory.getLogger(RetryInterceptor.class);\n    private final int maxRetries;\n    private final long waitTimeInMs;\n\n    public RetryInterceptor(int maxRetries, Duration retryWaitTime) {\n        this.maxRetries = maxRetries;\n        waitTimeInMs = retryWaitTime.toMillis();\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        int attempts = 1;\n        while (true) {\n            try {\n                Response response = chain.proceed(request);\n                int statusCode = response.code();\n                if (shouldRetry(statusCode, attempts)) {    // do not check call.isCanceled(), RetryAndFollowUpInterceptor already checked and throw exception\n                    logger.warn(errorCode(\"HTTP_REQUEST_FAILED\"), \"http request failed, retry soon, responseStatus={}, uri={}\", statusCode, uri(request));\n                    closeResponseBody(response);\n                } else {\n                    return response;\n                }\n            } catch (IOException | RouteException e) {\n                if (shouldRetry(chain.call().isCanceled(), request.method(), attempts, e)) {\n                    logger.warn(errorCode(\"HTTP_REQUEST_FAILED\"), \"http request failed, retry soon, uri={}, error={}\", uri(request), e.getMessage(), e);\n                } else {\n                    throw e;\n                }\n            }\n            sleep(waitTime(attempts));\n            attempts++;\n\n            // set to actionLog directly to keep trace log concise\n            ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n            if (actionLog != null) actionLog.stats.compute(\"http_retries\", (key, oldValue) -> (oldValue == null) ? 1.0 : oldValue + 1);\n        }\n    }\n\n    // remove query params, to keep it simple by skipping masking\n    String uri(Request request) {\n        return request.url().newBuilder().query(null).build().toString();\n    }\n\n    // response.close asserts body not null, refer to Response.close()\n    // RetryAndFollowUpInterceptor also closes body directly\n    private void closeResponseBody(Response response) {\n        ResponseBody body = response.body();\n        if (body != null) closeQuietly(body);\n    }\n\n    boolean shouldRetry(int statusCode, int attempts) {\n        if (statusCode == HTTPStatus.SERVICE_UNAVAILABLE.code || statusCode == HTTPStatus.TOO_MANY_REQUESTS.code) {\n            if (attempts >= maxRetries) return false;\n            return withinMaxProcessTime(attempts);\n        }\n        return false;\n    }\n\n    // refer to RetryAndFollowUpInterceptor.intercept for built-in error handling\n    boolean shouldRetry(boolean canceled, String method, int attempts, Exception e) {\n        if (canceled) return false;    // AsyncTimout cancels call if callTimeout, refer to RealCall.kt/timout field\n        if (attempts >= maxRetries) return false;\n        if (!withinMaxProcessTime(attempts)) return false;\n\n        if (e instanceof RouteException) return true;   // if it's route failure, then request is not sent yet\n        if (e instanceof ConnectionShutdownException) return true;  // refer to RetryAndFollowUpInterceptor -> requestSendStarted = e !is ConnectionShutdownException\n\n        // only not retry on POST if request sent\n        if (!\"POST\".equals(method)) return true;\n\n        // should not retry on connection reset, the request could be sent already, and server side may continue to complete it\n        if (e instanceof SSLException && \"Connection reset\".equals(e.getMessage())) return false;\n        if (e instanceof StreamResetException exception && exception.errorCode == ErrorCode.CANCEL) return false;\n\n        // okHTTP uses both socket timeout and AsyncTimeout, it closes socket/connection when timeout is detected by background thread, so no need to close exchange\n        // refer to AsyncTimeout.newTimeoutException() -> SocketAsyncTimeout.newTimeoutException()\n        return !(e instanceof SocketTimeoutException && \"timeout\".equals(e.getMessage()));\n    }\n\n    // for short circuit, e.g. heavy load request causes remote service busy, and client timeout triggers more retry requests, to amplify the load\n    boolean withinMaxProcessTime(int attempts) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return true;\n        long remainingTime = actionLog.remainingProcessTimeInNano();\n        if (remainingTime <= waitTime(attempts).toNanos()) {\n            logger.debug(\"not retry due to max process time limit, remainingTime={}\", Duration.ofNanos(remainingTime));\n            return false;\n        }\n        return true;\n    }\n\n    Duration waitTime(int attempts) {\n        return Duration.ofMillis(waitTimeInMs << attempts - 1);\n    }\n\n    void sleep(Duration duration) {\n        Threads.sleepRoughly(duration);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ServiceUnavailableInterceptor.java."}, {"role": "assistant", "content": "The source code of java class ServiceUnavailableInterceptor.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.api.http.HTTPStatus;\nimport okhttp3.Interceptor;\nimport okhttp3.Response;\nimport okhttp3.internal.connection.RealConnection;\n\nimport java.io.IOException;\n\n/**\n * @author neo\n */\npublic class ServiceUnavailableInterceptor implements Interceptor {\n    // only network interceptor is able to access connection,\n    // this is to obsolete the current connection if got 503, during remote graceful shutdown process (kube/service)\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Response response = chain.proceed(chain.request());\n        if (response.code() == HTTPStatus.SERVICE_UNAVAILABLE.code) {\n            RealConnection connection = (RealConnection) chain.connection();\n            if (connection != null) {\n                connection.setNoNewExchanges(true);\n            }\n        }\n        return response;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TimeoutInterceptor.java."}, {"role": "assistant", "content": "The source code of java class TimeoutInterceptor.java:\n```java\npackage core.framework.internal.http;\n\nimport core.framework.http.HTTPRequest;\nimport okhttp3.Interceptor;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author neo\n */\npublic class TimeoutInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Interceptor.Chain chain) throws IOException {\n        Interceptor.Chain chainWithTimeout = chain;\n        Request request = chain.request();\n        HTTPRequest httpRequest = request.tag(HTTPRequest.class);\n        if (httpRequest != null) {\n            if (httpRequest.connectTimeout != null) {\n                chainWithTimeout = chainWithTimeout.withConnectTimeout((int) httpRequest.connectTimeout.toMillis(), TimeUnit.MILLISECONDS);\n            }\n            if (httpRequest.timeout != null) {\n                chainWithTimeout = chainWithTimeout.withReadTimeout((int) httpRequest.timeout.toMillis(), TimeUnit.MILLISECONDS)\n                        .withWriteTimeout((int) httpRequest.timeout.toMillis(), TimeUnit.MILLISECONDS);\n            }\n        }\n        return chainWithTimeout.proceed(request);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanFactory.java."}, {"role": "assistant", "content": "The source code of java class BeanFactory.java:\n```java\npackage core.framework.internal.inject;\n\nimport core.framework.inject.Inject;\nimport core.framework.inject.Named;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.util.Maps;\nimport core.framework.util.Types;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class BeanFactory {\n    private final Map<Key, Object> beans = Maps.newHashMap();\n\n    public void bind(Type type, @Nullable String name, Object instance) {\n        if (instance == null) throw new Error(\"instance must not be null\");\n\n        if (!isTypeOf(instance, type))\n            throw new Error(format(\"instance type does not match, type={}, instanceType={}\", type.getTypeName(), instance.getClass().getCanonicalName()));\n\n        Object previous = beans.put(new Key(type, name), instance);\n        if (previous != null)\n            throw new Error(format(\"found duplicate bean, type={}, name={}, previous={}\", type.getTypeName(), name, previous));\n    }\n\n    public Object bean(Type type, String name) {\n        Object bean = beans.get(new Key(type, name));\n        if (bean == null) throw new Error(format(\"can not find bean, type={}, name={}\", type.getTypeName(), name));\n        return bean;\n    }\n\n    public <T> T create(Class<T> instanceClass) {\n        if (instanceClass.isInterface() || Modifier.isAbstract(instanceClass.getModifiers()))\n            throw new Error(\"instance class must be concrete, class=\" + instanceClass.getCanonicalName());\n\n        try {\n            T instance = construct(instanceClass);\n            inject(instance);\n            return instance;\n        } catch (ReflectiveOperationException e) {\n            throw new Error(e);\n        }\n    }\n\n    public <T> void inject(T instance) {\n        try {\n            Class<?> visitorType = instance.getClass();\n            while (!visitorType.equals(Object.class)) {\n                for (Field field : visitorType.getDeclaredFields()) {\n                    if (field.isAnnotationPresent(Inject.class)) {\n                        if (Modifier.isStatic(field.getModifiers()))\n                            throw new Error(\"static field must not have @Inject, field=\" + Fields.path(field));\n                        if (field.trySetAccessible()) {\n                            field.set(instance, lookupValue(field));\n                        } else {\n                            throw new Error(\"failed to inject field, field=\" + Fields.path(field));\n                        }\n                    }\n                }\n                visitorType = visitorType.getSuperclass();\n            }\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        }\n    }\n\n    private <T> T construct(Class<T> instanceClass) throws ReflectiveOperationException {\n        Constructor<?>[] constructors = instanceClass.getDeclaredConstructors();\n        if (constructors.length > 1 || constructors[0].getParameterCount() > 1 || !Modifier.isPublic(constructors[0].getModifiers())) {\n            throw new Error(format(\"instance class must have only one public default constructor, class={}, constructors={}\", instanceClass.getCanonicalName(), Arrays.toString(constructors)));\n        }\n        return instanceClass.getDeclaredConstructor().newInstance();\n    }\n\n    private Object lookupValue(Field field) {\n        Named named = field.getDeclaredAnnotation(Named.class);\n        Type fieldType = stripOwnerType(field.getGenericType());\n\n        String name = named == null ? null : named.value();\n        Object bean = beans.get(new Key(fieldType, name));\n        if (bean == null) throw new Error(format(\"can not resolve dependency, type={}, name={}, field={}\", fieldType.getTypeName(), name, Fields.path(field)));\n        return bean;\n    }\n\n    private Type stripOwnerType(Type paramType) {    // type from field/method params could has owner type, which is not used in bind/key\n        if (paramType instanceof ParameterizedType parameterizedType)\n            return Types.generic((Class<?>) parameterizedType.getRawType(), parameterizedType.getActualTypeArguments());\n        return paramType;\n    }\n\n    private boolean isTypeOf(Object instance, Type type) {\n        if (type instanceof Class<?> classType) return classType.isInstance(instance);\n        if (type instanceof ParameterizedType parameterizedType) return isTypeOf(instance, parameterizedType.getRawType());\n        throw new Error(\"not supported type, type=\" + type.getTypeName());\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InjectValidator.java."}, {"role": "assistant", "content": "The source code of java class InjectValidator.java:\n```java\npackage core.framework.internal.inject;\n\nimport core.framework.inject.Inject;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.util.Strings;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class InjectValidator {\n    // validate all cascaded fields with @Inject are properly assigned,\n    // to prevent cases like someone added new @Inject field to one class but didn't realize the instance is not created thru DI\n\n    private final Class<?> rootClass;\n    private final Set<Object> visitedObjects = new HashSet<>();     // to prevent circular references\n    private final Queue<Object> queue = new ArrayDeque<>();\n\n    public InjectValidator(Object instance) {\n        rootClass = instance.getClass();\n        queue.add(instance);\n    }\n\n    public void validate() {\n        while (true) {\n            var instance = queue.poll();\n            if (instance == null) return;\n\n            visitedObjects.add(instance);\n\n            Field[] fields = instance.getClass().getDeclaredFields();\n            for (Field field : fields) {\n                int modifiers = field.getModifiers();\n                if (Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) continue;  // skip final field as final field enforces initialization\n\n                Object value = fieldValue(field, instance);\n\n                // 1. @Inject presents, not null -> stop as most likely injected by framework\n                // 2. @Inject presents, null -> error, means parent bean is not autowired\n                // 3. @Inject not present, not null -> add to queue to check object tree\n                // 4. @Inject not present, null -> stop as it could be app managed field\n                if (field.isAnnotationPresent(Inject.class)) {\n                    if (value == null) throw new Error(Strings.format(\"field with @Inject is not bound to any value, rootClass={}, field={}\", rootClass.getCanonicalName(), Fields.path(field)));\n                } else if (value != null && shouldInspect(value)) {\n                    queue.add(value);\n                }\n            }\n        }\n    }\n\n    // only try to inspect relevant / application level classes\n    private boolean shouldInspect(Object value) {\n        Class<?> valueClass = value.getClass();\n        if (valueClass.getPackageName().startsWith(\"java\") || valueClass.isEnum()) return false;\n        return !visitedObjects.contains(value);\n    }\n\n    private Object fieldValue(Field field, Object instance) {\n        if (field.trySetAccessible()) {\n            try {\n                return field.get(instance);\n            } catch (IllegalAccessException e) {\n                throw new Error(e);\n            }\n        }\n        return null;    // ignore non accessible fields\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Key.java."}, {"role": "assistant", "content": "The source code of java class Key.java:\n```java\npackage core.framework.internal.inject;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Type;\nimport java.util.Objects;\n\n/**\n * @author neo\n */\npublic final class Key {\n    public final Type type;\n    @Nullable\n    public final String name;\n\n    public Key(Type type, @Nullable String name) {\n        this.type = type;\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        if (this == object) return true;\n        if (object == null || getClass() != object.getClass()) return false;\n        Key key = (Key) object;\n        return Objects.equals(type, key.type)\n                && Objects.equals(name, key.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(type, name);\n    }\n\n    @Override\n    public String toString() {\n        return \"Key{type=\" + type.getTypeName() + \", name=\" + name + '}';\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class JSONClassValidator.java."}, {"role": "assistant", "content": "The source code of java class JSONClassValidator.java:\n```java\npackage core.framework.internal.json;\n\nimport core.framework.api.json.Property;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.internal.validate.ClassValidator;\nimport core.framework.internal.validate.ClassVisitor;\nimport core.framework.util.Maps;\nimport core.framework.util.Sets;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class JSONClassValidator implements ClassVisitor {\n    public static void validateEnum(Class<?> enumClass) {\n        Set<String> enumValues = Sets.newHashSet();\n        List<Field> fields = Classes.enumConstantFields(enumClass);\n        for (Field field : fields) {\n            Property property = field.getDeclaredAnnotation(Property.class);\n            if (property == null)\n                throw new Error(\"enum must have @Property, field=\" + Fields.path(field));\n            boolean added = enumValues.add(property.name());\n            if (!added)\n                throw new Error(format(\"found duplicate property, field={}, name={}\", Fields.path(field), property.name()));\n        }\n    }\n\n    private final ClassValidator validator;\n    private final Map<String, Set<String>> visitedProperties = Maps.newHashMap();\n\n    public JSONClassValidator(Class<?> instanceClass) {\n        validator = new ClassValidator(instanceClass);\n        validator.allowedValueClasses = Set.of(String.class, Boolean.class,\n            Integer.class, Long.class, Double.class, BigDecimal.class,\n            LocalDate.class, LocalDateTime.class, ZonedDateTime.class, Instant.class, LocalTime.class);\n        validator.visitor = this;\n    }\n\n    public void validate() {\n        validator.validate();\n    }\n\n    @Override\n    public void visitField(Field field, String parentPath) {\n        Property property = field.getDeclaredAnnotation(Property.class);\n        if (property == null)\n            throw new Error(\"field must have @Property, field=\" + Fields.path(field));\n\n        String name = property.name();\n        if (name.isBlank()) throw new Error(\"@Property name attribute must not be blank, field=\" + Fields.path(field));\n\n        boolean added = visitedProperties.computeIfAbsent(parentPath, key -> Sets.newHashSet()).add(name);\n        if (!added) {\n            throw new Error(format(\"found duplicate property, field={}, name={}\", Fields.path(field), name));\n        }\n    }\n\n    @Override\n    public void visitEnum(Class<?> enumClass) {\n        validateEnum(enumClass);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ConsumerMetrics.java."}, {"role": "assistant", "content": "The source code of java class ConsumerMetrics.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * @author neo\n */\npublic class ConsumerMetrics implements Metrics {\n    private final String name;\n    private final List<Metric> recordsLagMax = new CopyOnWriteArrayList<>();    // all metrics are added in message thread, so to use concurrent list\n    private final List<Metric> recordsConsumedRate = new CopyOnWriteArrayList<>();\n    private final List<Metric> bytesConsumedRate = new CopyOnWriteArrayList<>();\n    private final List<Metric> fetchRate = new CopyOnWriteArrayList<>();\n\n    ConsumerMetrics(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        stats.put(statName(\"records_max_lag\"), sum(recordsLagMax));\n        stats.put(statName(\"records_consumed_rate\"), sum(recordsConsumedRate));\n        stats.put(statName(\"bytes_consumed_rate\"), sum(bytesConsumedRate));\n        stats.put(statName(\"fetch_rate\"), sum(fetchRate));\n    }\n\n    void add(Map<MetricName, ? extends Metric> kafkaMetrics) {\n        for (var entry : kafkaMetrics.entrySet()) {\n            MetricName name = entry.getKey();\n            if (\"consumer-fetch-manager-metrics\".equals(name.group())) {\n                if (\"records-lag-max\".equals(name.name())) recordsLagMax.add(entry.getValue());\n                else if (\"records-consumed-rate\".equals(name.name())) recordsConsumedRate.add(entry.getValue());\n                else if (\"bytes-consumed-rate\".equals(name.name())) bytesConsumedRate.add(entry.getValue());\n                else if (\"fetch-rate\".equals(name.name())) fetchRate.add(entry.getValue());\n            }\n        }\n    }\n\n    double sum(List<Metric> metrics) {\n        double sum = 0.0;\n        for (var metric : metrics) {\n            double value = (double) metric.metricValue();\n            if (Double.isFinite(value)) sum += value; // kafka uses infinity as initial value, e.g. org.apache.kafka.common.metrics.stats.Max\n        }\n        return sum;\n    }\n\n    String statName(String statName) {\n        var builder = new StringBuilder(\"kafka_consumer\");\n        if (name != null) builder.append('_').append(name);\n        builder.append('_').append(statName);\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KafkaMessage.java."}, {"role": "assistant", "content": "The source code of java class KafkaMessage.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.log.Trace;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.common.header.Header;\nimport org.apache.kafka.common.header.Headers;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\npublic class KafkaMessage {\n    public static final String HEADER_CORRELATION_ID = \"correlationId\";\n    public static final String HEADER_TRACE = \"trace\";\n    public static final String HEADER_CLIENT = \"client\";\n    public static final String HEADER_REF_ID = \"refId\";\n\n    final String key;\n    final byte[] value;\n    final Trace trace;\n    final String correlationId;\n    final String refId;\n    final String client;\n    final long timestamp;\n\n    // one poll batch is small (~500) and short (~500ms), it doesn't expect many messages with same key (less than 3?)\n    List<KafkaMessage> subsequent;\n\n    KafkaMessage(ConsumerRecord<String, byte[]> record) {\n        key = record.key();\n        value = record.value();\n\n        Headers headers = record.headers();\n        refId = header(headers, HEADER_REF_ID);\n        correlationId = header(headers, HEADER_CORRELATION_ID);\n        client = header(headers, HEADER_CLIENT);\n        String trace = header(headers, HEADER_TRACE);\n        this.trace = trace == null ? null : Trace.parse(trace);\n\n        timestamp = record.timestamp();\n    }\n\n    final String header(Headers headers, String key) {\n        Header header = headers.lastHeader(key);\n        if (header == null) return null;\n        return new String(header.value(), UTF_8);\n    }\n\n    void addSubsequent(KafkaMessage message) {\n        if (subsequent == null) subsequent = new ArrayList<>(5);\n        subsequent.add(message);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KafkaMessages.java."}, {"role": "assistant", "content": "The source code of java class KafkaMessages.java:\n```java\npackage core.framework.internal.kafka;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass KafkaMessages {\n    final Map<String, KafkaMessage> ordered = new HashMap<>();\n    final List<KafkaMessage> unordered = new ArrayList<>();\n    final String topic;\n\n    boolean bulk;\n    int count;\n    int size;\n\n    KafkaMessages(String topic) {\n        this.topic = topic;\n    }\n\n    void addOrdered(ConsumerRecord<String, byte[]> record) {\n        var message = new KafkaMessage(record);\n        if (message.key != null) {\n            KafkaMessage root = ordered.get(message.key);\n            if (root != null) root.addSubsequent(message);\n            else ordered.put(message.key, message);\n        } else {\n            unordered.add(message);\n        }\n        count++;\n        size += message.value.length;\n    }\n\n    void addUnordered(ConsumerRecord<String, byte[]> record) {\n        var message = new KafkaMessage(record);\n        unordered.add(message);\n        count++;\n        size += message.value.length;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KafkaURI.java."}, {"role": "assistant", "content": "The source code of java class KafkaURI.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.util.Strings;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class KafkaURI {\n    public final List<String> bootstrapURIs;\n    private final String uri;\n\n    public KafkaURI(String uri) {\n        this.uri = uri;\n        bootstrapURIs = parse(uri);\n    }\n\n    // refer to org.apache.kafka.clients.ClientUtils.parseAndValidateAddresses,\n    // append default port if not presents\n    private List<String> parse(String uri) {\n        String[] values = Strings.split(uri, ',');\n        List<String> uris = new ArrayList<>(values.length);\n        for (String value : values) {\n            String result = value.strip();\n            if (result.indexOf(':') == -1) {\n                uris.add(result + \":9092\");\n            } else {\n                uris.add(result);\n            }\n        }\n        return uris;\n    }\n\n    @Override\n    public String toString() {  // make it easier to log\n        return uri;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KeyDeserializer.java."}, {"role": "assistant", "content": "The source code of java class KeyDeserializer.java:\n```java\npackage core.framework.internal.kafka;\n\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.serialization.Deserializer;\nimport org.apache.kafka.common.utils.Utils;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\npublic class KeyDeserializer implements Deserializer<String> {\n    @Override\n    public String deserialize(String topic, byte[] data) {\n        // this is not used if deserialize(String topic, Headers headers, ByteBuffer data) is used\n        // refer to KIP-863: Reduce CompletedFetch#parseRecord() memory copy\n        throw new Error(\"unexpected flow\");\n    }\n\n    @Override\n    public String deserialize(String topic, Headers headers, ByteBuffer data) {\n        if (data == null) return null;\n\n        if (data.hasArray()) {\n            return new String(data.array(), data.position() + data.arrayOffset(), data.remaining(), StandardCharsets.UTF_8);\n        }\n\n        return new String(Utils.toArray(data), StandardCharsets.UTF_8);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageListener.java."}, {"role": "assistant", "content": "The source code of java class MessageListener.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.log.LogManager;\nimport core.framework.kafka.BulkMessageHandler;\nimport core.framework.kafka.MessageHandler;\nimport core.framework.util.Maps;\nimport core.framework.util.Network;\nimport core.framework.util.StopWatch;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.serialization.ByteArrayDeserializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic class MessageListener {\n    public final ConsumerMetrics consumerMetrics;\n    public final Set<String> topics = new HashSet<>();\n    public final Map<String, MessageProcess<?>> processes = new HashMap<>();\n    public final Map<String, MessageProcess<?>> bulkProcesses = new HashMap<>();\n    final LogManager logManager;\n\n    private final Logger logger = LoggerFactory.getLogger(MessageListener.class);\n    private final KafkaURI uri;\n    private final String name;\n\n    public int concurrency = Runtime.getRuntime().availableProcessors() * 16;\n    public long longConsumerDelayThresholdInNano = Duration.ofSeconds(30).toNanos();\n    public int maxPollRecords = 500;            // default kafka setting, refer to org.apache.kafka.clients.consumer.ConsumerConfig.MAX_POLL_RECORDS_CONFIG\n    public int maxPollBytes = 3 * 1024 * 1024;  // get 3M bytes if possible for batching, this is not absolute limit of max bytes to poll, refer to org.apache.kafka.clients.consumer.ConsumerConfig.FETCH_MAX_BYTES_DOC\n    public int minPollBytes = 1;                // default kafka setting\n    public Duration maxWaitTime = Duration.ofMillis(500);\n    public String groupId = LogManager.APP_NAME;\n\n    long maxProcessTimeInNano;\n    private MessageListenerThread thread;\n\n    public MessageListener(KafkaURI uri, String name, LogManager logManager, long maxProcessTimeInNano) {\n        this.uri = uri;\n        this.name = name;\n        this.logManager = logManager;\n        this.maxProcessTimeInNano = maxProcessTimeInNano;\n        this.consumerMetrics = new ConsumerMetrics(name);\n    }\n\n    public <T> void subscribe(String topic, Class<T> messageClass, MessageHandler<T> handler, BulkMessageHandler<T> bulkHandler) {\n        boolean added = topics.add(topic);\n        if (!added) throw new Error(\"topic is already subscribed, topic=\" + topic);\n        if (handler != null) {\n            processes.put(topic, new MessageProcess<>(handler, messageClass));\n        } else {\n            bulkProcesses.put(topic, new MessageProcess<>(bulkHandler, messageClass));\n        }\n    }\n\n    public void start() {\n        Consumer<String, byte[]> consumer = createConsumer();\n        thread = new MessageListenerThread(threadName(name), consumer, this);\n        thread.start();\n        logger.info(\"kafka listener started, uri={}, topics={}, name={}, groupId={}\", uri, topics, name, groupId);\n    }\n\n    public void shutdown() {\n        if (thread != null) {  // in case of shutdown in middle of start\n            logger.info(\"shutting down kafka listener, uri={}, name={}\", uri, name);\n            thread.shutdown();\n        }\n    }\n\n    public void awaitTermination(long timeoutInMs) {\n        if (thread != null) {\n            try {\n                boolean success = thread.awaitTermination(timeoutInMs);\n                if (!success) {\n                    logger.error(errorCode(\"FAILED_TO_STOP\"), \"failed to terminate kafka listener, name={}\", name);\n                } else {\n                    logger.info(\"kafka listener stopped, uri={}, topics={}, name={}\", uri, topics, name);\n                }\n            } catch (InterruptedException e) {\n                logger.warn(e.getMessage(), e);\n            }\n        }\n    }\n\n    String threadName(String name) {\n        return \"kafka-listener\" + (name == null ? \"\" : \"-\" + name);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    Consumer<String, byte[]> createConsumer() {\n        var watch = new StopWatch();\n        try {\n            Map<String, Object> config = Maps.newHashMapWithExpectedSize(13);\n            config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, uri.bootstrapURIs);\n            config.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);\n            config.put(ConsumerConfig.CLIENT_ID_CONFIG, Network.LOCAL_HOST_NAME + (name == null ? \"\" : \"/\" + name));      // will show in monitor metrics\n            config.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.FALSE);\n            config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"latest\");                      // refer to org.apache.kafka.clients.consumer.ConsumerConfig, must be in(\"latest\", \"earliest\", \"none\")\n            config.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 1_800_000);                  // 30min as max process time for each poll\n            config.put(ConsumerConfig.RECONNECT_BACKOFF_MS_CONFIG, 500L);                       // longer backoff to reduce cpu usage when kafka is not available\n            config.put(ConsumerConfig.RECONNECT_BACKOFF_MAX_MS_CONFIG, 5_000L);                 // 5s\n            config.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords);\n            config.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, maxPollBytes);\n            config.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, minPollBytes);\n            config.put(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, (int) maxWaitTime.toMillis());\n            config.put(ConsumerConfig.AUTO_INCLUDE_JMX_REPORTER_CONFIG, Boolean.FALSE);\n            Consumer<String, byte[]> consumer = new KafkaConsumer<>(config, new KeyDeserializer(), new ByteArrayDeserializer());\n            consumerMetrics.add(consumer.metrics());\n\n            consumer.subscribe(topics);\n            return consumer;\n        } finally {\n            logger.info(\"create kafka consumer, topics={}, name={}, elapsed={}\", topics, name, watch.elapsed());\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageListenerThread.java."}, {"role": "assistant", "content": "The source code of java class MessageListenerThread.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.async.ThreadPools;\nimport core.framework.internal.async.VirtualThread;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.PerformanceWarning;\nimport core.framework.internal.log.filter.BytesLogParam;\nimport core.framework.kafka.Message;\nimport core.framework.util.Sets;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Threads;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Semaphore;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\nclass MessageListenerThread extends Thread {\n    private final Logger logger = LoggerFactory.getLogger(MessageListenerThread.class);\n    private final MessageListener listener;\n    private final LogManager logManager;\n\n    private final Consumer<String, byte[]> consumer;\n    private final Builder.OfVirtual thread;\n\n    private final Semaphore semaphore;\n    private final int concurrency;\n\n    private final Object lock = new Object();\n    private volatile boolean shutdown;\n    private volatile boolean processing;\n\n    MessageListenerThread(String name, Consumer<String, byte[]> consumer, MessageListener listener) {\n        super(name);\n        this.consumer = consumer;\n        this.listener = listener;\n        logManager = listener.logManager;\n        concurrency = listener.concurrency;\n        semaphore = new Semaphore(concurrency);\n        thread = ThreadPools.virtualThreadBuilder(name + \"-\");   // used in single thread, no need to use factory()\n    }\n\n    @Override\n    public void run() {\n        try {\n            processing = true;\n            process();\n        } finally {\n            processing = false;\n            synchronized (lock) {\n                lock.notifyAll();\n            }\n        }\n    }\n\n    private void process() {\n        while (!shutdown) {\n            try {\n                Collection<KafkaMessages> allMessages = poll();   // consumer should call poll at least once every MAX_POLL_INTERVAL_MS\n                if (allMessages == null) continue;\n\n                processAll(allMessages);\n            } catch (Throwable e) {\n                if (!shutdown) {\n                    logger.error(\"failed to poll messages, retry in 10 seconds\", e);\n                    Threads.sleepRoughly(Duration.ofSeconds(10));\n                }\n            }\n        }\n\n        logger.info(\"close kafka consumer, name={}\", getName());\n        consumer.close();\n    }\n\n    @Nullable\n    Collection<KafkaMessages> poll() {\n        ConsumerRecords<String, byte[]> records = consumer.poll(Duration.ofSeconds(30));\n        if (records.isEmpty()) return null;\n\n        Map<String, KafkaMessages> messageMappings = new LinkedHashMap<>();\n        for (ConsumerRecord<String, byte[]> record : records) {\n            String topic = record.topic();\n            KafkaMessages messages = messageMappings.computeIfAbsent(topic, KafkaMessages::new);\n            if (listener.bulkProcesses.containsKey(topic)) {\n                messages.addUnordered(record);  // bulk is processed in single thread\n                messages.bulk = true;\n            } else {\n                messages.addOrdered(record);\n            }\n        }\n        return messageMappings.values();\n    }\n\n    void shutdown() {\n        shutdown = true;\n        // do not call interrupt(), it will interrupt consumer coordinator,\n        // the only downside of not calling interrupt() is if thread is at process->exception->sleepRoughly, shutdown will have to wait until sleep ends\n        consumer.wakeup();\n    }\n\n    boolean awaitTermination(long timeoutInMs) throws InterruptedException {\n        long end = System.currentTimeMillis() + timeoutInMs;\n        synchronized (lock) {\n            while (processing) {\n                long left = end - System.currentTimeMillis();\n                if (left <= 0) {\n                    return false;\n                }\n                lock.wait(left);\n            }\n            return true;\n        }\n    }\n\n    void processAll(Collection<KafkaMessages> allMessages) throws InterruptedException {\n        var watch = new StopWatch();\n        int count = 0;\n        int size = 0;\n\n        for (KafkaMessages messages : allMessages) {\n            count += messages.count;\n            size += messages.size;\n\n            if (messages.bulk) {\n                MessageProcess<?> bulkProcess = listener.bulkProcesses.get(messages.topic);\n                processBulk(bulkProcess, messages);\n            } else {\n                MessageProcess<?> process = listener.processes.get(messages.topic);\n                processSingle(process, messages);\n            }\n        }\n\n        semaphore.acquire(concurrency);\n        try {\n            consumer.commitAsync();\n        } finally {\n            semaphore.release(concurrency);\n        }\n\n        logger.info(\"process kafka messages, count={}, size={}, elapsed={}\", count, size, watch.elapsed());\n    }\n\n    private void processSingle(MessageProcess<?> process, KafkaMessages messages) throws InterruptedException {\n        for (KafkaMessage message : messages.unordered) {\n            semaphore.acquire();\n            thread.start(() -> {\n                try {\n                    VirtualThread.COUNT.increase();\n                    handleSingle(messages.topic, process, message);\n                } finally {\n                    VirtualThread.COUNT.decrease();\n                    semaphore.release();\n                }\n            });\n        }\n        for (KafkaMessage message : messages.ordered.values()) {\n            semaphore.acquire();\n            thread.start(() -> {\n                try {\n                    VirtualThread.COUNT.increase();\n                    handleSingle(messages.topic, process, message);\n                    if (message.subsequent != null) {\n                        for (KafkaMessage subsequent : message.subsequent) {\n                            handleSingle(messages.topic, process, subsequent);\n                        }\n                    }\n                } finally {\n                    VirtualThread.COUNT.decrease();\n                    semaphore.release();\n                }\n            });\n        }\n    }\n\n    <T> void handleSingle(String topic, MessageProcess<T> process, KafkaMessage message) {\n        ActionLog actionLog = logManager.begin(\"=== message handling begin ===\", null);\n        try {\n            initAction(actionLog, topic, process.handler.getClass().getCanonicalName(), process.warnings);\n\n            actionLog.track(\"kafka\", 0, 1, 0);\n\n            if (message.trace != null) actionLog.trace = message.trace;\n            if (message.correlationId != null) actionLog.correlationIds = List.of(message.correlationId);\n            if (message.client != null) actionLog.clients = List.of(message.client);\n            if (message.refId != null) actionLog.refIds = List.of(message.refId);\n            logger.debug(\"[header] refId={}, client={}, correlationId={}, trace={}\", message.refId, message.client, message.correlationId, message.trace);\n\n            actionLog.context.put(\"key\", Collections.singletonList(message.key)); // key can be null\n\n            checkConsumerDelay(actionLog, message.timestamp, listener.longConsumerDelayThresholdInNano);\n\n            logger.debug(\"[message] key={}, value={}, timestamp={}\", message.key, new BytesLogParam(message.value), message.timestamp);\n\n            T messageObject = process.reader.fromJSON(message.value);\n            process.validator.validate(messageObject, false);\n            process.handler().handle(message.key, messageObject);\n        } catch (Throwable e) {\n            logManager.logError(e);\n        } finally {\n            logManager.end(\"=== message handling end ===\");\n        }\n    }\n\n    private void processBulk(MessageProcess<?> bulkProcess, KafkaMessages messages) throws InterruptedException {\n        semaphore.acquire();\n        thread.start(() -> {\n            VirtualThread.COUNT.increase();\n            try {\n                handleBulk(messages.topic, bulkProcess, messages.unordered);\n            } finally {\n                VirtualThread.COUNT.decrease();\n                semaphore.release();\n            }\n        });\n    }\n\n    <T> void handleBulk(String topic, MessageProcess<T> process, List<KafkaMessage> messages) {\n        ActionLog actionLog = logManager.begin(\"=== message handling begin ===\", null);\n        try {\n            initAction(actionLog, topic, process.handler.getClass().getCanonicalName(), process.warnings);\n\n            List<Message<T>> messageObjects = messages(messages, actionLog, process.reader);\n            for (Message<T> message : messageObjects) {   // validate after fromJSON, so it can track refId/correlationId\n                process.validator.validate(message.value, false);\n            }\n\n            process.bulkHandler().handle(messageObjects);\n        } catch (Throwable e) {\n            logManager.logError(e);\n        } finally {\n            logManager.end(\"=== message handling end ===\");\n        }\n    }\n\n    private void initAction(ActionLog actionLog, String topic, String handler, PerformanceWarning[] warnings) {\n        actionLog.action(\"topic:\" + topic);\n        actionLog.warningContext.maxProcessTimeInNano(listener.maxProcessTimeInNano);\n        actionLog.context.put(\"topic\", List.of(topic));\n        actionLog.context.put(\"handler\", List.of(handler));\n        logger.debug(\"topic={}, handler={}\", topic, handler);\n        if (warnings != null) actionLog.initializeWarnings(warnings);\n    }\n\n    <T> List<Message<T>> messages(List<KafkaMessage> messages, ActionLog actionLog, JSONReader<T> reader) throws IOException {\n        int size = messages.size();\n        actionLog.track(\"kafka\", 0, size, 0);\n        List<Message<T>> messageObjects = new ArrayList<>(size);\n        Set<String> correlationIds = new HashSet<>();\n        Set<String> clients = new HashSet<>();\n        Set<String> refIds = new HashSet<>();\n        Set<String> keys = Sets.newHashSetWithExpectedSize(size);\n        long minTimestamp = Long.MAX_VALUE;\n\n        for (KafkaMessage message : messages) {\n            if (message.trace != null) actionLog.trace = message.trace;   // trigger trace if any message is trace\n            if (message.correlationId != null) correlationIds.add(message.correlationId);\n            if (message.client != null) clients.add(message.client);\n            if (message.refId != null) refIds.add(message.refId);\n            keys.add(message.key);\n\n            logger.debug(\"[message] key={}, value={}, timestamp={}, refId={}, client={}, correlationId={}, trace={}\",\n                message.key, new BytesLogParam(message.value), message.timestamp, message.refId, message.client, message.correlationId, message.trace);\n\n            if (minTimestamp > message.timestamp) minTimestamp = message.timestamp;\n\n            T messageObject = reader.fromJSON(message.value);\n            messageObjects.add(new Message<>(message.key, messageObject));\n        }\n        actionLog.context.put(\"key\", new ArrayList<>(keys));    // keys could contain null\n\n        if (!correlationIds.isEmpty()) actionLog.correlationIds = List.copyOf(correlationIds);  // action log kafka appender doesn't send headers\n        if (!clients.isEmpty()) actionLog.clients = List.copyOf(clients);\n        if (!refIds.isEmpty()) actionLog.refIds = List.copyOf(refIds);\n        checkConsumerDelay(actionLog, minTimestamp, listener.longConsumerDelayThresholdInNano);\n        return messageObjects;\n    }\n\n    void checkConsumerDelay(ActionLog actionLog, long timestamp, long longConsumerDelayThresholdInNano) {\n        long delay = (actionLog.date.toEpochMilli() - timestamp) * 1_000_000;     // convert to nanoseconds\n        logger.debug(\"consumerDelay={}\", Duration.ofNanos(delay));\n        actionLog.stats.put(\"consumer_delay\", (double) delay);\n        // refer to core.framework.internal.kafka.MessageListener.createConsumer, MAX_POLL_INTERVAL_MS_CONFIG = 30 mins\n        // log as error if delay > 15 mins\n        if (delay > 900_000_000_000L) {\n            logger.error(errorCode(\"LONG_CONSUMER_DELAY\"), \"consumer delay is too long, delay={}\", Duration.ofNanos(delay));\n        } else if (delay > longConsumerDelayThresholdInNano) {\n            logger.warn(errorCode(\"LONG_CONSUMER_DELAY\"), \"consumer delay is too long, delay={}\", Duration.ofNanos(delay));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageProcess.java."}, {"role": "assistant", "content": "The source code of java class MessageProcess.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.log.PerformanceWarning;\nimport core.framework.internal.log.WarningContext;\nimport core.framework.internal.validate.Validator;\nimport core.framework.kafka.BulkMessageHandler;\nimport core.framework.kafka.MessageHandler;\nimport core.framework.log.IOWarning;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class MessageProcess<T> {\n    public final Object handler;\n    public final JSONReader<T> reader;\n    public final Validator<T> validator;\n    @Nullable\n    public final PerformanceWarning[] warnings;\n\n    MessageProcess(Object handler, Class<T> messageClass) {\n        this.handler = handler;\n        reader = JSONMapper.reader(messageClass);\n        validator = Validator.of(messageClass);\n        this.warnings = warnings(handler);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public MessageHandler<T> handler() {\n        return (MessageHandler<T>) handler;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public BulkMessageHandler<T> bulkHandler() {\n        return (BulkMessageHandler<T>) handler;\n    }\n\n    @Nullable\n    private PerformanceWarning[] warnings(Object handler) {\n        try {\n            Method targetMethod;\n            if (handler instanceof MessageHandler) {\n                targetMethod = handler.getClass().getMethod(\"handle\", String.class, Object.class);\n            } else {\n                targetMethod = handler.getClass().getMethod(\"handle\", List.class);\n            }\n            return WarningContext.warnings(targetMethod.getDeclaredAnnotationsByType(IOWarning.class));\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageProducer.java."}, {"role": "assistant", "content": "The source code of java class MessageProducer.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.util.StopWatch;\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.Map;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic class MessageProducer {\n    public final ProducerMetrics producerMetrics;\n    private final Logger logger = LoggerFactory.getLogger(MessageProducer.class);\n    private final KafkaURI uri;\n    private final String name;\n    private final int maxRequestSize;\n    private Producer<byte[], byte[]> producer;\n\n    public MessageProducer(KafkaURI uri, String name, int maxRequestSize) {\n        this.uri = uri;\n        this.name = name;\n        this.maxRequestSize = maxRequestSize;\n        this.producerMetrics = new ProducerMetrics(name);\n    }\n\n    public void initialize() {\n        producer = createProducer(uri);\n    }\n\n    public void send(ProducerRecord<byte[], byte[]> record) {\n        producer.send(record, new KafkaCallback(record));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    Producer<byte[], byte[]> createProducer(KafkaURI uri) {\n        var watch = new StopWatch();\n        try {\n            Map<String, Object> config = Map.of(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, uri.bootstrapURIs,\n                ProducerConfig.COMPRESSION_TYPE_CONFIG, CompressionType.SNAPPY.name,\n                ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG, 60_000,                           // 60s, DELIVERY_TIMEOUT_MS_CONFIG is INT type\n                ProducerConfig.LINGER_MS_CONFIG, 5L,                                         // use small linger time within acceptable range to improve batching\n                ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, 500L,                            // longer backoff to reduce cpu usage when kafka is not available\n                ProducerConfig.RECONNECT_BACKOFF_MAX_MS_CONFIG, 5_000L,                      // 5s\n                ProducerConfig.MAX_BLOCK_MS_CONFIG, 30_000L,                                 // 30s, metadata update timeout, shorter than default, to get exception sooner if kafka is not available\n                ProducerConfig.MAX_REQUEST_SIZE_CONFIG, maxRequestSize,\n                ProducerConfig.AUTO_INCLUDE_JMX_REPORTER_CONFIG, Boolean.FALSE);\n\n            var serializer = new ByteArraySerializer();\n            var producer = new KafkaProducer<>(config, serializer, serializer);\n            producerMetrics.set(producer.metrics());\n            return producer;\n        } finally {\n            logger.info(\"create kafka producer, uri={}, name={}, elapsed={}\", uri, name, watch.elapsed());\n        }\n    }\n\n    public void close(long timeoutInMs) {\n        if (producer != null) {\n            logger.info(\"close kafka producer, uri={}, name={}\", uri, name);\n            producer.flush();\n            producer.close(Duration.ofMillis(timeoutInMs));    // close timeout must greater than 0, the shutdown hook always pass in positive timeout\n        }\n    }\n\n    static final class KafkaCallback implements Callback {\n        private static final Logger LOGGER = LoggerFactory.getLogger(KafkaCallback.class);\n        private final ProducerRecord<byte[], byte[]> record;\n\n        KafkaCallback(ProducerRecord<byte[], byte[]> record) {\n            this.record = record;\n        }\n\n        @Override\n        public void onCompletion(RecordMetadata metadata, Exception exception) {\n            if (exception != null) {    // if failed to send message (kafka is down), fallback to error output\n                byte[] key = record.key();\n                LOGGER.error(\"failed to send kafka message, error={}, topic={}, key={}, value={}\",\n                    exception.getMessage(),\n                    record.topic(),\n                    key == null ? null : new String(key, UTF_8),\n                    new String(record.value(), UTF_8),\n                    exception);\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessagePublisherImpl.java."}, {"role": "assistant", "content": "The source code of java class MessagePublisherImpl.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport core.framework.internal.log.filter.BytesLogParam;\nimport core.framework.internal.validate.Validator;\nimport core.framework.kafka.MessagePublisher;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Strings;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.header.Headers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic class MessagePublisherImpl<T> implements MessagePublisher<T> {\n    private final Logger logger = LoggerFactory.getLogger(MessagePublisherImpl.class);\n\n    private final MessageProducer producer;\n    private final String topic;\n    private final JSONWriter<T> writer;\n    private final Validator<T> validator;\n\n    public MessagePublisherImpl(MessageProducer producer, String topic, Class<T> messageClass) {\n        this.producer = producer;\n        this.topic = topic;\n        writer = JSONMapper.writer(messageClass);\n        validator = Validator.of(messageClass);\n    }\n\n    @Override\n    public void publish(@Nullable String key, T value) {\n        var watch = new StopWatch();\n        byte[] keyBytes = key == null ? null : Strings.bytes(key);\n        validator.validate(value, false);\n        byte[] message = writer.toJSON(value);\n        try {\n            var record = new ProducerRecord<>(topic, null, System.currentTimeMillis(), keyBytes, message, null);\n            linkContext(record.headers());\n            producer.send(record);\n        } finally {\n            long elapsed = watch.elapsed();\n            logger.debug(\"publish, topic={}, key={}, message={}, elapsed={}\", topic, key, new BytesLogParam(message), elapsed);\n            ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n            if (actionLog != null) {\n                trackMaxMessageSize(actionLog, message.length);\n                actionLog.track(\"kafka\", elapsed, 0, 1);   // kafka producer send message in background, the main purpose of track is to count how many message sent in action\n            }\n        }\n    }\n\n    private void trackMaxMessageSize(ActionLog actionLog, double messageSize) {\n        // refer to org.apache.kafka.clients.producer.KafkaProducer.doSend\n        // int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(), compressionType, serializedKey, serializedValue, headers);\n        // kafka limits entire request size includes key/value/headers, here we only track value size\n        double maxSize = actionLog.stats.getOrDefault(\"kafka_max_message_size\", 0D);\n        if (messageSize > maxSize) {\n            actionLog.stats.put(\"kafka_max_message_size\", messageSize);\n        }\n    }\n\n    private void linkContext(Headers headers) {\n        headers.add(KafkaMessage.HEADER_CLIENT, Strings.bytes(LogManager.APP_NAME));\n\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return;      // publisher may be used without action log context\n\n        headers.add(KafkaMessage.HEADER_CORRELATION_ID, Strings.bytes(actionLog.correlationId()));\n        if (actionLog.trace == Trace.CASCADE) headers.add(KafkaMessage.HEADER_TRACE, Strings.bytes(actionLog.trace.name()));\n        headers.add(KafkaMessage.HEADER_REF_ID, Strings.bytes(actionLog.id));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ProducerMetrics.java."}, {"role": "assistant", "content": "The source code of java class ProducerMetrics.java:\n```java\npackage core.framework.internal.kafka;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class ProducerMetrics implements Metrics {\n    private final String name;\n    Metric requestSizeAvg; // The average size of all requests in the window for a broker.\n    Metric requestSizeMax; // The maximum size of any request sent in the window for a broker\n    private Metric requestRate; // The number of batch requests sent per second, one batch request contains multiple messages\n    private Metric outgoingByteRate; // The number of outgoing bytes sent to all servers per second\n\n    public ProducerMetrics(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        if (requestRate != null) stats.put(statName(\"request_rate\"), (Double) requestRate.metricValue());\n        if (requestSizeAvg != null) {\n            Double value = (Double) requestSizeAvg.metricValue();\n            if (!value.isNaN()) stats.put(statName(\"request_size_avg\"), value);     // avg value can be NaN, refer to https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=95652345\n        }\n        if (requestSizeMax != null) {\n            Double value = (Double) requestSizeMax.metricValue();\n            if (!value.isNaN()) stats.put(statName(\"request_size_max\"), value);\n        }\n        if (outgoingByteRate != null) stats.put(statName(\"outgoing_byte_rate\"), (Double) outgoingByteRate.metricValue());\n    }\n\n    // refer to https://docs.confluent.io/platform/current/kafka/monitoring.html#per-broker-metrics\n    public void set(Map<MetricName, ? extends Metric> kafkaMetrics) {\n        for (Map.Entry<MetricName, ? extends Metric> entry : kafkaMetrics.entrySet()) {\n            MetricName metricName = entry.getKey();\n            if (\"producer-metrics\".equals(metricName.group())) {\n                String name = metricName.name();\n                if (\"request-rate\".equals(name)) requestRate = entry.getValue();\n                else if (\"request-size-avg\".equals(name)) requestSizeAvg = entry.getValue();\n                else if (\"request-size-max\".equals(name)) requestSizeMax = entry.getValue();\n                else if (\"outgoing-byte-rate\".equals(name)) outgoingByteRate = entry.getValue();\n            }\n        }\n    }\n\n    private String statName(String statName) {\n        StringBuilder builder = new StringBuilder(\"kafka_producer\");\n        if (name != null) builder.append('_').append(name);\n        builder.append('_').append(statName);\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class AbstractLogger.java."}, {"role": "assistant", "content": "The source code of java class AbstractLogger.java:\n```java\npackage core.framework.internal.log;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\n\n/**\n * @author neo\n */\nabstract class AbstractLogger implements Logger {\n    protected final String name;\n\n    AbstractLogger(String name) {\n        this.name = name;\n    }\n\n    abstract void log(Marker marker, LogLevel level, String message, Object[] arguments, Throwable exception);\n\n    private void logWithOneArgument(Marker marker, LogLevel level, String format, Object arg) {\n        if (arg instanceof Throwable exception)\n            log(marker, level, format, null, exception);\n        else\n            log(marker, level, format, new Object[]{arg}, null);\n    }\n\n    private void logWithTwoArguments(Marker marker, LogLevel level, String format, Object arg1, Object arg2) {\n        if (arg2 instanceof Throwable exception)\n            log(marker, level, format, new Object[]{arg1}, exception);\n        else\n            log(marker, level, format, new Object[]{arg1, arg2}, null);\n    }\n\n    private void logWithArguments(Marker marker, LogLevel level, String format, Object... arguments) {\n        if (arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable exception) {\n            Object[] messageArguments = new Object[arguments.length - 1];\n            System.arraycopy(arguments, 0, messageArguments, 0, arguments.length - 1);\n            log(marker, level, format, messageArguments, exception);\n        } else {\n            log(marker, level, format, arguments, null);\n        }\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return false;\n    }\n\n    @Override\n    public boolean isTraceEnabled(Marker marker) {\n        return false;\n    }\n\n    @Override\n    public void trace(String msg) {\n    }\n\n    @Override\n    public void trace(String format, Object arg) {\n    }\n\n    @Override\n    public void trace(String format, Object arg1, Object arg2) {\n    }\n\n    @Override\n    public void trace(String format, Object... arguments) {\n    }\n\n    @Override\n    public void trace(String msg, Throwable t) {\n    }\n\n    @Override\n    public void trace(Marker marker, String msg) {\n    }\n\n    @Override\n    public void trace(Marker marker, String format, Object arg) {\n    }\n\n    @Override\n    public void trace(Marker marker, String format, Object arg1, Object arg2) {\n    }\n\n    @Override\n    public void trace(Marker marker, String format, Object... arguments) {\n    }\n\n    @Override\n    public void trace(Marker marker, String msg, Throwable t) {\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return false;\n    }\n\n    @Override\n    public boolean isDebugEnabled(Marker marker) {\n        return false;\n    }\n\n    @Override\n    public void debug(String msg) {\n        log(null, LogLevel.DEBUG, msg, null, null);\n    }\n\n    @Override\n    public void debug(String format, Object arg) {\n        logWithOneArgument(null, LogLevel.DEBUG, format, arg);\n    }\n\n    @Override\n    public void debug(String format, Object arg1, Object arg2) {\n        logWithTwoArguments(null, LogLevel.DEBUG, format, arg1, arg2);\n    }\n\n    @Override\n    public void debug(String format, Object... arguments) {\n        logWithArguments(null, LogLevel.DEBUG, format, arguments);\n    }\n\n    @Override\n    public void debug(String msg, Throwable t) {\n        log(null, LogLevel.DEBUG, msg, null, t);\n    }\n\n    @Override\n    public void debug(Marker marker, String msg) {\n        log(marker, LogLevel.DEBUG, msg, null, null);\n    }\n\n    @Override\n    public void debug(Marker marker, String format, Object arg) {\n        logWithOneArgument(marker, LogLevel.DEBUG, format, arg);\n    }\n\n    @Override\n    public void debug(Marker marker, String format, Object arg1, Object arg2) {\n        logWithTwoArguments(marker, LogLevel.DEBUG, format, arg1, arg2);\n    }\n\n    @Override\n    public void debug(Marker marker, String format, Object... arguments) {\n        logWithArguments(marker, LogLevel.DEBUG, format, arguments);\n    }\n\n    @Override\n    public void debug(Marker marker, String msg, Throwable t) {\n        log(marker, LogLevel.DEBUG, msg, null, t);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return true;\n    }\n\n    @Override\n    public boolean isInfoEnabled(Marker marker) {\n        return true;\n    }\n\n    @Override\n    public void info(String msg) {\n        log(null, LogLevel.INFO, msg, null, null);\n    }\n\n    @Override\n    public void info(String format, Object arg) {\n        logWithOneArgument(null, LogLevel.INFO, format, arg);\n    }\n\n    @Override\n    public void info(String format, Object arg1, Object arg2) {\n        logWithTwoArguments(null, LogLevel.INFO, format, arg1, arg2);\n    }\n\n    @Override\n    public void info(String format, Object... arguments) {\n        logWithArguments(null, LogLevel.INFO, format, arguments);\n    }\n\n    @Override\n    public void info(String msg, Throwable t) {\n        log(null, LogLevel.INFO, msg, null, t);\n    }\n\n    @Override\n    public void info(Marker marker, String msg) {\n        log(marker, LogLevel.INFO, msg, null, null);\n    }\n\n    @Override\n    public void info(Marker marker, String format, Object arg) {\n        logWithOneArgument(marker, LogLevel.INFO, format, arg);\n    }\n\n    @Override\n    public void info(Marker marker, String format, Object arg1, Object arg2) {\n        logWithTwoArguments(marker, LogLevel.INFO, format, arg1, arg2);\n    }\n\n    @Override\n    public void info(Marker marker, String format, Object... arguments) {\n        logWithArguments(marker, LogLevel.INFO, format, arguments);\n    }\n\n    @Override\n    public void info(Marker marker, String msg, Throwable t) {\n        log(marker, LogLevel.INFO, msg, null, t);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return true;\n    }\n\n    @Override\n    public boolean isWarnEnabled(Marker marker) {\n        return true;\n    }\n\n    @Override\n    public void warn(String msg) {\n        log(null, LogLevel.WARN, msg, null, null);\n    }\n\n    @Override\n    public void warn(String format, Object arg) {\n        logWithOneArgument(null, LogLevel.WARN, format, arg);\n    }\n\n    @Override\n    public void warn(String format, Object arg1, Object arg2) {\n        logWithTwoArguments(null, LogLevel.WARN, format, arg1, arg2);\n    }\n\n    @Override\n    public void warn(String format, Object... arguments) {\n        logWithArguments(null, LogLevel.WARN, format, arguments);\n    }\n\n    @Override\n    public void warn(String msg, Throwable t) {\n        log(null, LogLevel.WARN, msg, null, t);\n    }\n\n    @Override\n    public void warn(Marker marker, String msg) {\n        log(marker, LogLevel.WARN, msg, null, null);\n    }\n\n    @Override\n    public void warn(Marker marker, String format, Object arg) {\n        logWithOneArgument(marker, LogLevel.WARN, format, arg);\n    }\n\n    @Override\n    public void warn(Marker marker, String format, Object arg1, Object arg2) {\n        logWithTwoArguments(marker, LogLevel.WARN, format, arg1, arg2);\n    }\n\n    @Override\n    public void warn(Marker marker, String format, Object... arguments) {\n        logWithArguments(marker, LogLevel.WARN, format, arguments);\n    }\n\n    @Override\n    public void warn(Marker marker, String msg, Throwable t) {\n        log(marker, LogLevel.WARN, msg, null, t);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return true;\n    }\n\n    @Override\n    public boolean isErrorEnabled(Marker marker) {\n        return true;\n    }\n\n    @Override\n    public void error(String msg) {\n        log(null, LogLevel.ERROR, msg, null, null);\n    }\n\n    @Override\n    public void error(String format, Object arg) {\n        logWithOneArgument(null, LogLevel.ERROR, format, arg);\n    }\n\n    @Override\n    public void error(String format, Object arg1, Object arg2) {\n        logWithTwoArguments(null, LogLevel.ERROR, format, arg1, arg2);\n    }\n\n    @Override\n    public void error(String format, Object... arguments) {\n        logWithArguments(null, LogLevel.ERROR, format, arguments);\n    }\n\n    @Override\n    public void error(String msg, Throwable t) {\n        log(null, LogLevel.ERROR, msg, null, t);\n    }\n\n    @Override\n    public void error(Marker marker, String msg) {\n        log(marker, LogLevel.ERROR, msg, null, null);\n    }\n\n    @Override\n    public void error(Marker marker, String format, Object arg) {\n        logWithOneArgument(marker, LogLevel.ERROR, format, arg);\n    }\n\n    @Override\n    public void error(Marker marker, String format, Object arg1, Object arg2) {\n        logWithTwoArguments(marker, LogLevel.ERROR, format, arg1, arg2);\n    }\n\n    @Override\n    public void error(Marker marker, String format, Object... arguments) {\n        logWithArguments(marker, LogLevel.ERROR, format, arguments);\n    }\n\n    @Override\n    public void error(Marker marker, String msg, Throwable t) {\n        log(marker, LogLevel.ERROR, msg, null, t);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ActionLog.java."}, {"role": "assistant", "content": "The source code of java class ActionLog.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.log.Markers;\nimport core.framework.util.Strings;\n\nimport javax.annotation.Nullable;\nimport java.text.DecimalFormat;\nimport java.time.Instant;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.internal.log.LogLevel.DEBUG;\nimport static core.framework.internal.log.LogLevel.WARN;\n\n/**\n * @author neo\n */\npublic final class ActionLog {\n    public static final int MAX_CONTEXT_VALUE_LENGTH = 1000;\n    static final int MAX_CONTEXT_VALUES_SIZE = 5000;    // e.g. roughly 5000 \"order_id=UUID\"=>(8+36+3)*5000=235k\n\n    private static final String LOGGER = LoggerImpl.abbreviateLoggerName(ActionLog.class.getCanonicalName());\n    private static final int SOFT_EVENTS_LIMIT = 3000;    // normally 3000 lines trace is about 350k, and limit memory usage for each action\n\n    public final String id;\n    public final Instant date;\n    public final Map<String, List<String>> context;\n    public final Map<String, List<String>> info;\n    public final Map<String, Double> stats;\n    public final WarningContext warningContext;\n\n    final Map<String, PerformanceStat> performanceStats;\n    private final List<LogEvent> events;\n    private final long startTime;\n    public LogLevel result = LogLevel.INFO;\n    public Trace trace = Trace.NONE;        // whether flush trace log for all subsequent actions\n    public String action = \"unassigned\";\n    public List<String> correlationIds;     // with bulk message handler, there will be multiple correlationIds handled by one batch\n    public List<String> clients;\n    public List<String> refIds;\n    public String errorMessage;\n    long elapsed;\n    private String errorCode;\n\n    public ActionLog(String message, String id) {\n        startTime = System.nanoTime();\n        date = Instant.now();\n        if (id == null) {\n            this.id = LogManager.ID_GENERATOR.next(date);\n        } else {\n            this.id = id;   // in executor, id is generated in advance to link parent and task\n        }\n        events = new ArrayList<>(32);   // according to benchmark, ArrayList is as fast as LinkedList with max 3000 items, and has smaller memory footprint\n        context = new HashMap<>();  // default capacity is 16, no need to keep insertion order, kibana will sort all keys on display\n        info = new HashMap<>();\n        stats = new HashMap<>();\n        performanceStats = new HashMap<>();\n        warningContext = new WarningContext();\n\n        add(event(message));\n        add(event(\"id={}\", this.id));\n        add(event(\"date={}\", DateTimeFormatter.ISO_INSTANT.format(date)));\n        add(event(\"thread={}\", Thread.currentThread().getName()));\n    }\n\n    void process(LogEvent event) {\n        if (event.level.value > result.value) {\n            result = event.level;\n            errorCode = event.errorCode();      // only update errorCode/message if level raised, so errorCode will be first WARN or ERROR\n            errorMessage = Strings.truncate(event.message(), MAX_CONTEXT_VALUE_LENGTH);     // limit error message length in action log\n        }\n        if (event.level.value >= WARN.value || events.size() < SOFT_EVENTS_LIMIT) {       // after reach max holding lines, only add warning/error events\n            add(event);\n        }\n    }\n\n    void end(String message) {\n        for (PerformanceStat stat : performanceStats.values()) {\n            stat.checkTotalIO();\n        }\n\n        elapsed = elapsed();\n        add(event(\"elapsed={}\", elapsed));\n        warningContext.checkMaxProcessTime(elapsed);\n\n        add(event(message));\n    }\n\n    public long elapsed() {\n        return System.nanoTime() - startTime;\n    }\n\n    private void add(LogEvent event) {  // log inside action log will call this to add log event directly, so internal message won't be suspended\n        events.add(event);\n        if (events.size() == SOFT_EVENTS_LIMIT) {\n            events.add(event(\"...(soft trace limit reached)\"));\n        }\n    }\n\n    private LogEvent event(String message, Object... arguments) {\n        return new LogEvent(LOGGER, null, DEBUG, message, arguments, null);\n    }\n\n    String result() {\n        if (result == LogLevel.INFO) return \"OK\";\n        return result.name();\n    }\n\n    boolean flushTraceLog() {\n        return trace != Trace.NONE || result.value >= WARN.value;\n    }\n\n    public String errorCode() {\n        if (errorCode != null) return errorCode;\n        if (result.value >= WARN.value) return \"UNASSIGNED\";\n        return null;\n    }\n\n    public void context(String key, Object... values) {\n        List<String> contextValues = context.computeIfAbsent(key, k -> new ArrayList<>(Math.max(2, values.length)));    // at least use 2 as init capacity, 0 capacity will result in size 10 array after adding\n        for (Object value : values) {\n            String contextValue = String.valueOf(value);\n            if (contextValue.length() > MAX_CONTEXT_VALUE_LENGTH) { // prevent application code from putting large blob as context, e.g. xml or json response\n                // use new Error() to print calling stack\n                process(new LogEvent(LOGGER, Markers.errorCode(\"CONTEXT_TOO_LARGE\"), WARN, \"context value is too long, key={}, value={}\", new Object[]{key, contextValue}, new Error(\"context value is too long\")));\n            } else if (contextValues.size() >= MAX_CONTEXT_VALUES_SIZE) {\n                // try to warn once only, generally if hits here, the app likely will add much more within loop\n                if (!\"CONTEXT_TOO_LARGE\".equals(errorCode))\n                    process(new LogEvent(LOGGER, Markers.errorCode(\"CONTEXT_TOO_LARGE\"), WARN, \"too many context values, key={}, size={}\", new Object[]{key, contextValues.size()}, new Error(\"too many context values\")));\n            } else {\n                contextValues.add(contextValue);\n            }\n        }\n        add(event(\"[context] {}={}\", key, values.length == 1 ? values[0] : values));\n    }\n\n    public void info(String key, Object... values) {\n        List<String> infoValues = info.computeIfAbsent(key, k -> new ArrayList<>(Math.max(2, values.length)));\n        for (Object value : values) {\n            String infoValue = String.valueOf(value);\n            // currently, we just reuse the context values constrains on info values\n            if (infoValue.length() > MAX_CONTEXT_VALUE_LENGTH) {\n                process(new LogEvent(LOGGER, Markers.errorCode(\"CONTEXT_INFO_TOO_LARGE\"), WARN, \"info value is too long, key={}, value={}\", new Object[]{key, infoValue}, new Error(\"info value is too long\")));\n            } else if (infoValues.size() >= MAX_CONTEXT_VALUES_SIZE) {\n                if (!\"CONTEXT_INFO_TOO_LARGE\".equals(errorCode))\n                    process(new LogEvent(LOGGER, Markers.errorCode(\"CONTEXT_INFO_TOO_LARGE\"), WARN, \"too many info values, key={}, size={}\", new Object[]{key, infoValues.size()}, new Error(\"too many info values\")));\n            } else {\n                infoValues.add(infoValue);\n            }\n        }\n        add(event(\"[info] {}={}\", key, values.length == 1 ? values[0] : values));\n    }\n\n    public void stat(String key, double value) {\n        stats.compute(key, (k, oldValue) -> (oldValue == null) ? value : oldValue + value);\n        var format = new DecimalFormat();\n        add(event(\"[stat] {}={}\", key, format.format(value)));\n    }\n\n    public void initializeWarnings(PerformanceWarning[] warnings) {\n        for (PerformanceWarning warning : warnings) {\n            performanceStats.put(warning.operation, new PerformanceStat(warning));\n        }\n    }\n\n    public int track(String operation, long elapsed, int readEntries, int writeEntries) {\n        PerformanceStat stat = performanceStats.computeIfAbsent(operation, key -> new PerformanceStat(WarningContext.defaultWarning(key)));\n        stat.track(elapsed, readEntries, writeEntries);\n        return stat.count;\n    }\n\n    public String correlationId() {\n        if (correlationIds != null && correlationIds.size() == 1) return correlationIds.get(0);\n        return id; // if there are multiple correlationIds (in batch), use current id as following correlationId\n    }\n\n    public List<String> correlationIds() {\n        if (correlationIds != null) return correlationIds;\n        return List.of(id);     // current action is root action, use self id as correlationId\n    }\n\n    public void action(String action) {\n        add(event(\"action={}\", action));\n        this.action = action;\n    }\n\n    public long remainingProcessTimeInNano() {\n        long remainingTime = warningContext.maxProcessTimeInNano - elapsed();\n        if (remainingTime < 0) return 0;\n        return remainingTime;\n    }\n\n    public String trace() {\n        var builder = new StringBuilder(events.size() << 7);  // length * 128 as rough initial capacity\n        for (LogEvent event : events) {\n            event.appendTrace(builder, startTime);\n        }\n        return builder.toString();\n    }\n\n    @Nullable\n    public PerformanceWarning[] warnings() {\n        List<PerformanceWarning> configs = new ArrayList<>(performanceStats.size());\n        for (PerformanceStat stat : performanceStats.values()) {\n            if (stat.warning != null) configs.add(stat.warning);\n        }\n        if (configs.isEmpty()) return null;\n        return configs.toArray(new PerformanceWarning[0]);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ActionLogMessageFactory.java."}, {"role": "assistant", "content": "The source code of java class ActionLogMessageFactory.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.log.message.ActionLogMessage;\nimport core.framework.log.message.PerformanceStatMessage;\nimport core.framework.util.Maps;\nimport core.framework.util.Network;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class ActionLogMessageFactory {\n    public ActionLogMessage create(ActionLog log) {\n        var message = new ActionLogMessage();\n        message.app = LogManager.APP_NAME;\n        message.host = Network.LOCAL_HOST_NAME;\n        message.id = log.id;\n        message.date = log.date;\n        message.result = log.result();\n        message.correlationIds = log.correlationIds();\n        message.clients = log.clients;\n        message.refIds = log.refIds;\n        message.elapsed = log.elapsed;\n        message.action = log.action;\n        message.errorCode = log.errorCode();\n        message.errorMessage = log.errorMessage;\n        message.context = log.context;\n        message.info = log.info;\n        message.stats = log.stats;\n        message.performanceStats = performanceStats(log.performanceStats);\n        if (log.flushTraceLog()) {\n            message.traceLog = log.trace();\n        }\n        return message;\n    }\n\n    private Map<String, PerformanceStatMessage> performanceStats(Map<String, PerformanceStat> stats) {\n        Map<String, PerformanceStatMessage> messages = Maps.newHashMapWithExpectedSize(stats.size());\n        for (Map.Entry<String, PerformanceStat> entry : stats.entrySet()) {\n            PerformanceStat value = entry.getValue();\n            if (value.count == 0) continue;     // for IOWarnings, it may initialize warnings not used by current action (e.g. for executor task action)\n            var message = new PerformanceStatMessage();\n            message.count = value.count;\n            message.totalElapsed = value.totalElapsed;\n            if (value.readEntries != 0) message.readEntries = value.readEntries;\n            if (value.writeEntries != 0) message.writeEntries = value.writeEntries;\n            messages.put(entry.getKey(), message);\n        }\n        return messages;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ConsoleAppender.java."}, {"role": "assistant", "content": "The source code of java class ConsoleAppender.java:\n```java\npackage core.framework.internal.log.appender;\n\nimport core.framework.log.LogAppender;\nimport core.framework.log.message.ActionLogMessage;\nimport core.framework.log.message.PerformanceStatMessage;\nimport core.framework.log.message.StatMessage;\n\nimport java.io.PrintStream;\nimport java.text.DecimalFormat;\nimport java.time.format.DateTimeFormatter;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class ConsoleAppender implements LogAppender {\n    private static final String LOG_SPLITTER = \" | \";\n\n    private final PrintStream stdout = System.out;\n    private final PrintStream stderr = System.err;\n\n    @Override\n    public void append(ActionLogMessage message) {\n        stdout.println(message(message));\n\n        if (message.traceLog != null) {\n            stderr.println(message.traceLog);\n        }\n    }\n\n    @Override\n    public void append(StatMessage message) {\n        stdout.println(message(message));\n    }\n\n    String message(ActionLogMessage log) {\n        var format = new DecimalFormat();   // according to benchmark, create DecimalFormat every time is faster than String.format(\"%.9\", value)\n\n        var builder = new StringBuilder(512);\n        builder.append(DateTimeFormatter.ISO_INSTANT.format(log.date))\n                .append(LOG_SPLITTER).append(log.result)\n                .append(LOG_SPLITTER).append(\"elapsed=\").append(format.format(log.elapsed.longValue()))\n                .append(LOG_SPLITTER).append(\"id=\").append(log.id)\n                .append(LOG_SPLITTER).append(\"action=\").append(log.action);\n\n        if (log.correlationIds != null) {\n            builder.append(LOG_SPLITTER).append(\"correlation_id=\");\n            appendList(builder, log.correlationIds);\n        }\n        String errorCode = log.errorCode;\n        if (errorCode != null) {\n            builder.append(LOG_SPLITTER).append(\"error_code=\").append(errorCode)\n                    .append(LOG_SPLITTER).append(\"error_message=\").append(filterLineSeparator(log.errorMessage));\n        }\n\n        for (Map.Entry<String, List<String>> entry : log.context.entrySet()) {\n            String key = entry.getKey();\n            List<String> values = entry.getValue();\n            for (String value : values) {\n                builder.append(LOG_SPLITTER).append(key).append('=').append(filterLineSeparator(value));\n            }\n        }\n        if (log.clients != null) {\n            builder.append(LOG_SPLITTER).append(\"client=\");\n            appendList(builder, log.clients);\n        }\n        if (log.refIds != null) {\n            builder.append(LOG_SPLITTER).append(\"ref_id=\");\n            appendList(builder, log.refIds);\n        }\n        for (Map.Entry<String, Double> entry : log.stats.entrySet()) {\n            builder.append(LOG_SPLITTER).append(entry.getKey()).append('=').append(format.format(entry.getValue()));\n        }\n        for (Map.Entry<String, PerformanceStatMessage> entry : log.performanceStats.entrySet()) {\n            String key = entry.getKey();\n            PerformanceStatMessage stat = entry.getValue();\n            builder.append(LOG_SPLITTER).append(key).append(\"_count=\").append(stat.count);\n            if (stat.readEntries != null) builder.append(LOG_SPLITTER).append(key).append(\"_reads=\").append(stat.readEntries);\n            if (stat.writeEntries != null) builder.append(LOG_SPLITTER).append(key).append(\"_writes=\").append(stat.writeEntries);\n            builder.append(LOG_SPLITTER).append(key).append(\"_elapsed=\").append(format.format(stat.totalElapsed));\n        }\n        return builder.toString();\n    }\n\n    String message(StatMessage message) {\n        var builder = new StringBuilder(512);\n        builder.append(DateTimeFormatter.ISO_INSTANT.format(message.date))\n                .append(LOG_SPLITTER).append(message.result);\n\n        String errorCode = message.errorCode;\n        if (errorCode != null) {\n            builder.append(LOG_SPLITTER).append(\"error_code=\").append(errorCode)\n                    .append(LOG_SPLITTER).append(\"error_message=\").append(message.errorMessage);\n        }\n\n        var format = new DecimalFormat();\n        for (Map.Entry<String, Double> entry : message.stats.entrySet()) {\n            builder.append(LOG_SPLITTER)\n                    .append(entry.getKey()).append('=')\n                    .append(format.format(entry.getValue()));\n        }\n\n        if (message.info != null) {\n            for (Map.Entry<String, String> entry : message.info.entrySet()) {\n                builder.append(LOG_SPLITTER)\n                        .append(entry.getKey()).append('=')\n                        .append(entry.getValue());\n            }\n        }\n\n        return builder.toString();\n    }\n\n    private void appendList(StringBuilder builder, List<String> items) {\n        int index = 0;\n        for (String item : items) {\n            if (index > 0) builder.append(',');\n            builder.append(item);\n            index++;\n        }\n    }\n\n    String filterLineSeparator(String value) {\n        if (value == null) return \"\";\n        int length = value.length();\n        var builder = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            char ch = value.charAt(i);\n            if (ch == '\\n' || ch == '\\r') builder.append(' ');\n            else builder.append(ch);\n        }\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KafkaAppender.java."}, {"role": "assistant", "content": "The source code of java class KafkaAppender.java:\n```java\npackage core.framework.internal.log.appender;\n\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.kafka.KafkaURI;\nimport core.framework.internal.kafka.ProducerMetrics;\nimport core.framework.log.LogAppender;\nimport core.framework.log.message.ActionLogMessage;\nimport core.framework.log.message.LogTopics;\nimport core.framework.log.message.StatMessage;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Threads;\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class KafkaAppender implements LogAppender {\n    public final ProducerMetrics producerMetrics = new ProducerMetrics(\"log-forwarder\");\n\n    final BlockingQueue<ProducerRecord<byte[], byte[]>> records = new LinkedBlockingQueue<>();\n    private final Logger logger = LoggerFactory.getLogger(KafkaAppender.class);\n    private final Thread logForwarderThread;\n    private final JSONWriter<ActionLogMessage> actionLogWriter = new JSONWriter<>(ActionLogMessage.class);\n    private final JSONWriter<StatMessage> statWriter = new JSONWriter<>(StatMessage.class);\n    private final Callback callback = new KafkaCallback();\n    private final KafkaURI uri;\n\n    private Producer<byte[], byte[]> producer;\n    private volatile boolean stop;\n\n    public KafkaAppender(KafkaURI uri) {\n        this.uri = uri;\n        logForwarderThread = Thread.ofPlatform().name(\"log-forwarder\").unstarted(() -> {\n            logger.info(\"log forwarder thread started, uri={}\", this.uri);\n            initialize();\n            process();\n        });\n    }\n\n    void initialize() {\n        while (!stop) {\n            if (resolveURI(uri)) {\n                producer = createProducer(uri);\n                break;\n            }\n            logger.warn(\"failed to resolve log kafka uri, retry in 10 seconds, uri={}\", this.uri);\n            records.clear();    // throw away records, to prevent from high heap usage\n            Threads.sleepRoughly(Duration.ofSeconds(10));\n        }\n    }\n\n    private void process() {\n        while (!stop) {\n            try {\n                ProducerRecord<byte[], byte[]> record = records.take();\n                producer.send(record, callback);\n            } catch (Throwable e) {\n                if (!stop) {    // if during stop and records.take() is interrupted, not clear records and sleep\n                    logger.warn(\"failed to send log message, retry in 30 seconds\", e);\n                    records.clear();\n                    Threads.sleepRoughly(Duration.ofSeconds(30));\n                }\n            }\n        }\n    }\n\n    KafkaProducer<byte[], byte[]> createProducer(KafkaURI uri) {\n        var watch = new StopWatch();\n        try {\n            Map<String, Object> config = new HashMap<>();                               // 30s, metadata update timeout, shorter than default, to get exception sooner if kafka is not available\n            config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, uri.bootstrapURIs);\n            config.put(ProducerConfig.ACKS_CONFIG, \"0\");                                // no acknowledge to maximize performance\n            config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, Boolean.FALSE);        // since kafka 3.0.0, \"enable.idempotence\" is true by default, and it overrides \"acks\" to all\n            config.put(ProducerConfig.CLIENT_ID_CONFIG, \"log-forwarder\");               // if not specify, kafka uses producer-${seq} name, also impact jmx naming\n            config.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, CompressionType.SNAPPY.name);\n            config.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG, 60_000);              // 60s, type is INT\n            config.put(ProducerConfig.LINGER_MS_CONFIG, 50L);\n            config.put(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, 500L);               // longer backoff to reduce cpu usage when kafka is not available\n            config.put(ProducerConfig.RECONNECT_BACKOFF_MAX_MS_CONFIG, 5_000L);         // 5s\n            config.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 30_000L);\n            config.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, 2_097_152);              // 2M, 1024*1024*2, kafka producer checks uncompressed request size, but with snappy, it is generally ok to send larger value, compression ratio is 1.5x~1.7x\n            var serializer = new ByteArraySerializer();\n            var producer = new KafkaProducer<>(config, serializer, serializer);\n            producerMetrics.set(producer.metrics());\n            return producer;\n        } finally {\n            logger.info(\"create kafka log producer, uri={}, elapsed={}\", uri, watch.elapsed());\n        }\n    }\n\n    @Override\n    public void append(ActionLogMessage message) {\n        byte[] value = actionLogWriter.toJSON(message);\n\n        // refer to org.apache.kafka.common.record.DefaultRecordBatch.estimateBatchSizeUpperBound\n        // overhead is 88 + valueSize\n        if (value.length > 2_000_000) {\n            logger.warn(errorCode(\"LOG_TOO_LARGE\"), \"action log message is too large, size={}, id={}, action={}\", value.length, message.id, message.action);\n            new ConsoleAppender().append(message);  // fall back to console appender to print\n\n            truncate(message, value.length - 2_000_000, 10_000);\n            value = actionLogWriter.toJSON(message);    // the value length is supposed to be less than 2_000_000, since json escapes '\\n' as 2 chars, but in trace string it's one char\n        }\n\n        // not specify message key for sticky partition, StickyPartitionCache will be used if key is null\n        // refer to org.apache.kafka.clients.producer.internals.DefaultPartitioner.partition\n        records.add(new ProducerRecord<>(LogTopics.TOPIC_ACTION_LOG, value));\n    }\n\n    @Override\n    public void append(StatMessage message) {\n        records.add(new ProducerRecord<>(LogTopics.TOPIC_STAT, statWriter.toJSON(message)));    // not specify message key for sticky partition\n    }\n\n    // during startup, if it encounters configuration runtime error, logForwarderThread won't start as all startup tasks will be skipped,\n    // but the failed_to_start action/trace will still be forwarded in stop() in shutdown hook\n    public void start() {\n        logForwarderThread.start();\n    }\n\n    public void stop(long timeoutInMs) {\n        logger.info(\"stop log forwarder\");\n        stop = true;\n        logForwarderThread.interrupt();\n\n        if (producer == null && resolveURI(uri)) producer = createProducer(uri);           // producer can be null if app failed to start (exception thrown by configure(), startup hook will not run)\n        if (producer != null) {                                         // producer can be null if uri is not resolved\n            for (ProducerRecord<byte[], byte[]> record : records) {     // if log-kafka is not available, here will block MAX_BLOCK_MS, to simplify it's ok not handling timeout since kafka appender is at end of shutdown, no more critical resources left to handle\n                producer.send(record);\n            }\n            producer.close(Duration.ofMillis(timeoutInMs));\n        }\n    }\n\n    // traceLog string length can be much smaller than json bytes size,\n    // since json encodes some chars into 2 bytes, e.g. \\n, '\"',\n    // if traceLog contains many of them like logs contains json string, it may over truncates\n    // in worst case, minTraceLength will be kept\n    void truncate(ActionLogMessage message, int overflow, int minTraceLength) {\n        // clear all large context\n        message.context.entrySet().removeIf(entry -> entry.getValue().size() > 10);\n        if (message.traceLog != null) {\n            int traceLength = message.traceLog.length();\n            // leave trace at least minTraceLength chars, if large context is removed, trace log most likely has enough room\n            int endIndex = Math.max(traceLength - overflow, minTraceLength);\n            String warning = \"...(hard trace limit reached, please check console log for full trace)\";\n            if (endIndex + warning.length() < traceLength) {\n                message.traceLog = message.traceLog.substring(0, endIndex) + warning;\n            }\n        }\n    }\n\n    boolean resolveURI(KafkaURI kafkaURI) {\n        for (String uri : kafkaURI.bootstrapURIs) {\n            int index = uri.indexOf(':');\n            if (index == -1) throw new Error(\"invalid kafka uri, uri=\" + uri);\n            String host = uri.substring(0, index);\n            var address = new InetSocketAddress(host, 9092);\n            if (!address.isUnresolved()) {\n                return true;    // break if any uri is resolvable\n            }\n        }\n        return false;\n    }\n\n    // pmd has flaws to check slf4j log format with lambda, even with https://github.com/pmd/pmd/pull/2263, it fails to analyze logger in lambda+if condition block\n    // so here use inner class as workaround\n    class KafkaCallback implements Callback {\n        @Override\n        public void onCompletion(RecordMetadata metadata, Exception exception) {\n            if (exception != null) {\n                logger.warn(\"failed to send log message\", exception);\n                records.clear();\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CollectStatTask.java."}, {"role": "assistant", "content": "The source code of java class CollectStatTask.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.internal.stat.StatCollector;\nimport core.framework.internal.stat.Stats;\nimport core.framework.log.LogAppender;\nimport core.framework.log.message.StatMessage;\nimport core.framework.util.Network;\n\nimport java.time.Instant;\n\n/**\n * @author neo\n */\npublic final class CollectStatTask implements Runnable {\n    private final LogAppender appender;\n    private final StatCollector collector;\n    private int count;\n\n    public CollectStatTask(LogAppender appender, StatCollector collector) {\n        this.appender = appender;\n        this.collector = collector;\n    }\n\n    @Override\n    public void run() {\n        var stats = new Stats();\n        collector.collectJVMUsage(stats);\n        collector.collectMetrics(stats);\n        if (count % 6 == 0) {   // every 60s\n            collector.collectMemoryUsage(stats);\n        }\n        count++;\n        StatMessage message = message(stats);\n        appender.append(message);\n    }\n\n    StatMessage message(Stats stats) {\n        var message = new StatMessage();\n        var now = Instant.now();\n        message.date = now;\n        message.id = LogManager.ID_GENERATOR.next(now);\n        message.result = stats.result();\n        message.app = LogManager.APP_NAME;\n        message.host = Network.LOCAL_HOST_NAME;\n        message.errorCode = stats.errorCode;\n        message.errorMessage = stats.errorMessage;\n        message.stats = stats.stats;\n        message.info = stats.info;\n        return message;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DefaultLoggerFactory.java."}, {"role": "assistant", "content": "The source code of java class DefaultLoggerFactory.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.util.Maps;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.Logger;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class DefaultLoggerFactory implements ILoggerFactory {\n    private final Map<String, Logger> loggers = Maps.newConcurrentHashMap();\n\n    @Override\n    public Logger getLogger(String name) {\n        return loggers.computeIfAbsent(name, this::createLogger);\n    }\n\n    private Logger createLogger(String name) {\n        return new LoggerImpl(name, infoLevel(name), traceLevel(name));\n    }\n\n    private LogLevel infoLevel(String name) {\n        // kafka log info for every producer/consumer, to reduce verbosity\n        if (\"org.apache.kafka.clients.consumer.ConsumerConfig\".equals(name)\n                || \"org.apache.kafka.clients.producer.ProducerConfig\".equals(name)\n                || \"org.apache.kafka.clients.admin.AdminClientConfig\".equals(name)\n                || \"org.apache.kafka.common.utils.AppInfoParser\".equals(name)) {\n            return LogLevel.WARN;\n        }\n        return LogLevel.INFO;\n    }\n\n    private LogLevel traceLevel(String name) {\n        if (name.startsWith(\"org.elasticsearch\")\n            || name.startsWith(\"org.mongodb\")\n            || name.startsWith(\"org.xnio\")) {\n            return LogLevel.INFO;\n        }\n        return LogLevel.DEBUG;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DefaultLoggerServiceProvider.java."}, {"role": "assistant", "content": "The source code of java class DefaultLoggerServiceProvider.java:\n```java\npackage core.framework.internal.log;\n\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.IMarkerFactory;\nimport org.slf4j.helpers.BasicMarkerFactory;\nimport org.slf4j.helpers.NOPMDCAdapter;\nimport org.slf4j.spi.MDCAdapter;\nimport org.slf4j.spi.SLF4JServiceProvider;\n\n/**\n * @author neo\n */\npublic class DefaultLoggerServiceProvider implements SLF4JServiceProvider {\n    private ILoggerFactory loggerFactory;\n    private IMarkerFactory markerFactory;\n    private MDCAdapter mdcAdapter;\n\n    @Override\n    public ILoggerFactory getLoggerFactory() {\n        return loggerFactory;\n    }\n\n    @Override\n    public IMarkerFactory getMarkerFactory() {\n        return markerFactory;\n    }\n\n    @Override\n    public MDCAdapter getMDCAdapter() {\n        return mdcAdapter;\n    }\n\n    @Override\n    public String getRequestedApiVersion() {\n        return \"2.0.99\";\n    }\n\n    @Override\n    public void initialize() {\n        loggerFactory = new DefaultLoggerFactory();\n        markerFactory = new BasicMarkerFactory();\n        mdcAdapter = new NOPMDCAdapter();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ArrayLogParam.java."}, {"role": "assistant", "content": "The source code of java class ArrayLogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class ArrayLogParam implements LogParam {\n    private final String[] values;\n\n    public ArrayLogParam(String... values) {\n        this.values = values;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        LogParamHelper.append(builder, values, maxParamLength);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BytesLogParam.java."}, {"role": "assistant", "content": "The source code of java class BytesLogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport core.framework.util.Strings;\n\nimport java.nio.charset.Charset;\nimport java.util.Set;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic class BytesLogParam implements LogParam {    // for text based value, detect if in json format, and mask if needed\n    private final byte[] bytes;\n    private final Charset charset;\n\n    public BytesLogParam(byte[] bytes) {\n        this(bytes, UTF_8);\n    }\n\n    public BytesLogParam(byte[] bytes, Charset charset) {\n        this.bytes = bytes;\n        this.charset = charset;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        if (bytes == null) {\n            builder.append(\"null\");\n            return;\n        }\n\n        boolean truncate = false;\n        String value;\n        if (bytes.length > maxParamLength) {\n            value = new String(bytes, 0, maxParamLength, charset);\n            truncate = true;\n        } else {\n            value = new String(bytes, charset);\n        }\n        if (shouldMask(value, maskedFields)) {\n            builder.append(filter(value, maskedFields));\n        } else {\n            if (truncate) {\n                builder.append(value, 0, value.length() - 1);\n            } else {\n                builder.append(value);\n            }\n        }\n        if (truncate) {\n            builder.append(\"...(truncated)\");\n        }\n    }\n\n    StringBuilder filter(String value, Set<String> maskedFields) {\n        var builder = new StringBuilder(value);\n        for (String maskedField : maskedFields) {\n            int current = -1;\n            while (true) {\n                current = builder.indexOf('\\\"' + maskedField + '\\\"', current);\n                if (current < 0) break;\n                int[] range = maskRange(builder, current + maskedField.length() + 2);    // start from last double quote\n                if (range == null) break;\n                builder.replace(range[0], range[1], \"******\");      // with benchmark, StringBuilder.replace is the fastest way to mask substring\n                current = range[1];\n            }\n        }\n        return builder;\n    }\n\n    // find first json \"string\" range from start, only mask string field value, ignore if target field value is list or object\n    private int[] maskRange(StringBuilder builder, int start) {\n        boolean escaped = false;\n        int maskStart = -1;\n        int length = builder.length();\n        for (int index = start; index < length; index++) {\n            char ch = builder.charAt(index);\n            if (ch == '\\\\') {\n                escaped = true;\n            } else if (!escaped && maskStart < 0 && ch == '\\\"') {\n                maskStart = index + 1;\n            } else if (!escaped && maskStart >= 0 && ch == '\\\"') {\n                return new int[]{maskStart, index};\n            } else if (maskStart < 0 && (ch == ',' || ch == '{' || ch == '}' || ch == '[' || ch == ']')) {\n                return null;    // not found start double quote, and reached next field\n            } else {\n                escaped = false;\n            }\n        }\n        if (maskStart >= 0) return new int[]{maskStart, length};  // json can be truncated, mask rest if found start quote\n        return null;\n    }\n\n    private boolean shouldMask(String value, Set<String> maskedFields) {\n        // only consider json string starts with '{', ignore other rare cases like array starts with '['\n        if (!Strings.startsWith(value, '{')) return false;\n        for (String maskedField : maskedFields) {\n            int index = value.indexOf('\\\"' + maskedField + '\\\"');\n            if (index >= 0) return true;\n        }\n        return false;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BytesMapLogParam.java."}, {"role": "assistant", "content": "The source code of java class BytesMapLogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic class BytesMapLogParam implements LogParam {\n    private final Map<String, byte[]> values;\n\n    public BytesMapLogParam(Map<String, byte[]> values) {\n        this.values = values;\n    }\n\n    // not masking the bytes values, thought it can be in json format\n    // currently sensitive info won't be handled in batch via cache/redis, so not to add unnecessary overhead\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        int maxLength = builder.length() + maxParamLength;\n        builder.append('{');\n        int index = 0;\n        for (Map.Entry<String, byte[]> entry : values.entrySet()) {\n            if (index > 0) builder.append(\", \");\n            builder.append(entry.getKey())\n                    .append('=')\n                    .append(new String(entry.getValue(), UTF_8));\n\n            if (builder.length() > maxLength) {\n                builder.setLength(maxLength);\n                builder.append(\"...(truncated)\");\n                return;\n            }\n\n            index++;\n        }\n        builder.append('}');\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FieldLogParam.java."}, {"role": "assistant", "content": "The source code of java class FieldLogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class FieldLogParam implements LogParam {\n    private final String field;\n    private final String value;\n\n    public FieldLogParam(String field, String value) {\n        this.field = field;\n        this.value = value;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        if (maskedFields.contains(field)) {\n            builder.append(\"******\");\n        } else {\n            LogParamHelper.append(builder, value, maxParamLength);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FieldMapLogParam.java."}, {"role": "assistant", "content": "The source code of java class FieldMapLogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class FieldMapLogParam implements LogParam {\n    private final Map<String, String> values;\n\n    // used for field based map, and mask based on field, not value (e.g. value in json format)\n    public FieldMapLogParam(Map<String, String> values) {\n        this.values = values;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        int maxLength = builder.length() + maxParamLength;\n        builder.append('{');\n        int index = 0;\n        for (Map.Entry<String, String> entry : values.entrySet()) {\n            if (index > 0) builder.append(\", \");\n            String key = entry.getKey();\n            builder.append(key).append('=');\n\n            if (maskedFields.contains(key)) builder.append(\"******\");\n            else builder.append(entry.getValue());\n\n            if (builder.length() > maxLength) {\n                builder.setLength(maxLength);\n                builder.append(\"...(truncated)\");\n                return;\n            }\n\n            index++;\n        }\n        builder.append('}');\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogFilter.java."}, {"role": "assistant", "content": "The source code of java class LogFilter.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport core.framework.util.Sets;\n\nimport java.util.Arrays;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class LogFilter {\n    private static final int MAX_PARAM_LENGTH = 10000; // limit long param string to 10k\n    public final Set<String> maskedFields = Sets.newHashSet();\n\n    public void append(StringBuilder builder, String message, Object... arguments) {\n        if (message == null || arguments == null) {\n            builder.append(message);\n            return;\n        }\n        int position = 0;\n        for (Object argument : arguments) {\n            int index = message.indexOf(\"{}\", position);\n            if (index == -1) {\n                builder.append(message, position, message.length());    // there are more arguments than count of \"{}\"\n                return;\n            } else {\n                builder.append(message, position, index);\n                appendArgument(builder, argument);\n                position = index + 2;\n            }\n        }\n        if (position < message.length()) {\n            builder.append(message, position, message.length());\n        }\n    }\n\n    private void appendArgument(StringBuilder builder, Object argument) {\n        if (argument == null) {\n            builder.append(\"null\");\n            return;\n        }\n        // for performance reason, truncation will be handled by each type of LogParam, to best fit each specific cases\n        if (argument instanceof LogParam logParam) {\n            logParam.append(builder, maskedFields, MAX_PARAM_LENGTH);\n            return;\n        }\n        appendRawArgument(builder, argument, MAX_PARAM_LENGTH);\n    }\n\n    void appendRawArgument(StringBuilder builder, Object argument, int maxLength) {\n        String value;\n        if (argument.getClass().isArray()) {\n            value = arrayArgument(argument);\n        } else {\n            value = String.valueOf(argument);\n        }\n        LogParamHelper.append(builder, value, maxLength);\n    }\n\n    private String arrayArgument(Object argument) {\n        return switch (argument) {\n            case final Object[] value -> Arrays.toString(value);\n            case final int[] value -> Arrays.toString(value);\n            case final long[] value -> Arrays.toString(value);\n            case final char[] value -> Arrays.toString(value);\n            case final double[] value -> Arrays.toString(value);\n            case final byte[] value -> Arrays.toString(value);\n            case final boolean[] value -> Arrays.toString(value);\n            case final float[] value -> Arrays.toString(value);\n            case final short[] value -> Arrays.toString(value);\n            case null -> \"null\";\n            default -> throw new Error(\"unexpected argument, argument=\" + argument);\n        };\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogParam.java."}, {"role": "assistant", "content": "The source code of java class LogParam.java:\n```java\npackage core.framework.internal.log.filter;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic interface LogParam {\n    void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogParamHelper.java."}, {"role": "assistant", "content": "The source code of java class LogParamHelper.java:\n```java\npackage core.framework.internal.log.filter;\n\n/**\n * @author neo\n */\npublic class LogParamHelper {\n    public static void append(StringBuilder builder, String value, int maxLength) {\n        if (value.length() > maxLength) {\n            builder.append(value, 0, maxLength);\n            builder.append(\"...(truncated)\");\n        } else {\n            builder.append(value);\n        }\n    }\n\n    public static void append(StringBuilder builder, String[] values, int maxLength) {\n        int totalMaxLength = builder.length() + maxLength;\n        builder.append('[');\n        for (int i = 0; i < values.length; i++) {\n            String value = values[i];\n            if (i > 0) builder.append(\", \");\n            builder.append(value);\n\n            if (builder.length() > totalMaxLength) {\n                builder.setLength(totalMaxLength);\n                builder.append(\"...(truncated)\");\n                return;\n            }\n        }\n        builder.append(']');\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class IdGenerator.java."}, {"role": "assistant", "content": "The source code of java class IdGenerator.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.util.Encodings;\n\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.time.Instant;\nimport java.util.Enumeration;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * @author neo\n */\npublic class IdGenerator {\n    private static final int LOW_ORDER_THREE_BYTES = 0xFFFFFF;\n\n    private final AtomicInteger counter = new AtomicInteger(ThreadLocalRandom.current().nextInt());\n    private final int machineIdentifier = machineIdentifier() & LOW_ORDER_THREE_BYTES;\n\n    private int machineIdentifier() {\n        try {\n            var builder = new StringBuilder();\n            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();\n            while (networkInterfaces.hasMoreElements()) {\n                NetworkInterface networkInterface = networkInterfaces.nextElement();\n                builder.append(networkInterface.getName());\n                byte[] mac = networkInterface.getHardwareAddress();\n                if (mac != null) builder.append(Encodings.hex(mac));\n            }\n            builder.append(ThreadLocalRandom.current().nextInt());  // append random value in case multiple apps run on same server (which is highly unlikely with cloud/kube env)\n            return builder.toString().hashCode();\n        } catch (SocketException e) {\n            throw new Error(e);\n        }\n    }\n\n    // action id doesn't need strict uniqueness as UUID, here to generate shorter and more elasticsearch/lucene friendly id\n    public String next(Instant now) {\n        long time = now.toEpochMilli();\n        int counter = this.counter.getAndIncrement() & LOW_ORDER_THREE_BYTES;\n        byte[] bytes = new byte[10];\n        bytes[0] = (byte) (time >> 32);     // save 5 bytes time in ms, about 34 years value space\n        bytes[1] = (byte) (time >> 24);\n        bytes[2] = (byte) (time >> 16);\n        bytes[3] = (byte) (time >> 8);\n        bytes[4] = (byte) time;\n        bytes[5] = (byte) (machineIdentifier >> 16);   // 3 bytes as machine id, about 16M value space\n        bytes[6] = (byte) (machineIdentifier >> 8);\n        bytes[7] = (byte) machineIdentifier;\n        bytes[8] = (byte) (counter >> 8);               // 2 bytes for max 65k actions per ms per server\n        bytes[9] = (byte) counter;\n        return Encodings.hex(bytes);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogEvent.java."}, {"role": "assistant", "content": "The source code of java class LogEvent.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.internal.log.marker.ErrorCodeMarker;\nimport core.framework.util.Exceptions;\nimport core.framework.util.Network;\nimport org.slf4j.Marker;\n\nimport javax.annotation.Nullable;\nimport java.time.Instant;\nimport java.time.format.DateTimeFormatter;\n\n/**\n * @author neo\n */\nfinal class LogEvent {\n    final LogLevel level;\n\n    private final long time = System.nanoTime();\n    private final String logger;\n    private final Marker marker;\n    private final String message;\n    private final Object[] arguments;\n    private final Throwable exception;\n\n    LogEvent(String logger, Marker marker, LogLevel level, String message, Object[] arguments, Throwable exception) {\n        this.logger = logger;\n        this.marker = marker;\n        this.level = level;\n        this.message = message;\n        this.arguments = arguments;\n        this.exception = exception;\n    }\n\n    String message() {  // only be called for error message\n        if (arguments == null || arguments.length == 0) return message;     // most case, message is from exception, and without no arguments\n\n        var builder = new StringBuilder(256);\n        LogManager.FILTER.append(builder, message, arguments);\n        return builder.toString();\n    }\n\n    @Nullable\n    String errorCode() {\n        if (marker instanceof ErrorCodeMarker) return marker.getName();\n        return null;\n    }\n\n    String info() {\n        var now = Instant.now();\n        var builder = new StringBuilder(256);\n        builder.append(DateTimeFormatter.ISO_INSTANT.format(now))\n            .append(\" [\").append(Network.LOCAL_HOST_NAME).append(\"] [\").append(Thread.currentThread().getName()).append(\"] \")\n            .append(level.name())\n            .append(' ')\n            .append(logger)\n            .append(\" - \");\n        if (marker != null) builder.append('[').append(marker.getName()).append(\"] \");\n        LogManager.FILTER.append(builder, message, arguments);\n        builder.append(System.lineSeparator());\n        if (exception != null) builder.append(Exceptions.stackTrace(exception));\n        return builder.toString();\n    }\n\n    void appendTrace(StringBuilder builder, long startTime) {\n        appendDuration(builder, time - startTime);\n        builder.append(' ');\n        if (level != LogLevel.DEBUG) builder.append(level.name()).append(' ');\n        builder.append(logger).append(\" - \");\n        if (marker != null) builder.append('[').append(marker.getName()).append(\"] \");\n        LogManager.FILTER.append(builder, message, arguments);\n        builder.append(System.lineSeparator());\n        if (exception != null) builder.append(Exceptions.stackTrace(exception));\n    }\n\n    void appendDuration(StringBuilder builder, long durationInNanos) {\n        long seconds = durationInNanos / 1000000000;\n\n        String minutePart = String.valueOf(seconds / 60);\n        if (minutePart.length() < 2) builder.append('0');\n        builder.append(minutePart).append(':');\n\n        String secondPart = String.valueOf(seconds % 60);\n        if (secondPart.length() < 2) builder.append('0');\n        builder.append(secondPart).append('.');\n\n        String nanoPart = String.valueOf(durationInNanos % 1000000000);\n        int padding = 9 - nanoPart.length();\n        for (int i = 0; i < padding; i++) {\n            builder.append('0');\n        }\n        builder.append(nanoPart);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LoggerImpl.java."}, {"role": "assistant", "content": "The source code of java class LoggerImpl.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.util.Strings;\nimport org.slf4j.Marker;\n\nimport java.io.PrintStream;\n\n/**\n * @author neo\n */\npublic final class LoggerImpl extends AbstractLogger {\n    private static final PrintStream STDOUT = System.out;\n    private static final PrintStream STDERR = System.err;\n\n    static String abbreviateLoggerName(String name) {\n        String[] tokens = Strings.split(name, '.');\n        var builder = new StringBuilder();\n        int abbrCount = tokens.length <= 4 ? tokens.length - 1 : tokens.length - 2;\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            if (i > 0) builder.append('.');\n            if (i < abbrCount && !token.isEmpty()) {\n                builder.append(token.charAt(0));\n            } else {\n                builder.append(token);\n            }\n        }\n        return builder.toString();\n    }\n\n    private final LogLevel infoLevel;\n    private final LogLevel traceLevel;\n\n    LoggerImpl(String name, LogLevel infoLevel, LogLevel traceLevel) {\n        super(abbreviateLoggerName(name));\n        this.infoLevel = infoLevel;\n        this.traceLevel = traceLevel;\n    }\n\n    @Override\n    public void log(Marker marker, LogLevel level, String message, Object[] arguments, Throwable exception) {\n        if (level.value >= traceLevel.value) {\n            var event = new LogEvent(name, marker, level, message, arguments, exception);\n\n            ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n            if (actionLog != null) actionLog.process(event);    // logManager.begin() may not be called\n\n            if (level.value >= infoLevel.value) {\n                write(event);\n            }\n        }\n    }\n\n    private void write(LogEvent event) {\n        String message = event.info();\n        if (event.level.value >= LogLevel.WARN.value)\n            STDERR.print(message);\n        else\n            STDOUT.print(message);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogLevel.java."}, {"role": "assistant", "content": "The source code of java class LogLevel.java:\n```java\npackage core.framework.internal.log;\n\n/**\n * @author neo\n */\npublic enum LogLevel {\n    ERROR(4), WARN(3), INFO(2), DEBUG(1);\n\n    final int value;\n\n    LogLevel(int value) {\n        this.value = value;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LogManager.java."}, {"role": "assistant", "content": "The source code of java class LogManager.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.internal.log.filter.LogFilter;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.LogAppender;\nimport core.framework.log.Markers;\nimport core.framework.log.Severity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.Marker;\n\nimport java.util.Collections;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class LogManager {\n    public static final ThreadLocal<ActionLog> CURRENT_ACTION_LOG = new ThreadLocal<>();\n    public static final String APP_NAME;\n\n    public static final IdGenerator ID_GENERATOR = new IdGenerator();\n    static final LogFilter FILTER = new LogFilter();\n    private static final Logger LOGGER = LoggerFactory.getLogger(LogManager.class);\n\n    static {\n        APP_NAME = appName(System.getenv());\n    }\n\n    static String appName(Map<String, String> env) {\n        // gradle application plugin linux script uses APP_NAME as variable which shadowed env variable, so here to use different name\n        // refer to https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\n        String appName = env.get(\"CORE_APP_NAME\");\n        if (appName != null) {\n            LOGGER.info(\"found CORE_APP_NAME env var, appName={}\", appName);\n            return appName;\n        }\n        appName = System.getProperty(\"core.appName\");\n        if (appName == null) {\n            LOGGER.info(\"not found -Dcore.appName, this should only happen in local dev env or test, use \\\"local\\\" as appName\");\n            appName = \"local\";\n        }\n        return appName;\n    }\n\n    private final ActionLogMessageFactory actionLogMessageFactory = new ActionLogMessageFactory();\n    public LogAppender appender;\n\n    public ActionLog begin(String message, String id) {\n        var actionLog = new ActionLog(message, id);\n        CURRENT_ACTION_LOG.set(actionLog);\n        return actionLog;\n    }\n\n    public void end(String message) {\n        ActionLog actionLog = CURRENT_ACTION_LOG.get();\n        actionLog.end(message);\n        CURRENT_ACTION_LOG.remove();    // actionLog.end(message) may produce more logs\n\n        if (appender != null) {\n            try {\n                appender.append(actionLogMessageFactory.create(actionLog));\n            } catch (Throwable e) {\n                LOGGER.warn(\"failed to append action log, error={}\", e.getMessage(), e);\n            }\n        }\n    }\n\n    public void logError(Throwable e) {\n        String errorMessage = e.getMessage();\n        Marker marker = Markers.errorCode(errorCode(e));\n        if (e instanceof ErrorCode errorCode && errorCode.severity() == Severity.WARN) {\n            LOGGER.warn(marker, errorMessage, e);\n        } else {\n            LOGGER.error(marker, errorMessage, e);\n        }\n    }\n\n    String errorCode(Throwable e) {\n        return e instanceof ErrorCode errorCode ? errorCode.errorCode() : e.getClass().getCanonicalName();\n    }\n\n    public void maskFields(String... fields) {\n        Collections.addAll(FILTER.maskedFields, fields);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class AbstractMarker.java."}, {"role": "assistant", "content": "The source code of java class AbstractMarker.java:\n```java\npackage core.framework.internal.log.marker;\n\nimport org.slf4j.Marker;\n\nimport java.io.Serial;\nimport java.util.Iterator;\n\n/**\n * @author neo\n */\npublic abstract class AbstractMarker implements Marker {\n    @Serial\n    private static final long serialVersionUID = 8406894019332263130L;\n\n    @Override\n    public void add(Marker reference) {\n    }\n\n    @Override\n    public boolean remove(Marker reference) {\n        return false;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public boolean hasChildren() {\n        return false;\n    }\n\n    @Override\n    public boolean hasReferences() {\n        return false;\n    }\n\n    @Override\n    public Iterator<Marker> iterator() {\n        return null;\n    }\n\n    @Override\n    public boolean contains(Marker other) {\n        return false;\n    }\n\n    @Override\n    public boolean contains(String name) {\n        return false;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ErrorCodeMarker.java."}, {"role": "assistant", "content": "The source code of java class ErrorCodeMarker.java:\n```java\npackage core.framework.internal.log.marker;\n\n/**\n * @author neo\n */\npublic final class ErrorCodeMarker extends AbstractMarker {\n    private static final long serialVersionUID = 2633013025655449295L;\n\n    private final String code;\n\n    public ErrorCodeMarker(String code) {\n        this.code = code;\n    }\n\n    @Override\n    public String getName() {\n        return code;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PerformanceStat.java."}, {"role": "assistant", "content": "The source code of java class PerformanceStat.java:\n```java\npackage core.framework.internal.log;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\n\nimport static core.framework.log.Markers.errorCode;\nimport static core.framework.util.ASCII.toUpperCase;\n\n/**\n * @author neo\n */\nclass PerformanceStat {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PerformanceStat.class);\n    @Nullable\n    final PerformanceWarning warning;\n\n    int count;\n    long totalElapsed;\n    int readEntries;\n    int writeEntries;\n\n    PerformanceStat(@Nullable PerformanceWarning warning) {\n        this.warning = warning;\n    }\n\n    void track(long elapsed, int readEntries, int writeEntries) {\n        count += 1;\n        totalElapsed += elapsed;\n        this.readEntries += readEntries;\n        this.writeEntries += writeEntries;\n\n        checkSingleIO(elapsed, readEntries);\n    }\n\n    void checkSingleIO(long elapsed, int readEntries) {\n        if (warning == null) return;\n\n        if (warning.maxReads > 0 && readEntries > warning.maxReads) {\n            LOGGER.warn(errorCode(\"HIGH_\" + toUpperCase(warning.operation) + \"_IO\"), \"read too many entries once, operation={}, entries={}\", warning.operation, readEntries);\n        }\n        if (warning.maxElapsed > 0 && elapsed > warning.maxElapsed) {\n            LOGGER.warn(errorCode(\"SLOW_\" + toUpperCase(warning.operation)), \"slow operation, operation={}, elapsed={}\", warning.operation, Duration.ofNanos(elapsed));\n        }\n    }\n\n    void checkTotalIO() {\n        if (warning == null) return;\n\n        if (warning.maxOperations > 0 && count > warning.maxOperations) {\n            LOGGER.warn(errorCode(\"HIGH_\" + toUpperCase(warning.operation) + \"_IO\"), \"too many operations, operation={}, count={}\", warning.operation, count);\n        }\n        if (warning.maxTotalReads > 0 && readEntries > warning.maxTotalReads) {\n            LOGGER.warn(errorCode(\"HIGH_\" + toUpperCase(warning.operation) + \"_IO\"), \"read too many entries, operation={}, entries={}\", warning.operation, readEntries);\n        }\n        if (warning.maxTotalWrites > 0 && writeEntries > warning.maxTotalWrites) {\n            LOGGER.warn(errorCode(\"HIGH_\" + toUpperCase(warning.operation) + \"_IO\"), \"write too many entries, operation={}, entries={}\", warning.operation, writeEntries);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PerformanceWarning.java."}, {"role": "assistant", "content": "The source code of java class PerformanceWarning.java:\n```java\npackage core.framework.internal.log;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class PerformanceWarning {\n    public final String operation;\n    public final int maxOperations;\n    public final long maxElapsed;\n    public final int maxReads;\n    public final int maxTotalReads;\n    public final int maxTotalWrites;\n\n    public PerformanceWarning(String operation, int maxOperations, Duration maxElapsed, int maxReads, int maxTotalReads, int maxTotalWrites) {\n        this.operation = operation;\n        this.maxOperations = maxOperations;\n        this.maxElapsed = maxElapsed == null ? -1 : maxElapsed.toNanos();\n        this.maxReads = maxReads;\n        this.maxTotalReads = maxTotalReads;\n        this.maxTotalWrites = maxTotalWrites;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Trace.java."}, {"role": "assistant", "content": "The source code of java class Trace.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.util.ASCII;\n\n/**\n * @author neo\n */\npublic enum Trace {\n    CURRENT,       // only trace current action\n    CASCADE,    // trace all correlated actions\n    NONE;\n\n    // the value come from external client like browser / script, to be compatible with lower/upper cases, true/false values\n    public static Trace parse(String value) {\n        String valueInLowerCase = ASCII.toLowerCase(value);\n        if (valueInLowerCase == null || \"false\".equals(valueInLowerCase) || \"none\".equals(valueInLowerCase)) return NONE;\n        if (\"cascade\".equals(valueInLowerCase)) return CASCADE;\n        return CURRENT;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WarningContext.java."}, {"role": "assistant", "content": "The source code of java class WarningContext.java:\n```java\npackage core.framework.internal.log;\n\nimport core.framework.log.IOWarning;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Duration;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class WarningContext {\n    private static final Logger LOGGER = LoggerFactory.getLogger(WarningContext.class);\n    // use static constant mapping for both performance and simplicity\n    private static final PerformanceWarning[] DEFAULT_WARNINGS = {\n        new PerformanceWarning(\"db\", 2000, Duration.ofSeconds(5), 2000, 10_000, 10_000),\n        new PerformanceWarning(\"redis\", 2000, Duration.ofMillis(500), 1000, 10_000, 10_000),\n        new PerformanceWarning(\"elasticsearch\", 2000, Duration.ofSeconds(5), 2000, 10_000, 10_000),\n        new PerformanceWarning(\"mongo\", 2000, Duration.ofSeconds(5), 2000, 10_000, 10_000)\n    };\n\n    @Nullable\n    public static PerformanceWarning[] warnings(IOWarning[] warnings) {\n        if (warnings.length == 0) return null;\n\n        var results = new PerformanceWarning[warnings.length];\n        for (int i = 0; i < warnings.length; i++) {\n            IOWarning warning = warnings[i];\n            String operation = warning.operation();\n            PerformanceWarning defaultWarning = defaultWarning(operation);\n\n            int maxOperations = warning.maxOperations();\n            if (maxOperations < 0 && defaultWarning != null) maxOperations = defaultWarning.maxOperations;\n\n            Duration maxElapsed = null;\n            if (warning.maxElapsedInMs() > 0) maxElapsed = Duration.ofMillis(warning.maxElapsedInMs());\n            if (maxElapsed == null && defaultWarning != null && defaultWarning.maxElapsed > 0) maxElapsed = Duration.ofNanos(defaultWarning.maxElapsed);\n\n            int maxReads = warning.maxReads();\n            if (maxReads < 0 && defaultWarning != null) maxReads = defaultWarning.maxReads;\n\n            int maxTotalReads = warning.maxTotalReads();\n            if (maxTotalReads < 0 && defaultWarning != null) maxTotalReads = defaultWarning.maxTotalReads;\n\n            int maxTotalWrites = warning.maxTotalWrites();\n            if (maxTotalWrites < 0 && defaultWarning != null) maxTotalWrites = defaultWarning.maxTotalWrites;\n\n            results[i] = new PerformanceWarning(operation, maxOperations, maxElapsed, maxReads, maxTotalReads, maxTotalWrites);\n        }\n        return results;\n    }\n\n    static PerformanceWarning defaultWarning(String operation) {\n        return switch (operation) {\n            case \"db\" -> DEFAULT_WARNINGS[0];\n            case \"redis\" -> DEFAULT_WARNINGS[1];\n            case \"elasticsearch\" -> DEFAULT_WARNINGS[2];\n            case \"mongo\" -> DEFAULT_WARNINGS[3];\n            default -> null;\n        };\n    }\n\n    public boolean suppressSlowSQLWarning;\n    long maxProcessTimeInNano;\n\n    public void maxProcessTimeInNano(long maxProcessTimeInNano) {\n        this.maxProcessTimeInNano = maxProcessTimeInNano;\n        LOGGER.debug(\"maxProcessTime={}\", maxProcessTimeInNano);\n    }\n\n    public void checkMaxProcessTime(long elapsed) {\n        if (maxProcessTimeInNano > 0 && elapsed > maxProcessTimeInNano) {\n            LOGGER.warn(errorCode(\"SLOW_PROCESS\"), \"action took longer than of max process time, maxProcessTime={}, elapsed={}\", Duration.ofNanos(maxProcessTimeInNano), Duration.ofNanos(elapsed));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BackgroundTaskExecutor.java."}, {"role": "assistant", "content": "The source code of java class BackgroundTaskExecutor.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.internal.async.ThreadPools;\nimport core.framework.util.Lists;\nimport core.framework.util.Randoms;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author neo\n */\npublic class BackgroundTaskExecutor {\n    private final Logger logger = LoggerFactory.getLogger(BackgroundTaskExecutor.class);\n\n    private final ScheduledExecutorService scheduler = ThreadPools.singleThreadScheduler(\"background-task-\");\n    private final List<BackgroundTask> tasks = Lists.newArrayList();\n\n    public void start() {\n        for (BackgroundTask task : tasks) {\n            Duration delay = Duration.ofMillis((long) Randoms.nextDouble(5000, 10000)); // delay 5s to 10s\n            scheduler.scheduleWithFixedDelay(task, delay.toMillis(), task.rate.toMillis(), TimeUnit.MILLISECONDS);\n        }\n        logger.info(\"background task executor started\");\n    }\n\n    public void scheduleWithFixedDelay(Runnable command, Duration rate) {\n        tasks.add(new BackgroundTask(command, rate));\n    }\n\n    void shutdown() {\n        logger.info(\"shutting down background task executor\");\n        scheduler.shutdown();\n    }\n\n    void awaitTermination(long timeoutInMs) throws InterruptedException {\n        boolean success = scheduler.awaitTermination(timeoutInMs, TimeUnit.MILLISECONDS);\n        if (!success) logger.warn(\"failed to terminate background task executor\");\n        else logger.info(\"background task executor stopped\");\n    }\n\n    private static class BackgroundTask implements Runnable {\n        final Duration rate;\n        private final Logger logger = LoggerFactory.getLogger(BackgroundTask.class);\n        private final Runnable command;\n\n        BackgroundTask(Runnable command, Duration rate) {\n            this.command = command;\n            this.rate = rate;\n        }\n\n        @Override\n        public void run() {\n            try {\n                command.run();\n            } catch (Throwable e) {\n                logger.error(\"failed to run background task, error={}\", e.getMessage(), e);\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Config.java."}, {"role": "assistant", "content": "The source code of java class Config.java:\n```java\npackage core.framework.internal.module;\n\nimport javax.annotation.Nullable;\n\n/**\n * @author neo\n */\npublic abstract class Config {  // use abstract class not interface is for hiding those method from app module, interface methods must be public\n    protected abstract void initialize(ModuleContext context, @Nullable String name);\n\n    // after initialization done, validate and finalize\n    protected void validate() {\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ModuleContext.java."}, {"role": "assistant", "content": "The source code of java class ModuleContext.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.async.Executor;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.async.ExecutorImpl;\nimport core.framework.internal.async.ThreadPools;\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.inject.BeanFactory;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.stat.StatCollector;\nimport core.framework.internal.web.HTTPServer;\nimport core.framework.internal.web.HTTPServerConfig;\nimport core.framework.internal.web.HTTPServerMetrics;\nimport core.framework.internal.web.controller.ControllerClassValidator;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.internal.web.controller.ControllerInspector;\nimport core.framework.internal.web.route.PathPatternValidator;\nimport core.framework.internal.web.sys.APIController;\nimport core.framework.internal.web.sys.DiagnosticController;\nimport core.framework.internal.web.sys.PropertyController;\nimport core.framework.module.LambdaController;\nimport core.framework.util.ASCII;\nimport core.framework.util.Maps;\nimport core.framework.web.Controller;\nimport core.framework.web.SessionContext;\nimport core.framework.web.WebContext;\nimport core.framework.web.site.WebDirectory;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class ModuleContext {    // after core.framework.module.App.start(), entire ModuleContext will be GCed\n    public final LogManager logManager;\n    public final StartupHook startupHook = new StartupHook();\n    public final ShutdownHook shutdownHook;\n    public final ReadinessProbe probe = new ReadinessProbe();\n    public final BeanFactory beanFactory = new BeanFactory();\n    public final PropertyManager propertyManager = new PropertyManager();\n    public final StatCollector collector = new StatCollector();\n    public final HTTPServer httpServer;\n    public final HTTPServerConfig httpServerConfig = new HTTPServerConfig();\n    public final APIController apiController = new APIController();\n    public final BeanClassValidator beanClassValidator = new BeanClassValidator();\n    protected final Map<String, Config> configs = Maps.newHashMap();\n    final PropertyValidator propertyValidator = new PropertyValidator();\n    private BackgroundTaskExecutor backgroundTask;\n\n    public ModuleContext(LogManager logManager) {\n        this.logManager = logManager;\n        shutdownHook = new ShutdownHook(logManager);\n        httpServer = createHTTPServer();\n    }\n\n    // create builtin beans can be overridden by test context\n    public void initialize() {\n        var executor = new ExecutorImpl(ThreadPools.virtualThreadExecutor(\"executor-\"), logManager, shutdownHook.shutdownTimeoutInNano);\n        beanFactory.bind(Executor.class, null, executor);\n        shutdownHook.add(ShutdownHook.STAGE_2, timeout -> executor.shutdown());\n        shutdownHook.add(ShutdownHook.STAGE_3, executor::awaitTermination);\n\n        var diagnosticController = new DiagnosticController();\n        route(HTTPMethod.GET, \"/_sys/vm\", (LambdaController) diagnosticController::vm, true);\n        route(HTTPMethod.GET, \"/_sys/thread\", (LambdaController) diagnosticController::thread, true);\n        route(HTTPMethod.GET, \"/_sys/thread/virtual\", (LambdaController) diagnosticController::virtualThread, true);\n        route(HTTPMethod.GET, \"/_sys/heap\", (LambdaController) diagnosticController::heap, true);\n        route(HTTPMethod.GET, \"/_sys/proc\", (LambdaController) diagnosticController::proc, true);\n        route(HTTPMethod.GET, \"/_sys/property\", new PropertyController(propertyManager), true);\n        route(HTTPMethod.GET, \"/_sys/api\", (LambdaController) apiController::service, true);\n        route(HTTPMethod.GET, \"/_sys/api/message\", (LambdaController) apiController::message, true);\n    }\n\n    private HTTPServer createHTTPServer() {\n        var httpServer = new HTTPServer(logManager);\n        beanFactory.bind(WebContext.class, null, httpServer.handler.webContext);\n        beanFactory.bind(SessionContext.class, null, httpServer.siteManager.sessionManager);\n        beanFactory.bind(WebDirectory.class, null, httpServer.siteManager.webDirectory);\n\n        startupHook.start.add(() -> httpServer.start(httpServerConfig));\n        shutdownHook.add(ShutdownHook.STAGE_0, timeout -> httpServer.shutdown());\n        shutdownHook.add(ShutdownHook.STAGE_1, httpServer::awaitRequestCompletion);\n        shutdownHook.add(ShutdownHook.STAGE_8, timeout -> httpServer.awaitTermination());\n\n        collector.metrics.add(new HTTPServerMetrics(httpServer));\n        return httpServer;\n    }\n\n    public BackgroundTaskExecutor backgroundTask() {\n        if (backgroundTask == null) {\n            var backgroundTask = new BackgroundTaskExecutor();\n            startupHook.start.add(backgroundTask::start);\n            shutdownHook.add(ShutdownHook.STAGE_2, timeout -> backgroundTask.shutdown());\n            shutdownHook.add(ShutdownHook.STAGE_3, backgroundTask::awaitTermination);\n            this.backgroundTask = backgroundTask;\n        }\n        return backgroundTask;\n    }\n\n    public final void route(HTTPMethod method, String path, Controller controller, boolean skipInterceptor) {\n        new PathPatternValidator(path, true).validate();\n        var inspector = new ControllerInspector(controller);\n        new ControllerClassValidator(inspector.targetClass, inspector.targetMethod).validate();\n        String action = \"http:\" + ASCII.toLowerCase(method.name()) + \":\" + path;\n        httpServer.handler.route.add(method, path, new ControllerHolder(controller, inspector.targetMethod, inspector.controllerInfo, action, skipInterceptor));\n    }\n\n    public <T extends Config> T config(Class<T> configClass, @Nullable String name) {\n        String key = configClass.getCanonicalName() + \":\" + name;   // not using computeIfAbsent, to avoid concurrent modification in nested call, e.g. httpConfig->publishAPIConfig->apiConfig\n        @SuppressWarnings(\"unchecked\")\n        T config = (T) configs.get(key);\n        if (config == null) {\n            try {\n                config = configClass(configClass).getConstructor().newInstance();\n                config.initialize(this, name);\n                configs.put(key, config);\n            } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\n                throw new Error(e);\n            }\n        }\n        return config;\n    }\n\n    public <T> T bind(Type type, @Nullable String name, T instance) {\n        beanFactory.bind(type, name, instance);\n        return instance;\n    }\n\n    public void validate() {\n        Set<String> keys = propertyManager.properties.keys();\n        propertyValidator.validate(keys);\n\n        for (Config config : configs.values()) {\n            config.validate();\n        }\n    }\n\n    public Optional<String> property(String key) {\n        propertyValidator.usedProperties.add(key);\n        return propertyManager.property(key);\n    }\n\n    protected <T> Class<T> configClass(Class<T> configClass) {\n        return configClass;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PropertyManager.java."}, {"role": "assistant", "content": "The source code of java class PropertyManager.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.util.ASCII;\nimport core.framework.util.Properties;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic class PropertyManager {\n    public final Properties properties = new Properties();\n    private final Logger logger = LoggerFactory.getLogger(PropertyManager.class);\n\n    public Optional<String> property(String key) {\n        if (!properties.containsKey(key)) return Optional.empty();   // if the key is not defined in property file, do not check env, make env more deterministic, e.g. env may define property not in property files, which make integration-test inconsistent with runtime\n\n        String envVarName = envVarName(key);\n        // use env var to override property, e.g. under docker/kubenetes, SYS_HTTP_LISTEN to override sys.http.listen\n        // in kube env, ConfigMap can be bound as env variables\n        String value = System.getenv(envVarName);\n        if (!Strings.isBlank(value)) {\n            logger.info(\"found overridden property by env var {}, key={}, value={}\", envVarName, key, maskValue(key, value));\n            return Optional.of(value);\n        }\n        value = System.getProperty(key);     // use system property to override property, e.g. -Dsys.http.listen=8080\n        if (!Strings.isBlank(value)) {\n            logger.info(\"found overridden property by system property -D{}, key={}, value={}\", key, key, maskValue(key, value));\n            return Optional.of(value);\n        }\n\n        return properties.get(key);\n    }\n\n    public String maskValue(String key, String value) { // generally only password or secretKey will be put into property file\n        String lowerCaseKey = ASCII.toLowerCase(key);\n        if (lowerCaseKey.contains(\"password\") || lowerCaseKey.contains(\"secret\")) return \"******\";\n        return value;\n    }\n\n    String envVarName(String propertyKey) {\n        var builder = new StringBuilder();\n        int length = propertyKey.length();\n        for (int i = 0; i < length; i++) {\n            char ch = propertyKey.charAt(i);\n            if (ch == '.') builder.append('_');\n            else builder.append(ASCII.toUpperCase(ch));\n        }\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PropertyValidator.java."}, {"role": "assistant", "content": "The source code of java class PropertyValidator.java:\n```java\npackage core.framework.internal.module;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author neo\n */\nclass PropertyValidator {\n    Set<String> usedProperties = new HashSet<>();\n\n    void validate(Set<String> keys) {\n        List<String> notUsedKeys = new ArrayList<>();\n        for (String key : keys) {\n            if (!usedProperties.contains(key)) notUsedKeys.add(key);\n        }\n        if (!notUsedKeys.isEmpty()) {\n            throw new Error(\"found not used properties, please remove unnecessary config, keys=\" + notUsedKeys);\n        }\n        usedProperties = null;  // release memory\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ReadinessProbe.java."}, {"role": "assistant", "content": "The source code of java class ReadinessProbe.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class ReadinessProbe {\n    static final long MAX_WAIT_TIME_IN_NANO = 27_000_000_000L;  // 27s, roughly attempts 6 times if no read timeout\n    private final Logger logger = LoggerFactory.getLogger(ReadinessProbe.class);\n\n    // hostURI is in host[:port] format\n    public List<String> hostURIs = new ArrayList<>();\n    public List<String> urls = new ArrayList<>();\n\n    public Map<String, String> defaultHeaders = new HashMap<>();\n\n    public void check() throws Exception {\n        logger.info(\"check readiness\");\n        var watch = new StopWatch();\n        checkDNS(watch);\n        checkHTTP(watch);\n    }\n\n    private void checkDNS(StopWatch watch) throws InterruptedException {\n        for (String hostURI : hostURIs) {\n            String hostname = hostname(hostURI);\n            resolveHost(hostname, watch);\n        }\n        hostURIs = null;    // release memory\n        this.defaultHeaders = null;\n    }\n\n    private void checkHTTP(StopWatch watch) throws InterruptedException {\n        if (!urls.isEmpty()) {\n            HTTPClient client = HTTPClient.builder().build();\n            for (String url : urls) {\n                sendHTTPRequest(url, client, watch);\n            }\n        }\n        urls = null;    // release memory\n    }\n\n    private void sendHTTPRequest(String url, HTTPClient client, StopWatch watch) throws InterruptedException {\n        var request = new HTTPRequest(HTTPMethod.GET, url);\n        if (defaultHeaders != null && !defaultHeaders.isEmpty()) {\n            request.headers.putAll(defaultHeaders);\n        }\n        while (true) {\n            try {\n                HTTPResponse response = client.execute(request);\n                if (response.statusCode >= 200 && response.statusCode < 300) return;\n                throw new Exception(\"http request failed, status=\" + response.statusCode);\n            } catch (Exception e) {\n                if (watch.elapsed() >= MAX_WAIT_TIME_IN_NANO) throw new Error(\"readiness check failed, url=\" + url, e);\n                logger.warn(errorCode(\"NOT_READY\"), \"http probe failed, retry soon, url={}\", url, e);\n                Thread.sleep(5000);\n            }\n        }\n    }\n\n    void resolveHost(String hostname, StopWatch watch) throws InterruptedException {\n        while (true) {\n            try {\n                InetAddress.getByName(hostname);\n                return;\n            } catch (UnknownHostException e) {\n                if (watch.elapsed() >= MAX_WAIT_TIME_IN_NANO)\n                    throw new Error(\"readiness check failed, host=\" + hostname, e);\n                logger.warn(errorCode(\"NOT_READY\"), \"dns probe failed, retry soon, host={}\", hostname, e);\n                Thread.sleep(5000);\n            }\n        }\n    }\n\n    String hostname(String hostURI) {\n        int index = hostURI.indexOf(':');\n        if (index == -1) return hostURI;\n        return hostURI.substring(0, index);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ShutdownHook.java."}, {"role": "assistant", "content": "The source code of java class ShutdownHook.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.management.ManagementFactory;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class ShutdownHook implements Runnable {\n    public static final int STAGE_0 = 0;    // send shutdown signal, begin to shut down processor for external requests, e.g. http server / kafka listener / scheduler\n    public static final int STAGE_1 = 1;    // await external request processor to stop\n    public static final int STAGE_2 = 2;    // after no more new external requests, shutdown internal executors / background tasks\n    public static final int STAGE_3 = 3;    // await internal executors to stop\n    public static final int STAGE_4 = 4;    // after no any task running, shutdown kafka producer\n    public static final int STAGE_5 = 5;    // release all application defined shutdown hook\n    public static final int STAGE_6 = 6;    // release all resources without dependencies, e.g. db / redis / mongo / search\n    public static final int STAGE_7 = 7;    // shutdown kafka log appender, give more time try to forward all logs\n    public static final int STAGE_8 = 8;    // finally, stop the http server, to make sure it responds to incoming requests during shutdown\n    public final long shutdownTimeoutInNano;\n    private final Logger logger = LoggerFactory.getLogger(ShutdownHook.class);\n    private final LogManager logManager;\n    private final Stage[] stages = new Stage[STAGE_8 + 1];\n    private final long shutdownDelayInSec;\n\n    ShutdownHook(LogManager logManager) {\n        this.logManager = logManager;\n        Map<String, String> env = System.getenv();\n        shutdownDelayInSec = shutdownDelayInSec(env);\n        shutdownTimeoutInNano = shutdownTimeoutInNano(env);\n    }\n\n    // in kube env, once Pod is set to the “Terminating” State,\n    // api-server remove pod from endpoint, and notify kubelet pod deletion simultaneously\n    // kube-proxy watches endpoint changes, and modify iptables accordingly\n    // put delay to make sure kube-proxy update iptables before pod stops serving new requests, to reduce connection errors / 503\n    // (client still needs retry)\n    long shutdownDelayInSec(Map<String, String> env) {\n        String shutdownDelay = env.get(\"SHUTDOWN_DELAY_IN_SEC\");\n        if (shutdownDelay != null) {\n            long delay = Long.parseLong(shutdownDelay);\n            if (delay <= 0) throw new Error(\"shutdown delay must be greater than 0, delay=\" + shutdownDelay);\n            return delay;\n        }\n        return -1;\n    }\n\n    long shutdownTimeoutInNano(Map<String, String> env) {\n        String shutdownTimeout = env.get(\"SHUTDOWN_TIMEOUT_IN_SEC\");\n        if (shutdownTimeout != null) {\n            long timeout = Long.parseLong(shutdownTimeout) * 1_000_000_000;\n            if (timeout <= 0) throw new Error(\"shutdown timeout must be greater than 0, timeout=\" + shutdownTimeout);\n            return timeout;\n        }\n        return 25_000_000_000L;   // default kube terminationGracePeriodSeconds is 30s, here give 25s try to stop important processes\n    }\n\n    public void add(int stage, Shutdown shutdown) {\n        if (stages[stage] == null) stages[stage] = new Stage();\n        stages[stage].shutdowns.add(shutdown);\n    }\n\n    @Override\n    public void run() {\n        if (shutdownDelayInSec > 0) {\n            try {\n                logger.info(\"delay {} seconds prior to shutdown\", shutdownDelayInSec);\n                Thread.sleep(shutdownDelayInSec * 1000);\n            } catch (InterruptedException e) {\n                logger.warn(\"sleep is interrupted\", e);\n            }\n        }\n\n        ActionLog actionLog = logManager.begin(\"=== shutdown begin ===\", null);\n        logContext(actionLog);\n\n        long endTime = System.currentTimeMillis() + shutdownTimeoutInNano / 1_000_000;\n\n        shutdown(endTime, STAGE_0, STAGE_6);\n        logManager.end(\"=== shutdown end ===\"); // end action log before closing kafka log appender\n\n        shutdown(endTime, STAGE_7, STAGE_8);\n        logger.info(\"shutdown completed, elapsed={}\", actionLog.elapsed());\n    }\n\n    void logContext(ActionLog actionLog) {\n        actionLog.action(\"app:stop\");\n        actionLog.context(\"start_time\", Instant.ofEpochMilli(ManagementFactory.getRuntimeMXBean().getStartTime()));\n        actionLog.stats.put(\"uptime\", ManagementFactory.getRuntimeMXBean().getUptime() * 1_000_000d);   // convert to nanoseconds\n    }\n\n    void shutdown(long endTime, int fromStage, int toStage) {\n        for (int i = fromStage; i <= toStage; i++) {\n            Stage stage = stages[i];\n            if (stage == null) continue;\n            logger.info(\"shutdown stage: {}\", i);\n            for (Shutdown shutdown : stage.shutdowns) {\n                try {\n                    long timeoutInMs = endTime - System.currentTimeMillis();\n                    if (timeoutInMs < 1000) timeoutInMs = 1000; // give 1s if less 1s is left, usually we put larger terminationGracePeriodSeconds than SHUTDOWN_TIMEOUT_IN_SEC, so there are some room to gracefully shutdown rest resources\n                    shutdown.execute(timeoutInMs);\n                } catch (Throwable e) {\n                    logger.warn(errorCode(\"FAILED_TO_STOP\"), \"failed to shutdown, method={}\", shutdown, e);\n                }\n            }\n        }\n    }\n\n    public interface Shutdown {\n        void execute(long timeoutInMs) throws Exception;\n    }\n\n    static class Stage {\n        final List<Shutdown> shutdowns = new ArrayList<>();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StartupHook.java."}, {"role": "assistant", "content": "The source code of java class StartupHook.java:\n```java\npackage core.framework.internal.module;\n\nimport core.framework.async.Task;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class StartupHook {\n    // startup has 2 stages, initialize() is for client initialization, e.g. kafka client,\n    // start() is to start actual process, like scheduler/listener/etc, those processors may depend on client requires initialize()\n\n    public List<Task> initialize = new ArrayList<>();\n    public List<Task> start = new ArrayList<>();\n\n    public void initialize() throws Exception {\n        for (Task task : initialize) {\n            task.execute();\n        }\n        initialize = null;  // release memory\n    }\n\n    public void start() throws Exception {\n        for (Task task : start) {\n            task.execute();\n        }\n        start = null;   // release memory\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Protocol.java."}, {"role": "assistant", "content": "The source code of java class Protocol.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.util.Strings;\n\nimport java.io.IOException;\n\n/**\n * refer to https://github.com/antirez/RESP3/blob/master/spec.md, currently only support RESP2\n */\nfinal class Protocol {\n    private static final byte BLOB_STRING_BYTE = '$';\n    private static final byte SIMPLE_STRING_BYTE = '+';\n    private static final byte SIMPLE_ERROR_BYTE = '-';\n    private static final byte NUMBER_BYTE = ':';\n    private static final byte ARRAY_BYTE = '*';\n\n    static void writeArray(RedisOutputStream stream, int length) throws IOException {\n        stream.write(ARRAY_BYTE);\n        stream.writeBytesCRLF(RedisEncodings.encode(length));\n    }\n\n    static void writeBlobString(RedisOutputStream stream, byte[] value) throws IOException {\n        stream.write(BLOB_STRING_BYTE);\n        stream.writeBytesCRLF(RedisEncodings.encode(value.length));\n        stream.writeBytesCRLF(value);\n    }\n\n    static Object read(RedisInputStream stream) throws IOException {\n        return parseObject(stream);\n    }\n\n    private static Object parseObject(RedisInputStream stream) throws IOException {\n        byte firstByte = stream.readByte();\n        return switch (firstByte) {\n            case SIMPLE_STRING_BYTE -> stream.readSimpleString();\n            case BLOB_STRING_BYTE -> parseBlobString(stream);\n            case ARRAY_BYTE -> parseArray(stream);\n            case NUMBER_BYTE -> stream.readLong();\n            case SIMPLE_ERROR_BYTE -> {\n                String message = stream.readSimpleString();\n                throw new RedisException(message);\n            }\n            default -> throw new IOException(\"unknown redis response, firstByte=\" + (char) firstByte);\n        };\n    }\n\n    private static byte[] parseBlobString(RedisInputStream stream) throws IOException {\n        int length = (int) stream.readLong();\n        if (length == -1) return null;\n\n        return stream.readBytes(length);\n    }\n\n    private static Object[] parseArray(RedisInputStream stream) throws IOException {\n        int length = (int) stream.readLong();\n        if (length == -1) return null;\n\n        var array = new Object[length];\n        for (int i = 0; i < length; i++) {\n            array[i] = parseObject(stream);       // redis won't put error within array, so here it doesn't expect RedisException\n        }\n        return array;\n    }\n\n    static class Command {\n        static final byte[] AUTH = Strings.bytes(\"AUTH\");\n        static final byte[] INFO = Strings.bytes(\"INFO\");\n\n        static final byte[] GET = Strings.bytes(\"GET\");\n        static final byte[] SET = Strings.bytes(\"SET\");\n        static final byte[] PEXPIRE = Strings.bytes(\"PEXPIRE\");\n        static final byte[] PTTL = Strings.bytes(\"PTTL\");\n        static final byte[] DEL = Strings.bytes(\"DEL\");\n        static final byte[] INCRBY = Strings.bytes(\"INCRBY\");\n        static final byte[] MGET = Strings.bytes(\"MGET\");\n        static final byte[] MSET = Strings.bytes(\"MSET\");\n        static final byte[] SCAN = Strings.bytes(\"SCAN\");\n\n        static final byte[] HGET = Strings.bytes(\"HGET\");\n        static final byte[] HGETALL = Strings.bytes(\"HGETALL\");\n        static final byte[] HSET = Strings.bytes(\"HSET\");\n        static final byte[] HMSET = Strings.bytes(\"HMSET\");\n        static final byte[] HDEL = Strings.bytes(\"HDEL\");\n        static final byte[] HINCRBY = Strings.bytes(\"HINCRBY\");\n\n        static final byte[] PFADD = Strings.bytes(\"PFADD\");\n        static final byte[] PFCOUNT = Strings.bytes(\"PFCOUNT\");\n\n        static final byte[] SADD = Strings.bytes(\"SADD\");\n        static final byte[] SMEMBERS = Strings.bytes(\"SMEMBERS\");\n        static final byte[] SISMEMBER = Strings.bytes(\"SISMEMBER\");\n        static final byte[] SREM = Strings.bytes(\"SREM\");\n        static final byte[] SPOP = Strings.bytes(\"SPOP\");\n        static final byte[] SCARD = Strings.bytes(\"SCARD\");\n\n        static final byte[] LRANGE = Strings.bytes(\"LRANGE\");\n        static final byte[] RPUSH = Strings.bytes(\"RPUSH\");\n        static final byte[] LPOP = Strings.bytes(\"LPOP\");\n        static final byte[] LTRIM = Strings.bytes(\"LTRIM\");\n\n        static final byte[] ZADD = Strings.bytes(\"ZADD\");\n        static final byte[] ZINCRBY = Strings.bytes(\"ZINCRBY\");\n        static final byte[] ZRANGE = Strings.bytes(\"ZRANGE\");\n        static final byte[] ZREM = Strings.bytes(\"ZREM\");\n        static final byte[] ZPOPMIN = Strings.bytes(\"ZPOPMIN\");\n    }\n\n    static class Keyword {\n        static final byte[] MATCH = Strings.bytes(\"MATCH\");\n        static final byte[] COUNT = Strings.bytes(\"COUNT\");\n        static final byte[] NX = Strings.bytes(\"NX\");\n        static final byte[] PX = Strings.bytes(\"PX\");\n        static final byte[] LIMIT = Strings.bytes(\"LIMIT\");\n        static final byte[] WITHSCORES = Strings.bytes(\"WITHSCORES\");\n        static final byte[] BYSCORE = Strings.bytes(\"BYSCORE\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisAdminImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisAdminImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisAdmin;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport static core.framework.internal.redis.Protocol.Command.INFO;\nimport static core.framework.internal.redis.RedisEncodings.decode;\n\n/**\n * @author neo\n */\npublic class RedisAdminImpl implements RedisAdmin {\n    private final Logger logger = LoggerFactory.getLogger(RedisAdminImpl.class);\n    private final RedisImpl redis;\n\n    public RedisAdminImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public Map<String, String> info() {\n        var watch = new StopWatch();\n        String value = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeCommand(INFO);\n            value = decode(connection.readBlobString());\n            return parseInfo(value);\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"info, returnedValue={}, elapsed={}\", value, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n\n    Map<String, String> parseInfo(String info) {\n        Map<String, String> values = Maps.newHashMapWithExpectedSize(128);  // redis 5.x return roughly 122 keys for info\n        StringTokenizer tokenizer = new StringTokenizer(info, \"\\r\\n\");\n        while (tokenizer.hasMoreTokens()) {\n            String line = tokenizer.nextToken();\n            if (!Strings.startsWith(line, '#')) {\n                int index = line.indexOf(':');\n                values.put(line.substring(0, index), line.substring(index + 1));\n            }\n        }\n        return values;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisConnection.java."}, {"role": "assistant", "content": "The source code of java class RedisConnection.java:\n```java\npackage core.framework.internal.redis;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\nimport static core.framework.internal.redis.RedisEncodings.encode;\n\n/**\n * @author neo\n */\nclass RedisConnection implements AutoCloseable {\n    RedisOutputStream outputStream;\n    RedisInputStream inputStream;\n    private Socket socket;\n\n    void connect(String host, int port, int timeoutInMs) throws IOException {\n        socket = new Socket();\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true); // Socket buffer whether closed, to ensure timely delivery of data\n        socket.setSoLinger(true, 0); // Control calls close () method, the underlying socket is closed immediately\n        socket.connect(new InetSocketAddress(host, port), timeoutInMs);\n        socket.setSoTimeout(timeoutInMs);\n        outputStream = new RedisOutputStream(socket.getOutputStream(), 8192);\n        inputStream = new RedisInputStream(socket.getInputStream());\n    }\n\n    void writeCommand(byte[] command) throws IOException {\n        writeArray(1);\n        writeBlobString(command);\n        flush();\n    }\n\n    void writeKeyCommand(byte[] command, String key) throws IOException {\n        writeArray(2);\n        writeBlobString(command);\n        writeBlobString(encode(key));\n        flush();\n    }\n\n    void writeKeysCommand(byte[] command, String... keys) throws IOException {\n        writeArray(1 + keys.length);\n        writeBlobString(command);\n        for (String key : keys) {\n            writeBlobString(encode(key));\n        }\n        flush();\n    }\n\n    void writeKeyArgumentCommand(byte[] command, String key, byte[] argument) throws IOException {\n        writeArray(3);\n        writeBlobString(command);\n        writeBlobString(encode(key));\n        writeBlobString(argument);\n        flush();\n    }\n\n    void writeKeyArgumentsCommand(byte[] command, String key, byte[] argument1, byte[] argument2) throws IOException {\n        writeArray(4);\n        writeBlobString(command);\n        writeBlobString(encode(key));\n        writeBlobString(argument1);\n        writeBlobString(argument2);\n        flush();\n    }\n\n    void writeKeyArgumentsCommand(byte[] command, String key, String... arguments) throws IOException {\n        writeArray(2 + arguments.length);\n        writeBlobString(command);\n        writeBlobString(encode(key));\n        for (String value : arguments) {\n            writeBlobString(encode(value));\n        }\n        flush();\n    }\n\n    void writeArray(int length) throws IOException {\n        Protocol.writeArray(outputStream, length);\n    }\n\n    void writeBlobString(byte[] value) throws IOException {\n        Protocol.writeBlobString(outputStream, value);\n    }\n\n    void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (socket != null) socket.close();\n    }\n\n    String readSimpleString() throws IOException {\n        return (String) Protocol.read(inputStream);\n    }\n\n    byte[] readBlobString() throws IOException {\n        return (byte[]) Protocol.read(inputStream);\n    }\n\n    long readLong() throws IOException {\n        return (long) Protocol.read(inputStream);\n    }\n\n    Object[] readArray() throws IOException {\n        return (Object[]) Protocol.read(inputStream);\n    }\n\n    Object[] readAll(int size) throws IOException {\n        RedisException exception = null;\n        Object[] results = new Object[size];\n        for (int i = 0; i < size; i++) {\n            try {\n                results[i] = Protocol.read(inputStream);\n            } catch (RedisException e) {\n                exception = e;\n            }\n        }\n        if (exception != null) throw exception;\n        return results;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisConnectionFactory.java."}, {"role": "assistant", "content": "The source code of java class RedisConnectionFactory.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.resource.Pool;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.time.Duration;\nimport java.util.function.Supplier;\n\nimport static core.framework.internal.redis.Protocol.Command.AUTH;\n\n/**\n * @author neo\n */\nclass RedisConnectionFactory implements Supplier<RedisConnection> {\n    RedisHost host;\n    String password;\n    int timeoutInMs = (int) Duration.ofSeconds(5).toMillis();\n\n    @Override\n    public RedisConnection get() {\n        return create(timeoutInMs);\n    }\n\n    RedisConnection create(int timeoutInMs) {\n        if (host == null) throw new Error(\"redis host must not be null\");\n        var connection = new RedisConnection(); // this won't throw exception\n        try {\n            connection.connect(host.host, host.port, timeoutInMs);\n            if (password != null) {\n                connection.writeKeyCommand(AUTH, password);\n                connection.readSimpleString();\n            }\n            return connection;\n        } catch (RedisException e) {    // redis throws error (WRONGPASS) if AUTH failed\n            Pool.closeQuietly(connection);\n            throw e;\n        } catch (IOException e) {\n            Pool.closeQuietly(connection);\n            throw new UncheckedIOException(e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisEncodings.java."}, {"role": "assistant", "content": "The source code of java class RedisEncodings.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.util.Strings;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * @author neo\n */\nclass RedisEncodings {\n    private static final byte[][] INT_BYTES_CACHE = new byte[256][];\n\n    static {\n        for (int i = 0; i < 256; i++) {\n            String text = Integer.toString(i);\n            INT_BYTES_CACHE[i] = Strings.bytes(text);\n        }\n    }\n\n    static void validate(String name, String value) {\n        if (value == null) throw new Error(name + \" must not be null\");\n    }\n\n    static void validate(String name, String... values) {\n        if (values.length == 0) throw new Error(name + \" must not be empty\");\n        for (String value : values) {\n            if (value == null) throw new Error(name + \" must not contain null\");\n        }\n    }\n\n    static void validate(String name, Map<?, ?> values) {\n        if (values.isEmpty()) throw new Error(name + \" must not be empty\");\n        for (Map.Entry<?, ?> entry : values.entrySet()) {\n            if (entry.getKey() == null || entry.getValue() == null) throw new Error(name + \" must not contain null\");\n        }\n    }\n\n    static byte[] encode(String value) {\n        return Strings.bytes(value);\n    }\n\n    static byte[] encode(long value) {\n        if (value >= 0 && value < 256) {\n            return INT_BYTES_CACHE[(int) value];\n        }\n        String text = Long.toString(value);\n        return Strings.bytes(text); // according to JMH benchmark, text.getBytes(UTF_8) beats getBytesWithOtherCharset or convert by char[] directly, refer to JDK impl for details\n    }\n\n    static String decode(byte[] value) {\n        if (value == null) return null;\n        return new String(value, StandardCharsets.UTF_8);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisException.java."}, {"role": "assistant", "content": "The source code of java class RedisException.java:\n```java\npackage core.framework.internal.redis;\n\nimport java.io.Serial;\n\n/**\n * @author neo\n */\npublic class RedisException extends RuntimeException {\n    @Serial\n    private static final long serialVersionUID = -5459336238321986524L;\n\n    public RedisException(String message) {\n        super(message);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisHashImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisHashImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.log.filter.FieldMapLogParam;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisHash;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\n\nimport static core.framework.internal.redis.Protocol.Command.HDEL;\nimport static core.framework.internal.redis.Protocol.Command.HGET;\nimport static core.framework.internal.redis.Protocol.Command.HGETALL;\nimport static core.framework.internal.redis.Protocol.Command.HINCRBY;\nimport static core.framework.internal.redis.Protocol.Command.HMSET;\nimport static core.framework.internal.redis.Protocol.Command.HSET;\nimport static core.framework.internal.redis.RedisEncodings.decode;\nimport static core.framework.internal.redis.RedisEncodings.encode;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author neo\n */\npublic final class RedisHashImpl implements RedisHash {\n    private final Logger logger = LoggerFactory.getLogger(RedisHashImpl.class);\n    private final RedisImpl redis;\n\n    RedisHashImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public String get(String key, String field) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"field\", field);\n        String value = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(HGET, key, encode(field));\n            value = decode(connection.readBlobString());\n            return value;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"hget, key={}, field={}, returnedValue={}, elapsed={}\", key, field, value, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n\n    @Override\n    public Map<String, String> getAll(String key) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        Map<String, String> values = null;\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyCommand(HGETALL, key);\n            Object[] response = connection.readArray();\n            if (response.length % 2 != 0) throw new IOException(\"unexpected length of array, length=\" + response.length);\n            values = Maps.newHashMapWithExpectedSize(response.length / 2);\n            for (int i = 0; i < response.length; i += 2) {\n                values.put(decode((byte[]) response[i]), decode((byte[]) response[i + 1]));\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"hgetAll, key={}, returnedValues={}, elapsed={}\", key, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public void set(String key, String field, String value) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"field\", field);\n        validate(\"value\", value);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(4);\n            connection.writeBlobString(HSET);\n            connection.writeBlobString(encode(key));\n            connection.writeBlobString(encode(field));\n            connection.writeBlobString(encode(value));\n            connection.flush();\n            connection.readLong();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"hset, key={}, field={}, value={}, elapsed={}\", key, field, value, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n\n    @Override\n    public void multiSet(String key, Map<String, String> values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(2 + values.size() * 2);\n            connection.writeBlobString(HMSET);\n            connection.writeBlobString(encode(key));\n            for (Map.Entry<String, String> entry : values.entrySet()) {\n                connection.writeBlobString(encode(entry.getKey()));\n                connection.writeBlobString(encode(entry.getValue()));\n            }\n            connection.flush();\n            connection.readSimpleString();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            int size = values.size();\n            logger.debug(\"hmset, key={}, values={}, size={}, elapsed={}\", key, new FieldMapLogParam(values), size, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, size);\n        }\n    }\n\n    @Override\n    public long increaseBy(String key, String field, long increment) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"field\", field);\n        long value = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(HINCRBY, key, field, String.valueOf(increment));\n            value = connection.readLong();\n            return value;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"hincrby, key={}, field={}, increment={}, returnedValue={}, elapsed={}\", key, field, increment, value, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n\n    @Override\n    public long del(String key, String... fields) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"fields\", fields);\n        long deletedFields = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(HDEL, key, fields);\n            deletedFields = connection.readLong();\n            return deletedFields;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"hdel, key={}, fields={}, size={}, deletedFields={}, elapsed={}\", key, new ArrayLogParam(fields), fields.length, deletedFields, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, (int) deletedFields);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisHost.java."}, {"role": "assistant", "content": "The source code of java class RedisHost.java:\n```java\npackage core.framework.internal.redis;\n\n/**\n * @author neo\n */\npublic class RedisHost {\n    static final int DEFAULT_PORT = 6379;\n    public final String host;\n    public final int port;\n\n    public RedisHost(String host) {\n        int index = host.indexOf(':');\n        if (index == 0 || index == host.length() - 1) throw new Error(\"invalid host format, host=\" + host);\n        if (index != -1) {\n            this.host = host.substring(0, index);\n            try {\n                port = Integer.parseInt(host.substring(index + 1));\n            } catch (NumberFormatException e) {\n                throw new Error(\"invalid host format, host=\" + host, e);\n            }\n        } else {\n            this.host = host;\n            port = DEFAULT_PORT;\n        }\n    }\n\n    @Override\n    public String toString() {  // make it easier to log\n        return port == DEFAULT_PORT ? host : host + ':' + port;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisHyperLogLogImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisHyperLogLogImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisHyperLogLog;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport static core.framework.internal.redis.Protocol.Command.PFADD;\nimport static core.framework.internal.redis.Protocol.Command.PFCOUNT;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author tempo\n */\npublic class RedisHyperLogLogImpl implements RedisHyperLogLog {\n    private final Logger logger = LoggerFactory.getLogger(RedisHyperLogLogImpl.class);\n    private final RedisImpl redis;\n\n    public RedisHyperLogLogImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public boolean add(String key, String... values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(PFADD, key, values);\n            return connection.readLong() == 1;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"pfadd, key={}, values={}, size={}, elapsed={}\", key, new ArrayLogParam(values), values.length, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, values.length);\n        }\n    }\n\n    @Override\n    public long count(String... keys) {\n        var watch = new StopWatch();\n        validate(\"keys\", keys);\n        long count = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeysCommand(PFCOUNT, keys);\n            count = connection.readLong();\n            return count;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"pfcount, keys={}, returnedValue={}, elapsed={}\", keys, count, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.log.filter.BytesLogParam;\nimport core.framework.internal.log.filter.BytesMapLogParam;\nimport core.framework.internal.log.filter.FieldMapLogParam;\nimport core.framework.internal.resource.Pool;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.Redis;\nimport core.framework.redis.RedisAdmin;\nimport core.framework.redis.RedisHash;\nimport core.framework.redis.RedisHyperLogLog;\nimport core.framework.redis.RedisList;\nimport core.framework.redis.RedisSet;\nimport core.framework.redis.RedisSortedSet;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport static core.framework.internal.redis.Protocol.Command.DEL;\nimport static core.framework.internal.redis.Protocol.Command.GET;\nimport static core.framework.internal.redis.Protocol.Command.INCRBY;\nimport static core.framework.internal.redis.Protocol.Command.MGET;\nimport static core.framework.internal.redis.Protocol.Command.MSET;\nimport static core.framework.internal.redis.Protocol.Command.PEXPIRE;\nimport static core.framework.internal.redis.Protocol.Command.PTTL;\nimport static core.framework.internal.redis.Protocol.Command.SCAN;\nimport static core.framework.internal.redis.Protocol.Command.SET;\nimport static core.framework.internal.redis.Protocol.Keyword.COUNT;\nimport static core.framework.internal.redis.Protocol.Keyword.MATCH;\nimport static core.framework.internal.redis.Protocol.Keyword.NX;\nimport static core.framework.internal.redis.Protocol.Keyword.PX;\nimport static core.framework.internal.redis.RedisEncodings.decode;\nimport static core.framework.internal.redis.RedisEncodings.encode;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author neo\n */\npublic final class RedisImpl implements Redis {\n    final RedisConnectionFactory connectionFactory = new RedisConnectionFactory();\n\n    private final Logger logger = LoggerFactory.getLogger(RedisImpl.class);\n    private final RedisSet redisSet = new RedisSetImpl(this);\n    private final RedisHash redisHash = new RedisHashImpl(this);\n    private final RedisList redisList = new RedisListImpl(this);\n    private final RedisSortedSet redisSortedSet = new RedisSortedSetImpl(this);\n    private final RedisHyperLogLog redisHyperLogLog = new RedisHyperLogLogImpl(this);\n    private final RedisAdmin redisAdmin = new RedisAdminImpl(this);\n    private final String name;\n    public Pool<RedisConnection> pool;\n\n    public RedisImpl(String name) {\n        this.name = name;\n        pool = new Pool<>(connectionFactory, name);\n        pool.size(5, 50);\n        pool.maxIdleTime = Duration.ofMinutes(30);\n        pool.checkoutTimeout(Duration.ofSeconds(5));\n    }\n\n    public void host(String host) {\n        connectionFactory.host = new RedisHost(host);\n    }\n\n    public void password(String password) {\n        connectionFactory.password = password;\n    }\n\n    public void timeout(Duration timeout) {\n        connectionFactory.timeoutInMs = (int) timeout.toMillis();\n        pool.checkoutTimeout(timeout);\n    }\n\n    public void close() {\n        logger.info(\"close redis client, name={}, host={}\", name, connectionFactory.host);\n        pool.close();\n    }\n\n    @Override\n    public String get(String key) {\n        validate(\"key\", key);   // only validate on interface methods, internal usage will be checked by caller\n        return decode(getBytes(key));\n    }\n\n    public byte[] getBytes(String key) {\n        var watch = new StopWatch();\n        byte[] value = null;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyCommand(GET, key);\n            value = connection.readBlobString();\n            return value;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"get, key={}, returnedValue={}, elapsed={}\", key, new BytesLogParam(value), elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n\n    @Override\n    public RedisSet set() {\n        return redisSet;\n    }\n\n    @Override\n    public boolean set(String key, String value, Duration expiration, boolean onlyIfAbsent) {\n        validate(\"key\", key);\n        validate(\"value\", value);\n        return set(key, encode(value), expiration, onlyIfAbsent);\n    }\n\n    public boolean set(String key, byte[] value, Duration expiration, boolean onlyIfAbsent) {\n        var watch = new StopWatch();\n        byte[] expirationValue = expiration == null ? null : expirationValue(expiration);\n        boolean updated = false;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            int length = 3 + (onlyIfAbsent ? 1 : 0) + (expiration != null ? 2 : 0);\n            connection.writeArray(length);\n            connection.writeBlobString(SET);\n            connection.writeBlobString(encode(key));\n            connection.writeBlobString(value);\n            if (onlyIfAbsent) connection.writeBlobString(NX);\n            if (expiration != null) {\n                connection.writeBlobString(PX);\n                connection.writeBlobString(expirationValue);\n            }\n            connection.flush();\n            String result = connection.readSimpleString();\n            updated = \"OK\".equals(result);\n            return updated;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"set, key={}, value={}, expiration={}, onlyIfAbsent={}, updated={}, elapsed={}\", key, new BytesLogParam(value), expiration, onlyIfAbsent, updated, elapsed);\n            int writeEntries = updated ? 1 : 0;\n            ActionLogContext.track(\"redis\", elapsed, 0, writeEntries);\n        }\n    }\n\n    @Override\n    public void expire(String key, Duration expiration) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(PEXPIRE, key, encode(expiration.toMillis()));    // PEXPIRE accepts zero and negative ttl\n            connection.readLong();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"pexpire, key={}, expiration={}, elapsed={}\", key, expiration, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n\n    @Override\n    public long del(String... keys) {\n        var watch = new StopWatch();\n        validate(\"keys\", keys);\n        long deletedKeys = 0;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeysCommand(DEL, keys);\n            deletedKeys = connection.readLong();\n            return deletedKeys;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"del, keys={}, size={}, deletedKeys={}, elapsed={}\", new ArrayLogParam(keys), keys.length, deletedKeys, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, (int) deletedKeys);\n        }\n    }\n\n    @Override\n    public long increaseBy(String key, long increment) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        long value = 0;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(INCRBY, key, encode(increment));\n            value = connection.readLong();\n            return value;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"incrby, key={}, increment={}, returnedValue={}, elapsed={}\", key, increment, value, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n\n    @Override\n    public Map<String, String> multiGet(String... keys) {\n        Map<String, byte[]> values = multiGetBytes(keys);\n        Map<String, String> result = Maps.newLinkedHashMapWithExpectedSize(values.size());\n        for (Map.Entry<String, byte[]> entry : values.entrySet()) {\n            result.put(entry.getKey(), decode(entry.getValue()));\n        }\n        return result;\n    }\n\n    public Map<String, byte[]> multiGetBytes(String... keys) {\n        var watch = new StopWatch();\n        validate(\"keys\", keys);\n        Map<String, byte[]> values = Maps.newLinkedHashMapWithExpectedSize(keys.length);\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeysCommand(MGET, keys);\n            Object[] response = connection.readArray();\n            for (int i = 0; i < response.length; i++) {\n                byte[] value = (byte[]) response[i];\n                if (value != null) values.put(keys[i], value);\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"mget, keys={}, size={}, returnedValues={}, elapsed={}\", new ArrayLogParam(keys), keys.length, new BytesMapLogParam(values), elapsed);\n            ActionLogContext.track(\"redis\", elapsed, values.size(), 0);\n        }\n    }\n\n    @Override\n    public void multiSet(Map<String, String> values) {\n        var watch = new StopWatch();\n        validate(\"values\", values);\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(1 + values.size() * 2);\n            connection.writeBlobString(MSET);\n            for (Map.Entry<String, String> entry : values.entrySet()) {\n                connection.writeBlobString(encode(entry.getKey()));\n                connection.writeBlobString(encode(entry.getValue()));\n            }\n            connection.flush();\n            connection.readSimpleString();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            int size = values.size();\n            logger.debug(\"mset, values={}, size={}, elapsed={}\", new FieldMapLogParam(values), size, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, size);\n        }\n    }\n\n    public void multiSet(Map<String, byte[]> values, Duration expiration) {\n        var watch = new StopWatch();\n        validate(\"values\", values);\n        byte[] expirationValue = expirationValue(expiration);\n        int size = values.size();\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            for (Map.Entry<String, byte[]> entry : values.entrySet()) { // redis doesn't support mset with expiration, here to use pipeline\n                connection.writeArray(5);\n                connection.writeBlobString(SET);\n                connection.writeBlobString(encode(entry.getKey()));\n                connection.writeBlobString(entry.getValue());\n                connection.writeBlobString(PX);\n                connection.writeBlobString(expirationValue);\n            }\n            connection.flush();\n            connection.readAll(size);\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"set, values={}, size={}, expiration={}, elapsed={}\", new BytesMapLogParam(values), size, expiration, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, size);\n        }\n    }\n\n    @Override\n    public RedisHash hash() {\n        return redisHash;\n    }\n\n    @Override\n    public RedisList list() {\n        return redisList;\n    }\n\n    @Override\n    public RedisSortedSet sortedSet() {\n        return redisSortedSet;\n    }\n\n    @Override\n    public void forEach(String pattern, Consumer<String> consumer) {\n        var watch = new StopWatch();\n        if (pattern == null) throw new Error(\"pattern must not be null\");\n        long start = System.nanoTime();\n        long redisTook = 0;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        int returnedKeys = 0;\n        try {\n            RedisConnection connection = item.resource;\n            byte[] batchSize = encode(\"500\"); // use 500 as batch\n            String cursor = \"0\";\n            do {\n                connection.writeArray(6);\n                connection.writeBlobString(SCAN);\n                connection.writeBlobString(encode(cursor));\n                connection.writeBlobString(MATCH);\n                connection.writeBlobString(encode(pattern));\n                connection.writeBlobString(COUNT);\n                connection.writeBlobString(batchSize);\n                connection.flush();\n                Object[] response = connection.readArray();\n                cursor = decode((byte[]) response[0]);\n                Object[] keys = (Object[]) response[1];\n                returnedKeys += keys.length;\n                redisTook += System.nanoTime() - start;\n                for (Object key : keys) {\n                    consumer.accept(decode((byte[]) key));\n                }\n                start = System.nanoTime();\n            } while (!\"0\".equals(cursor));\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"scan, pattern={}, returnedKeys={}, redisTook={}, elapsed={}\", pattern, returnedKeys, redisTook, elapsed);\n            ActionLogContext.track(\"redis\", redisTook, returnedKeys, 0);\n        }\n    }\n\n    @Override\n    public RedisAdmin admin() {\n        return redisAdmin;\n    }\n\n    @Override\n    public RedisHyperLogLog hyperLogLog() {\n        return redisHyperLogLog;\n    }\n\n    public long[] expirationTime(String... keys) {\n        var watch = new StopWatch();\n        int size = keys.length;\n        long[] expirationTimes = null;\n        PoolItem<RedisConnection> item = pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            for (String key : keys) {\n                connection.writeArray(2);\n                connection.writeBlobString(PTTL);\n                connection.writeBlobString(encode(key));\n            }\n            connection.flush();\n            Object[] results = connection.readAll(size);\n            expirationTimes = new long[size];\n            for (int i = 0; i < results.length; i++) {\n                Long result = (Long) results[i];\n                expirationTimes[i] = result;\n            }\n            return expirationTimes;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"pttl,  keys={}, size={}, returnedValues={}, elapsed={}\", new ArrayLogParam(keys), size, expirationTimes, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, size, 0);\n        }\n    }\n\n    private byte[] expirationValue(Duration expiration) {\n        long expirationTime = expiration.toMillis();\n        if (expirationTime <= 0) throw new Error(\"expiration time must be longer than 0ms\");\n        return encode(expirationTime);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisInputStream.java."}, {"role": "assistant", "content": "The source code of java class RedisInputStream.java:\n```java\npackage core.framework.internal.redis;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * refer to jedis impl, https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/RedisInputStream.java\n * @author neo\n */\nclass RedisInputStream {\n    private final InputStream stream;\n    private final byte[] buffer = new byte[8192];\n    private int position;\n    private int limit;\n\n    RedisInputStream(InputStream stream) {\n        this.stream = stream;\n    }\n\n    byte readByte() throws IOException {\n        fill();\n        return buffer[position++];\n    }\n\n    String readSimpleString() throws IOException {\n        var builder = new StringBuilder();\n        while (true) {\n            fill();\n            byte value1 = buffer[position++];\n            if (value1 == '\\r') {\n                fill();\n                byte value2 = buffer[position++];\n                if (value2 == '\\n') {\n                    break;\n                }\n                builder.append((char) value1)\n                    .append((char) value2);\n            } else {\n                builder.append((char) value1);\n            }\n        }\n\n        String response = builder.toString();\n        if (response.isEmpty()) {\n            throw new IOException(\"simple string must not be empty\");\n        }\n        return response;\n    }\n\n    long readLong() throws IOException {\n        fill();\n        boolean negative = buffer[position] == '-';\n        if (negative) {\n            position++;\n        }\n        long value = 0;\n        while (true) {\n            fill();\n            int byteValue = buffer[position++];\n            if (byteValue == '\\r') {\n                fill();\n                byte byteValue2 = buffer[position++];\n                if (byteValue2 != '\\n') throw new IOException(\"unexpected character\");\n                break;\n            } else {\n                value = value * 10 + byteValue - '0';\n            }\n        }\n        return negative ? -value : value;\n    }\n\n    byte[] readBytes(int length) throws IOException {\n        byte[] response = new byte[length];\n        int offset = 0;\n        while (offset < length) {\n            fill();\n            int readLength = Math.min(limit - position, length - offset);\n            System.arraycopy(buffer, position, response, offset, readLength);\n            position += readLength;\n            offset += readLength;\n        }\n        byte value = readByte();\n        if (value != '\\r') throw new IOException(\"unexpected character\");\n        value = readByte();\n        if (value != '\\n') throw new IOException(\"unexpected character\");\n        return response;\n    }\n\n    private void fill() throws IOException {\n        if (position >= limit) {\n            limit = stream.read(buffer);\n            position = 0;\n            if (limit == -1) {\n                throw new IOException(\"unexpected end of stream\");\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisListImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisListImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisList;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static core.framework.internal.redis.Protocol.Command.LPOP;\nimport static core.framework.internal.redis.Protocol.Command.LRANGE;\nimport static core.framework.internal.redis.Protocol.Command.LTRIM;\nimport static core.framework.internal.redis.Protocol.Command.RPUSH;\nimport static core.framework.internal.redis.RedisEncodings.decode;\nimport static core.framework.internal.redis.RedisEncodings.encode;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author rexthk\n */\npublic final class RedisListImpl implements RedisList {\n    private final Logger logger = LoggerFactory.getLogger(RedisListImpl.class);\n    private final RedisImpl redis;\n\n    RedisListImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public List<String> pop(String key, int size) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (size <= 0) throw new Error(\"size must be greater than 0\");\n        List<String> values = new ArrayList<>(size);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(LPOP, key, encode(size));\n            Object[] response = connection.readArray();\n            if (response != null) {     // lpop returns nil array if no element, this is different behavior of other pop (e.g. spop), it's likely due to blpop impl, use nil array to distinguish between timeout and empty list\n                for (Object value : response) {\n                    values.add(decode((byte[]) value));\n                }\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"lpop, key={}, size={}, returnedValues={}, elapsed={}\", key, size, values, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, values.size(), 0);\n        }\n    }\n\n    @Override\n    public long push(String key, String... values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(RPUSH, key, values);\n            return connection.readLong();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"rpush, key={}, values={}, size={}, elapsed={}\", key, new ArrayLogParam(values), values.length, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, values.length);\n        }\n    }\n\n    @Override\n    public List<String> range(String key, long start, long stop) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        List<String> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(4);\n            connection.writeBlobString(LRANGE);\n            connection.writeBlobString(encode(key));\n            connection.writeBlobString(encode(start));\n            connection.writeBlobString(encode(stop));\n            connection.flush();\n            Object[] response = connection.readArray();\n            values = new ArrayList<>(response.length);\n            for (Object value : response) {\n                values.add(decode((byte[]) value));\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"lrange, key={}, start={}, stop={}, returnedValues={}, elapsed={}\", key, start, stop, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public void trim(String key, int maxSize) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (maxSize <= 0) throw new Error(\"maxSize must be greater than 0\");\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(LTRIM, key, encode(-maxSize), encode(-1));\n            connection.readSimpleString();\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"ltrim, key={}, maxSize={}, elapsed={}\", key, maxSize, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisOutputStream.java."}, {"role": "assistant", "content": "The source code of java class RedisOutputStream.java:\n```java\npackage core.framework.internal.redis;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * refer to https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/RedisOutputStream.java\n * @author neo\n */\nclass RedisOutputStream {\n    private final OutputStream stream;\n    private final byte[] buffer;\n    private int position;\n\n    RedisOutputStream(OutputStream stream, int bufferSize) {\n        this.stream = stream;\n        buffer = new byte[bufferSize];\n    }\n\n    void write(byte value) throws IOException {\n        if (position == buffer.length) {\n            flush();\n        }\n        buffer[position++] = value;\n    }\n\n    void writeBytesCRLF(byte[] bytes) throws IOException {\n        int length = bytes.length;\n        if (length > buffer.length) {\n            flush();\n            stream.write(bytes);\n        } else {\n            if (length > buffer.length - position) {\n                flush();\n            }\n            System.arraycopy(bytes, 0, buffer, position, length);\n            position += length;\n        }\n\n        if (buffer.length - position <= 2) {\n            flush();\n        }\n        buffer[position++] = '\\r';\n        buffer[position++] = '\\n';\n    }\n\n    void flush() throws IOException {\n        if (position > 0) {\n            stream.write(buffer, 0, position);\n            position = 0;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisSetImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisSetImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisSet;\nimport core.framework.util.Sets;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.Set;\n\nimport static core.framework.internal.redis.Protocol.Command.SADD;\nimport static core.framework.internal.redis.Protocol.Command.SCARD;\nimport static core.framework.internal.redis.Protocol.Command.SISMEMBER;\nimport static core.framework.internal.redis.Protocol.Command.SMEMBERS;\nimport static core.framework.internal.redis.Protocol.Command.SPOP;\nimport static core.framework.internal.redis.Protocol.Command.SREM;\nimport static core.framework.internal.redis.RedisEncodings.decode;\nimport static core.framework.internal.redis.RedisEncodings.encode;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author neo\n */\npublic final class RedisSetImpl implements RedisSet {\n    private final Logger logger = LoggerFactory.getLogger(RedisSetImpl.class);\n    private final RedisImpl redis;\n\n    RedisSetImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public long add(String key, String... values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        long addedValues = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(SADD, key, values);\n            addedValues = connection.readLong();\n            return addedValues;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"sadd, key={}, values={}, size={}, elapsed={}\", key, new ArrayLogParam(values), values.length, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, (int) addedValues);\n        }\n    }\n\n    @Override\n    public Set<String> members(String key) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        Set<String> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyCommand(SMEMBERS, key);\n            Object[] response = connection.readArray();\n            values = Sets.newHashSetWithExpectedSize(response.length);\n            for (Object value : response) {\n                values.add(decode((byte[]) value));\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"smembers, key={}, returnedValues={}, elapsed={}\", key, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public boolean isMember(String key, String value) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"value\", value);\n        boolean isMember = false;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(SISMEMBER, key, encode(value));\n            long response = connection.readLong();\n            isMember = response == 1;\n            return isMember;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"sismember, key={}, value={}, isMember={}, elapsed={}\", key, value, isMember, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n\n    @Override\n    public long remove(String key, String... values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        long removedValues = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(SREM, key, values);\n            removedValues = connection.readLong();\n            return removedValues;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            int size = values.length;\n            logger.debug(\"srem, key={}, values={}, size={}, removedValues={}, elapsed={}\", key, new ArrayLogParam(values), size, removedValues, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, size);\n        }\n    }\n\n    @Override\n    public Set<String> pop(String key, long count) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (count <= 0) throw new Error(\"count must be greater than 0\");\n        Set<String> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(SPOP, key, encode(count));\n            Object[] response = connection.readArray();\n            values = Sets.newHashSetWithExpectedSize(response.length);\n            for (Object value : response) {\n                values.add(decode((byte[]) value));\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"spop, key={}, count={}, returnedValues={}, elapsed={}\", key, count, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public long size(String key) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        long size = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyCommand(SCARD, key);\n            size = connection.readLong();\n            return size;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"scard, key={}, size={}, elapsed={}\", key, size, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 1, 0);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisSortedSetImpl.java."}, {"role": "assistant", "content": "The source code of java class RedisSortedSetImpl.java:\n```java\npackage core.framework.internal.redis;\n\nimport core.framework.internal.log.filter.ArrayLogParam;\nimport core.framework.internal.resource.PoolItem;\nimport core.framework.log.ActionLogContext;\nimport core.framework.redis.RedisSortedSet;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.Map;\n\nimport static core.framework.internal.redis.Protocol.Command.ZADD;\nimport static core.framework.internal.redis.Protocol.Command.ZINCRBY;\nimport static core.framework.internal.redis.Protocol.Command.ZPOPMIN;\nimport static core.framework.internal.redis.Protocol.Command.ZRANGE;\nimport static core.framework.internal.redis.Protocol.Command.ZREM;\nimport static core.framework.internal.redis.Protocol.Keyword.BYSCORE;\nimport static core.framework.internal.redis.Protocol.Keyword.LIMIT;\nimport static core.framework.internal.redis.Protocol.Keyword.NX;\nimport static core.framework.internal.redis.Protocol.Keyword.WITHSCORES;\nimport static core.framework.internal.redis.RedisEncodings.decode;\nimport static core.framework.internal.redis.RedisEncodings.encode;\nimport static core.framework.internal.redis.RedisEncodings.validate;\n\n/**\n * @author tempo\n */\npublic class RedisSortedSetImpl implements RedisSortedSet {\n    private final Logger logger = LoggerFactory.getLogger(RedisSortedSetImpl.class);\n    private final RedisImpl redis;\n\n    RedisSortedSetImpl(RedisImpl redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public int add(String key, Map<String, Long> values, boolean onlyIfAbsent) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        int added = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            int length = 2 + values.size() * 2;\n            if (onlyIfAbsent) length++;\n            connection.writeArray(length);\n            connection.writeBlobString(ZADD);\n            connection.writeBlobString(encode(key));\n            if (onlyIfAbsent) connection.writeBlobString(NX);\n            for (Map.Entry<String, Long> entry : values.entrySet()) {\n                connection.writeBlobString(encode(entry.getValue()));\n                connection.writeBlobString(encode(entry.getKey()));\n            }\n            connection.flush();\n            added = (int) connection.readLong();\n            return added;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"zadd, key={}, values={}, onlyIfAbsent={}, added={}, elapsed={}\", key, values, onlyIfAbsent, added, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, added);\n        }\n    }\n\n    @Override\n    public long increaseScoreBy(String key, String value, long increment) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"value\", value);\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        long score = 0;\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(4);\n            connection.writeBlobString(ZINCRBY);\n            connection.writeBlobString(encode(key));\n            connection.writeBlobString(encode(increment));\n            connection.writeBlobString(encode(value));\n            connection.flush();\n            score = (long) Double.parseDouble(decode(connection.readBlobString()));\n            return score;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"zincrby, key={}, value={}, increment={}, score={}, elapsed={}\", key, value, increment, score, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, 1);\n        }\n    }\n\n    @Override\n    public Map<String, Long> range(String key, long start, long stop) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        Map<String, Long> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeArray(5);\n            connection.writeBlobString(ZRANGE);\n            connection.writeBlobString(encode(key));\n            connection.writeBlobString(encode(start));\n            connection.writeBlobString(encode(stop));\n            connection.writeBlobString(WITHSCORES);\n            connection.flush();\n            Object[] response = connection.readArray();\n            values = valuesWithScores(response);\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"zrange, key={}, start={}, stop={}, returnedValues={}, elapsed={}\", key, start, stop, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public Map<String, Long> rangeByScore(String key, long minScore, long maxScore, long limit) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (limit == 0) throw new Error(\"limit must not be 0\");\n        if (maxScore < minScore) throw new Error(\"maxScore must be larger than minScore\");\n\n        Map<String, Long> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            Object[] response = rangeByScore(connection, key, minScore, maxScore, limit);\n            values = valuesWithScores(response);\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"zrangeByScore, key={}, minScore={}, maxScore={}, limit={}, returnedValues={}, elapsed={}\", key, minScore, maxScore, limit, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    private Object[] rangeByScore(RedisConnection connection, String key, long minScore, long maxScore, long limit) throws IOException {\n        connection.writeArray(9);\n        connection.writeBlobString(ZRANGE);\n        connection.writeBlobString(encode(key));\n        connection.writeBlobString(encode(minScore));\n        connection.writeBlobString(encode(maxScore));\n        connection.writeBlobString(BYSCORE);\n        connection.writeBlobString(WITHSCORES);\n        connection.writeBlobString(LIMIT);\n        connection.writeBlobString(encode(0));\n        connection.writeBlobString(encode(limit));\n        connection.flush();\n        return connection.readArray();\n    }\n\n    @Override\n    public Map<String, Long> popByScore(String key, long minScore, long maxScore, long limit) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (limit == 0) throw new Error(\"limit must not be 0\");\n        if (maxScore < minScore) throw new Error(\"stop must be larger than start\");\n\n        int fetchedEntries = 0;\n        Map<String, Long> values = null;\n        int size = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            Object[] response = rangeByScore(connection, key, minScore, maxScore, -1);\n            if (response.length % 2 != 0) throw new IOException(\"unexpected length of array, length=\" + response.length);\n            values = Maps.newLinkedHashMapWithExpectedSize(response.length / 2);\n            fetchedEntries = response.length / 2;\n            for (int i = 0; i < response.length; i += 2) {\n                byte[] value = (byte[]) response[i];\n                connection.writeKeyArgumentCommand(ZREM, key, value);\n                long removed = connection.readLong();\n                if (removed == 1L) {\n                    values.put(decode(value), (long) Double.parseDouble(decode((byte[]) response[i + 1])));\n                    size++;\n                    if (limit > 0 && size >= limit) break;\n                }\n            }\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"popByScore, key={}, minScore={}, maxScore={}, limit={}, returnedValues={}, size={}, elapsed={}\", key, minScore, maxScore, limit, values, size, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, fetchedEntries, size);\n        }\n    }\n\n    @Override\n    public Map<String, Long> popMin(String key, long limit) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        if (limit <= 0) throw new Error(\"limit must be greater than 0\");\n        Map<String, Long> values = null;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentCommand(ZPOPMIN, key, encode(limit));\n            Object[] response = connection.readArray();\n            values = valuesWithScores(response);\n            return values;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            logger.debug(\"zpopmin, key={}, limit={}, returnedValues={}, elapsed={}\", key, limit, values, elapsed);\n            int readEntries = values == null ? 0 : values.size();\n            ActionLogContext.track(\"redis\", elapsed, readEntries, 0);\n        }\n    }\n\n    @Override\n    public long remove(String key, String... values) {\n        var watch = new StopWatch();\n        validate(\"key\", key);\n        validate(\"values\", values);\n        long removedValues = 0;\n        PoolItem<RedisConnection> item = redis.pool.borrowItem();\n        try {\n            RedisConnection connection = item.resource;\n            connection.writeKeyArgumentsCommand(ZREM, key, values);\n            removedValues = connection.readLong();\n            return removedValues;\n        } catch (IOException e) {\n            item.broken = true;\n            throw new UncheckedIOException(e);\n        } finally {\n            redis.pool.returnItem(item);\n            long elapsed = watch.elapsed();\n            int size = values.length;\n            logger.debug(\"zrem, key={}, values={}, size={}, removedValues={}, elapsed={}\", key, new ArrayLogParam(values), size, removedValues, elapsed);\n            ActionLogContext.track(\"redis\", elapsed, 0, size);\n        }\n    }\n\n    private Map<String, Long> valuesWithScores(Object[] response) throws IOException {\n        if (response.length % 2 != 0) throw new IOException(\"unexpected length of array, length=\" + response.length);\n        Map<String, Long> values = Maps.newLinkedHashMapWithExpectedSize(response.length / 2);\n        for (int i = 0; i < response.length; i += 2) {\n            values.put(decode((byte[]) response[i]), (long) Double.parseDouble(decode((byte[]) response[i + 1])));\n        }\n        return values;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Classes.java."}, {"role": "assistant", "content": "The source code of java class Classes.java:\n```java\npackage core.framework.internal.reflect;\n\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic final class Classes {\n    public static List<Field> instanceFields(Class<?> instanceClass) {\n        // even though according to JDK doc, the fields returned is not in particular order, but common JDK impl follows field declaration order of source code\n        return Arrays.stream(instanceClass.getDeclaredFields())\n            .filter(field -> !Modifier.isStatic(field.getModifiers())).toList();\n    }\n\n    public static List<Field> enumConstantFields(Class<?> enumClass) {\n        return Arrays.stream(enumClass.getDeclaredFields())\n            .filter(Field::isEnumConstant).toList();\n    }\n\n    // return class name without package, e.g. for nested class will be EnclosingClass$NestedClass\n    public static String className(Class<?> valueClass) {\n        String name = valueClass.getName();\n        int index = name.lastIndexOf('.');\n        if (index < 0) return name;\n        return name.substring(index + 1);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Enums.java."}, {"role": "assistant", "content": "The source code of java class Enums.java:\n```java\npackage core.framework.internal.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\n\n/**\n * @author neo\n */\npublic final class Enums {\n    public static <T extends Enum<?>, A extends Annotation> A constantAnnotation(T constant, Class<A> annotationClass) {\n        try {\n            Field field = constant.getDeclaringClass().getField(constant.name());\n            return field.getDeclaredAnnotation(annotationClass);\n        } catch (NoSuchFieldException e) {\n            throw new Error(e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Fields.java."}, {"role": "assistant", "content": "The source code of java class Fields.java:\n```java\npackage core.framework.internal.reflect;\n\nimport java.lang.reflect.Field;\n\n/**\n * @author neo\n */\npublic final class Fields {\n    public static String path(Field field) {\n        return field.getDeclaringClass().getTypeName() + \".\" + field.getName();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class GenericTypes.java."}, {"role": "assistant", "content": "The source code of java class GenericTypes.java:\n```java\npackage core.framework.internal.reflect;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic final class GenericTypes {\n    public static Class<?> rawClass(Type type) {\n        if (type instanceof Class) {\n            return (Class<?>) type;\n        } else if (type instanceof final ParameterizedType parameterizedType) {\n            return (Class<?>) parameterizedType.getRawType();\n        } else {\n            throw new Error(\"unsupported type, type=\" + type);\n        }\n    }\n\n    public static boolean isList(Type type) {\n        return List.class.isAssignableFrom(rawClass(type));\n    }\n\n    public static boolean isGenericList(Type type) {\n        if (type instanceof ParameterizedType parameterizedType) {\n            Class<?> rawClass = (Class<?>) parameterizedType.getRawType();\n            return List.class.isAssignableFrom(rawClass) && parameterizedType.getActualTypeArguments()[0] instanceof Class;\n        }\n        return false;\n    }\n\n    public static Class<?> listValueClass(Type type) {\n        return (Class<?>) ((ParameterizedType) type).getActualTypeArguments()[0];\n    }\n\n    public static boolean isOptional(Type type) {\n        return Optional.class.equals(rawClass(type));\n    }\n\n    public static boolean isGenericOptional(Type type) {\n        if (type instanceof ParameterizedType parameterizedType) {\n            Class<?> rawClass = (Class<?>) parameterizedType.getRawType();\n            return Optional.class.equals(rawClass) && parameterizedType.getActualTypeArguments()[0] instanceof Class;\n        }\n        return false;\n    }\n\n    public static Class<?> optionalValueClass(Type type) {\n        return (Class<?>) ((ParameterizedType) type).getActualTypeArguments()[0];\n    }\n\n    public static boolean isMap(Type type) {\n        return Map.class.isAssignableFrom(rawClass(type));\n    }\n\n    public static boolean isGenericMap(Type type) {\n        if (!(type instanceof ParameterizedType)) return false;\n\n        Type[] arguments = ((ParameterizedType) type).getActualTypeArguments();\n        return arguments[0] instanceof Class && (arguments[1] instanceof Class || isGenericList(arguments[1]));\n    }\n\n    public static Class<?> mapKeyClass(Type type) {\n        return (Class<?>) ((ParameterizedType) type).getActualTypeArguments()[0];\n    }\n\n    public static Type mapValueType(Type type) {\n        return ((ParameterizedType) type).getActualTypeArguments()[1];\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Methods.java."}, {"role": "assistant", "content": "The source code of java class Methods.java:\n```java\npackage core.framework.internal.reflect;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\n/**\n * @author neo\n */\npublic final class Methods {\n    public static String path(Method method) {\n        var builder = new StringBuilder();\n        builder.append(method.getDeclaringClass().getCanonicalName())\n                .append('.')\n                .append(method.getName())\n                .append('(');\n        Type[] paramTypes = method.getGenericParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            if (i > 0) builder.append(\", \");\n            builder.append(paramTypeName(paramTypes[i]));\n        }\n        builder.append(')');\n        return builder.toString();\n    }\n\n    private static String paramTypeName(Type paramType) {\n        // shorten common types\n        if (String.class.equals(paramType)) return \"String\";\n        if (Integer.class.equals(paramType)) return \"Integer\";\n        if (Long.class.equals(paramType)) return \"Long\";\n        return paramType.getTypeName();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Params.java."}, {"role": "assistant", "content": "The source code of java class Params.java:\n```java\npackage core.framework.internal.reflect;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * @author neo\n */\npublic final class Params {\n    public static <T extends Annotation> T annotation(Annotation[] paramAnnotations, Class<T> annotationClass) {\n        for (Annotation annotation : paramAnnotations) {\n            if (annotation.annotationType().equals(annotationClass)) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) annotation;\n                return result;\n            }\n        }\n        return null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Pool.java."}, {"role": "assistant", "content": "The source code of java class Pool.java:\n```java\npackage core.framework.internal.resource;\n\nimport core.framework.util.StopWatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Supplier;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * this is for internal use only,\n * <p>\n * the reason not using template/lambda pattern but classic design\n * is to keep original exception, and simplify context variable access (read or write var within method),\n * <p>\n * the downside is boilerplate code, so to keep it only for internal\n *\n * @author neo\n */\npublic class Pool<T extends AutoCloseable> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Pool.class);\n\n    // helper for closing resource on creation failure\n    public static void closeQuietly(AutoCloseable resource) {\n        if (resource != null) {\n            try {\n                resource.close();\n            } catch (Exception e) {\n                LOGGER.warn(\"failed to close resource\", e);\n            }\n        }\n    }\n\n    final BlockingDeque<PoolItem<T>> idleItems = new LinkedBlockingDeque<>();\n    final String name;\n    final AtomicInteger size = new AtomicInteger(0);\n    private final Supplier<T> factory;\n    public Duration maxIdleTime = Duration.ofMinutes(30);\n    private int minSize = 1;\n    private int maxSize = 50;\n    private long checkoutTimeoutInMs = Duration.ofSeconds(30).toMillis();\n    private ResourceValidator<T> validator;\n    private long aliveWindowInMs;    // not to validate if last return time within the window\n\n    public Pool(Supplier<T> factory, String name) {\n        this.factory = factory;\n        this.name = name;\n    }\n\n    public void size(int minSize, int maxSize) {\n        this.minSize = minSize;\n        this.maxSize = maxSize;\n    }\n\n    public void checkoutTimeout(Duration timeout) {\n        checkoutTimeoutInMs = timeout.toMillis();\n    }\n\n    public void validator(ResourceValidator<T> validator, Duration aliveWindow) {\n        this.validator = validator;\n        aliveWindowInMs = aliveWindow.toMillis();\n    }\n\n    public PoolItem<T> borrowItem() {\n        while (true) {\n            PoolItem<T> item = idleItems.poll();\n            if (item != null) {\n                if (validate(item)) return item;\n                else continue;\n            }\n\n            if (size.get() < maxSize) {\n                return createNewItem();         // do not need to check newly created resource\n            } else {\n                return waitNextAvailableItem(); // do not need to check valid since it's just returned resource\n            }\n        }\n    }\n\n    private boolean validate(PoolItem<T> item) {\n        if (validator == null || System.currentTimeMillis() - item.returnTime < aliveWindowInMs) return true;\n        boolean valid;\n        try {\n            valid = validator.validate(item.resource);\n        } catch (Throwable e) {     // catch all exceptions to make sure item will be closed to avoid resource leak\n            LOGGER.warn(e.getMessage(), e);\n            valid = false;\n        }\n        if (!valid) {\n            LOGGER.warn(errorCode(\"BROKEN_POOL_CONNECTION\"), \"connection is broken, try to reconnect immediately, pool=\" + name);\n            closeItem(item);\n        }\n        return valid;\n    }\n\n    public void returnItem(PoolItem<T> item) {\n        if (item.broken) {\n            // not to replenish new item if current is broken to keep it simple,\n            // if pool is full and someone is waiting for resource, there will be other to release resource soon,\n            // as the broken resource is rare case\n            closeItem(item);\n        } else {\n            item.returnTime = System.currentTimeMillis();\n            idleItems.push(item);\n        }\n    }\n\n    private PoolItem<T> waitNextAvailableItem() {\n        var watch = new StopWatch();\n        try {\n            PoolItem<T> item = idleItems.poll(checkoutTimeoutInMs, TimeUnit.MILLISECONDS);\n            if (item == null) throw new PoolException(\"timeout to wait for next available resource\", \"POOL_TIME_OUT\");\n            return item;\n        } catch (InterruptedException e) {\n            throw new Error(\"interrupted during waiting for next available resource\", e);\n        } finally {\n            LOGGER.debug(\"wait for next available resource, pool={}, elapsed={}\", name, watch.elapsed());\n        }\n    }\n\n    private PoolItem<T> createNewItem() {\n        var watch = new StopWatch();\n        size.incrementAndGet();\n        try {\n            return new PoolItem<>(factory.get());\n        } catch (Throwable e) {\n            size.getAndDecrement();\n            throw e;\n        } finally {\n            LOGGER.debug(\"create new resource, pool={}, elapsed={}\", name, watch.elapsed());\n        }\n    }\n\n    public void refresh() {\n        LOGGER.info(\"refresh resource pool, pool={}\", name);\n        evictIdleItems();\n        replenish();\n    }\n\n    int activeCount() {\n        return totalCount() - idleItems.size();\n    }\n\n    int totalCount() {\n        return size.get();\n    }\n\n    private void evictIdleItems() {\n        Iterator<PoolItem<T>> iterator = idleItems.descendingIterator();\n        long maxIdleTimeInMs = maxIdleTime.toMillis();\n        long now = System.currentTimeMillis();\n\n        while (iterator.hasNext()) {\n            PoolItem<T> item = iterator.next();\n            if (now - item.returnTime >= maxIdleTimeInMs) {\n                boolean removed = idleItems.remove(item);\n                if (!removed) return;\n                closeItem(item);\n            } else {\n                return;\n            }\n        }\n    }\n\n    private void replenish() {\n        while (size.get() < minSize) {\n            returnItem(createNewItem());\n        }\n    }\n\n    private void closeItem(PoolItem<T> item) {\n        size.decrementAndGet();\n        closeResource(item);\n    }\n\n    private void closeResource(PoolItem<T> item) {\n        try {\n            item.resource.close();\n        } catch (Exception e) {\n            LOGGER.warn(\"failed to close resource, pool={}\", name, e);\n        }\n    }\n\n    public void close() {\n        size.set(maxSize);   // make sure no more new resource will be created\n        while (true) {\n            PoolItem<T> item = idleItems.poll();\n            if (item == null) return;\n            closeResource(item);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PoolException.java."}, {"role": "assistant", "content": "The source code of java class PoolException.java:\n```java\npackage core.framework.internal.resource;\n\nimport core.framework.log.ErrorCode;\n\n/**\n * @author neo\n */\npublic final class PoolException extends RuntimeException implements ErrorCode {\n    private static final long serialVersionUID = 2151045905336463247L;\n\n    private final String errorCode;\n\n    PoolException(String message, String errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    @Override\n    public String errorCode() {\n        return errorCode;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PoolItem.java."}, {"role": "assistant", "content": "The source code of java class PoolItem.java:\n```java\npackage core.framework.internal.resource;\n\n/**\n * @author neo\n */\npublic final class PoolItem<T> {\n    public final T resource;\n    public boolean broken;\n    long returnTime;    // according to profiling, use System.currentTimeMillis instead of Instant.now()\n\n    public PoolItem(T resource) {\n        this.resource = resource;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PoolMetrics.java."}, {"role": "assistant", "content": "The source code of java class PoolMetrics.java:\n```java\npackage core.framework.internal.resource;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\n\n/**\n * @author neo\n */\npublic class PoolMetrics implements Metrics {\n    private final Pool<?> pool;\n\n    public PoolMetrics(Pool<?> pool) {\n        this.pool = pool;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        stats.put(statName(\"total_count\"), pool.totalCount());\n        stats.put(statName(\"active_count\"), pool.activeCount());\n    }\n\n    String statName(String statName) {\n        return \"pool_\" + pool.name + '_' + statName;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResourceValidator.java."}, {"role": "assistant", "content": "The source code of java class ResourceValidator.java:\n```java\npackage core.framework.internal.resource;\n\n/**\n * @author neo\n */\npublic interface ResourceValidator<T> {\n    boolean validate(T resource) throws Throwable;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DailyTrigger.java."}, {"role": "assistant", "content": "The source code of java class DailyTrigger.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Trigger;\n\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\npublic final class DailyTrigger implements Trigger {\n    private final LocalTime time;\n\n    public DailyTrigger(LocalTime time) {\n        this.time = time;\n    }\n\n    @Override\n    public ZonedDateTime next(ZonedDateTime previous) {\n        ZonedDateTime next = previous.with(time);\n        if (!next.isAfter(previous)) {\n            next = next.plusDays(1).with(time);     // reset time in case the current day is daylight saving start date\n        }\n        return next;\n    }\n\n    @Override\n    public String toString() {\n        return \"daily@\" + time;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FixedRateTask.java."}, {"role": "assistant", "content": "The source code of java class FixedRateTask.java:\n```java\npackage core.framework.internal.scheduler;\n\n\nimport core.framework.scheduler.Job;\n\nimport java.time.Duration;\nimport java.time.ZonedDateTime;\n\n/**\n * @author neo\n */\npublic final class FixedRateTask implements Task {\n    final Duration rate;\n    private final String name;\n    private final Job job;\n    ZonedDateTime scheduledTime;\n\n    FixedRateTask(String name, Job job, Duration rate) {\n        this.name = name;\n        this.job = job;\n        this.rate = rate;\n    }\n\n    @Override\n    public String name() {\n        return name;\n    }\n\n    @Override\n    public Job job() {\n        return job;\n    }\n\n    @Override\n    public String trigger() {\n        return \"fixedRate@\" + rate;\n    }\n\n    ZonedDateTime scheduleNext() {  // only for tracking scheduled time of JobContext, the actual scheduling is managed java scheduler\n        scheduledTime = scheduledTime.plus(rate);\n        return scheduledTime;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HourlyTrigger.java."}, {"role": "assistant", "content": "The source code of java class HourlyTrigger.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Trigger;\n\nimport java.time.ZonedDateTime;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author keith\n */\npublic final class HourlyTrigger implements Trigger {\n    private final int minute;\n    private final int second;\n\n    public HourlyTrigger(int minute, int second) {\n        this.minute = minute;\n        this.second = second;\n\n        if (minute < 0 || minute > 59) {\n            throw new Error(\"minute is out of range, please use 0-59, minute=\" + minute);\n        }\n        if (second < 0 || second > 59) {\n            throw new Error(\"second is out of range, please use 0-59, second=\" + second);\n        }\n    }\n\n    @Override\n    public ZonedDateTime next(ZonedDateTime previous) {\n        ZonedDateTime next = previous.withMinute(minute).withSecond(second).withNano(0);\n        if (!next.isAfter(previous)) {\n            next = next.plusHours(1);\n        }\n        return next;\n    }\n\n    @Override\n    public String toString() {\n        return format(\"hourly@{}:{}\", minute, second);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MonthlyTrigger.java."}, {"role": "assistant", "content": "The source code of java class MonthlyTrigger.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Trigger;\n\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author tminglei, neo\n */\npublic final class MonthlyTrigger implements Trigger {\n    private final int dayOfMonth;\n    private final LocalTime time;\n\n    public MonthlyTrigger(int dayOfMonth, LocalTime time) {\n        this.dayOfMonth = dayOfMonth;\n        this.time = time;\n\n        if (dayOfMonth < 1 || dayOfMonth > 28) {\n            throw new Error(\"dayOfMonth is out of range, please use 1-28, dayOfMonth=\" + dayOfMonth);\n        }\n    }\n\n    @Override\n    public ZonedDateTime next(ZonedDateTime previous) {\n        ZonedDateTime next = previous.withDayOfMonth(dayOfMonth).with(time);\n        if (!next.isAfter(previous)) {\n            next = next.plusMonths(1).with(time);     // reset time in case the current day is daylight saving start date\n        }\n        return next;\n    }\n\n    @Override\n    public String toString() {\n        return format(\"monthly@{}/{}\", dayOfMonth, time);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Scheduler.java."}, {"role": "assistant", "content": "The source code of java class Scheduler.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.internal.async.ThreadPools;\nimport core.framework.internal.async.VirtualThread;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport core.framework.scheduler.Job;\nimport core.framework.scheduler.JobContext;\nimport core.framework.scheduler.Trigger;\nimport core.framework.util.Maps;\nimport core.framework.util.Randoms;\nimport core.framework.web.exception.NotFoundException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.time.Clock;\nimport java.time.Duration;\nimport java.time.ZonedDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport static core.framework.log.Markers.errorCode;\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class Scheduler {\n    public final Map<String, Task> tasks = Maps.newLinkedHashMap();     // to log scheduling job in order at startup\n    private final Logger logger = LoggerFactory.getLogger(Scheduler.class);\n    private final ScheduledExecutorService scheduler;\n    private final ExecutorService jobExecutor;\n    private final LogManager logManager;\n    private final long maxProcessTimeInNano = Duration.ofSeconds(10).toNanos(); // scheduler job should be fast, it may block other jobs, generally just sending kafka message\n    public Clock clock = Clock.systemUTC();\n\n    public Scheduler(LogManager logManager) {\n        this(logManager, ThreadPools.singleThreadScheduler(\"scheduler-\"), ThreadPools.virtualThreadExecutor(\"scheduler-job-\"));\n    }\n\n    Scheduler(LogManager logManager, ScheduledExecutorService scheduler, ExecutorService jobExecutor) {\n        this.logManager = logManager;\n        this.scheduler = scheduler;\n        this.jobExecutor = jobExecutor;\n    }\n\n    public void start() {\n        var now = ZonedDateTime.now(clock);\n        for (var entry : tasks.entrySet()) {\n            String name = entry.getKey();\n            Task task = entry.getValue();\n            if (task instanceof final FixedRateTask fixedRateTask) {\n                schedule(fixedRateTask);\n                logger.info(\"schedule job, job={}, trigger={}, jobClass={}\", name, task.trigger(), task.job().getClass().getCanonicalName());\n            } else if (task instanceof TriggerTask triggerTask) {\n                try {\n                    ZonedDateTime next = next(triggerTask.trigger, now);\n                    schedule(triggerTask, next);\n                    logger.info(\"schedule job, job={}, trigger={}, jobClass={}, next={}\", name, task.trigger(), task.job().getClass().getCanonicalName(), next);\n                } catch (Throwable e) {\n                    logger.error(\"failed to schedule job, job={}\", name, e);  // next() with custom trigger impl may throw exception, we don't let runtime error fail startup\n                }\n            }\n        }\n        logger.info(\"scheduler started\");\n    }\n\n    public void shutdown() throws InterruptedException {\n        logger.info(\"shutting down scheduler\");\n        scheduler.shutdown();\n        try {\n            boolean success = scheduler.awaitTermination(5000, TimeUnit.MILLISECONDS);\n            if (!success) logger.warn(\"failed to terminate scheduler\");\n        } finally {\n            jobExecutor.shutdown();\n        }\n    }\n\n    public void awaitTermination(long timeoutInMs) throws InterruptedException {\n        boolean success = jobExecutor.awaitTermination(timeoutInMs, TimeUnit.MILLISECONDS);\n        if (!success) logger.warn(errorCode(\"FAILED_TO_STOP\"), \"failed to terminate scheduler job executor\");\n        else logger.info(\"scheduler stopped\");\n    }\n\n    public void addFixedRateTask(String name, Job job, Duration rate) {\n        addTask(new FixedRateTask(name, job, rate));\n    }\n\n    public void addTriggerTask(String name, Job job, Trigger trigger) {\n        addTask(new TriggerTask(name, job, trigger, clock.getZone()));\n    }\n\n    private void addTask(Task task) {\n        String name = task.name();\n        Task previous = tasks.putIfAbsent(name, task);\n        if (previous != null)\n            throw new Error(format(\"found duplicate job, name={}, previous={}\", name, previous.job().getClass().getCanonicalName()));\n    }\n\n    ZonedDateTime next(Trigger trigger, ZonedDateTime previous) {\n        ZonedDateTime next = trigger.next(previous);\n        if (next == null || !next.isAfter(previous)) throw new Error(format(\"next scheduled time must be after previous, previous={}, next={}\", previous, next));\n        return next;\n    }\n\n    void schedule(TriggerTask task, ZonedDateTime time) {\n        ZonedDateTime now = ZonedDateTime.now(clock);\n        Duration delay = Duration.between(now, time);\n        scheduler.schedule(() -> executeTask(task, time), delay.toNanos(), TimeUnit.NANOSECONDS);\n    }\n\n    void schedule(FixedRateTask task) {\n        Duration delay = Duration.ofMillis((long) Randoms.nextDouble(1000, 3000)); // delay 1s to 3s to shuffle fix rated jobs\n        task.scheduledTime = ZonedDateTime.now(clock).plus(delay);\n        scheduler.scheduleAtFixedRate(() -> {\n            ZonedDateTime scheduledTime = task.scheduledTime;\n            ZonedDateTime next = task.scheduleNext();\n            logger.info(\"execute scheduled job, job={}, rate={}, scheduled={}, next={}\", task.name(), task.rate, scheduledTime, next);\n            submitJob(task, scheduledTime, null);\n        }, delay.toNanos(), task.rate.toNanos(), TimeUnit.NANOSECONDS);\n    }\n\n    void executeTask(TriggerTask task, ZonedDateTime scheduledTime) {\n        try {\n            ZonedDateTime next = next(task.trigger, scheduledTime);\n            schedule(task, next);\n            logger.info(\"execute scheduled job, job={}, trigger={}, scheduled={}, next={}\", task.name(), task.trigger(), scheduledTime, next);\n            submitJob(task, scheduledTime, null);\n        } catch (Throwable e) {\n            logger.error(\"failed to execute scheduled job, job is terminated, job={}, error={}\", task.name(), e.getMessage(), e);\n        }\n    }\n\n    public void triggerNow(String name, String triggerActionId) {\n        Task task = tasks.get(name);\n        if (task == null) throw new NotFoundException(\"job not found, name=\" + name);\n        submitJob(task, ZonedDateTime.now(clock), triggerActionId);\n    }\n\n    private void submitJob(Task task, ZonedDateTime scheduledTime, @Nullable String triggerActionId) {\n        jobExecutor.submit(() -> {\n            VirtualThread.COUNT.increase();\n            ActionLog actionLog = logManager.begin(\"=== job execution begin ===\", null);\n            try {\n                String name = task.name();\n                actionLog.action(\"job:\" + name);\n                if (triggerActionId != null) {  // triggered by scheduler controller\n                    actionLog.refIds = List.of(triggerActionId);\n                    actionLog.correlationIds = List.of(triggerActionId);\n                    actionLog.trace = Trace.CASCADE;\n                }\n                actionLog.warningContext.maxProcessTimeInNano(maxProcessTimeInNano);\n                actionLog.context(\"trigger\", task.trigger());\n                Job job = task.job();\n                actionLog.context(\"job\", name);\n                actionLog.context(\"job_class\", job.getClass().getCanonicalName());\n                actionLog.context(\"scheduled_time\", scheduledTime.toInstant());\n                job.execute(new JobContext(name, scheduledTime));\n                return null;\n            } catch (Throwable e) {\n                logManager.logError(e);\n                throw e;\n            } finally {\n                logManager.end(\"=== job execution end ===\");\n                VirtualThread.COUNT.decrease();\n            }\n        });\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Task.java."}, {"role": "assistant", "content": "The source code of java class Task.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Job;\n\n/**\n * @author neo\n */\npublic interface Task {\n    String name();\n\n    Job job();\n\n    String trigger();\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TriggerTask.java."}, {"role": "assistant", "content": "The source code of java class TriggerTask.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Job;\nimport core.framework.scheduler.Trigger;\nimport core.framework.util.Strings;\n\nimport java.time.ZoneId;\n\n/**\n * @author neo\n */\npublic class TriggerTask implements Task {\n    final Trigger trigger;\n    private final String name;\n    private final Job job;\n    private final ZoneId zoneId;\n\n    TriggerTask(String name, Job job, Trigger trigger, ZoneId zoneId) {\n        this.name = name;\n        this.trigger = trigger;\n        this.job = job;\n        this.zoneId = zoneId;\n    }\n\n    @Override\n    public String name() {\n        return name;\n    }\n\n    @Override\n    public Job job() {\n        return job;\n    }\n\n    @Override\n    public String trigger() {\n        return Strings.format(\"{}[{}]\", trigger, zoneId);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WeeklyTrigger.java."}, {"role": "assistant", "content": "The source code of java class WeeklyTrigger.java:\n```java\npackage core.framework.internal.scheduler;\n\nimport core.framework.scheduler.Trigger;\nimport core.framework.util.Strings;\n\nimport java.time.DayOfWeek;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\n\n/**\n * @author tminglei, neo\n */\npublic final class WeeklyTrigger implements Trigger {\n    private final DayOfWeek dayOfWeek;\n    private final LocalTime time;\n\n    public WeeklyTrigger(DayOfWeek dayOfWeek, LocalTime time) {\n        this.dayOfWeek = dayOfWeek;\n        this.time = time;\n    }\n\n    @Override\n    public ZonedDateTime next(ZonedDateTime previous) {\n        ZonedDateTime next = previous.plusDays(dayOfWeek.getValue() - previous.getDayOfWeek().getValue()).with(time);\n        if (!next.isAfter(previous)) {\n            next = next.plusWeeks(1).with(time);     // reset time in case the current day is daylight saving start date\n        }\n        return next;\n    }\n\n    @Override\n    public String toString() {\n        return Strings.format(\"weekly@{}/{}\", dayOfWeek, time);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Counter.java."}, {"role": "assistant", "content": "The source code of java class Counter.java:\n```java\npackage core.framework.internal.stat;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n// to track max count between collecting\npublic class Counter {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicInteger max = new AtomicInteger(0);\n\n    public void increase() {\n        int current = count.incrementAndGet();\n        max.getAndAccumulate(current, Math::max);     // only increase() may change max, no need to handle when decrease()\n    }\n\n    public int get() {\n        return count.get();\n    }\n\n    public int max() {\n        return max.getAndSet(count.get());\n    }\n\n    public int decrease() {\n        return count.decrementAndGet();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Diagnostic.java."}, {"role": "assistant", "content": "The source code of java class Diagnostic.java:\n```java\npackage core.framework.internal.stat;\n\nimport core.framework.util.Files;\n\nimport javax.management.InstanceNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.ObjectName;\nimport javax.management.ReflectionException;\nimport java.lang.management.ManagementFactory;\nimport java.nio.file.Path;\n\n/**\n * @author neo\n */\npublic class Diagnostic {\n    public static String thread() {\n        return invokeDiagnosticCommand(\"threadPrint\", \"-e\", \"-l\");\n    }\n\n    public static String vm() {\n        return invokeDiagnosticCommand(\"vmInfo\");\n    }\n\n    public static String heap() {\n        return invokeDiagnosticCommand(\"gcClassHistogram\");\n    }\n\n    // enable by -XX:NativeMemoryTracking=summary\n    public static String nativeMemory() {\n        return invokeDiagnosticCommand(\"vmNativeMemory\", \"summary\");\n    }\n\n    // currently Java 21 only support dump virtual thread to file\n    // refer to com.sun.management.internal.HotSpotDiagnostic.dumpThreads(java.lang.String, com.sun.management.HotSpotDiagnosticMXBean.ThreadDumpFormat)\n    public static String virtualThread() {\n        Path path = Files.tempFile();\n        try {\n            MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n            var name = new ObjectName(\"com.sun.management\", \"type\", \"HotSpotDiagnostic\");\n            server.invoke(name, \"dumpThreads\", new Object[]{path.toAbsolutePath().toString(), \"TEXT_PLAIN\"}, new String[]{String.class.getName(), String.class.getName()});\n            return Files.text(path);\n        } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanException | ReflectionException e) {\n            throw new Error(e);\n        } finally {\n            Files.delete(path);\n        }\n    }\n\n    // use \"jcmd pid help\" to list all operations,\n    // refer to com.sun.management.internal.DiagnosticCommandImpl.getMBeanInfo, all command names are transformed\n    private static String invokeDiagnosticCommand(String operation, String... params) {\n        try {\n            MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n            var name = new ObjectName(\"com.sun.management\", \"type\", \"DiagnosticCommand\");\n            return (String) server.invoke(name, operation, new Object[]{params}, new String[]{String[].class.getName()});\n        } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanException | ReflectionException e) {\n            throw new Error(e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class GCStat.java."}, {"role": "assistant", "content": "The source code of java class GCStat.java:\n```java\npackage core.framework.internal.stat;\n\nimport javax.annotation.Nullable;\nimport java.lang.management.GarbageCollectorMXBean;\n\n/**\n * @author neo\n */\nfinal class GCStat {\n    @Nullable\n    static GCStat of(GarbageCollectorMXBean bean) {\n        String name = collector(bean.getName());\n        if (name == null) return null;\n        return new GCStat(bean, name);\n    }\n\n    static String collector(String collectorName) {\n        // -XX:+UseG1GC\n        if (collectorName.contains(\"Young\")) return \"young\";\n        if (collectorName.contains(\"Old\")) return \"old\";\n        // -XX:+UseParallelGC\n        if (collectorName.contains(\"Scavenge\")) return \"young\";\n        if (collectorName.contains(\"MarkSweep\")) return \"old\";\n        return null;   // ignore not supported collector\n    }\n\n    final String name;\n    private final GarbageCollectorMXBean bean;\n    private long previousCount = -1; // generally only one thread collects stat, so no concurrency issue\n    private long previousElapsed = -1;\n\n    private GCStat(GarbageCollectorMXBean bean, String name) {\n        this.bean = bean;\n        this.name = name;\n    }\n\n    long count() {\n        long previous = previousCount;\n        long current = bean.getCollectionCount();\n        previousCount = current;\n        if (previous == -1) return 0;   // ignore first data point, only count changes, as monitor just started\n        return current - previous;\n    }\n\n    long elapsed() {\n        long previous = previousElapsed;\n        long current = bean.getCollectionTime();\n        previousElapsed = current;\n        if (previous == -1) return 0;   // ignore first data point, only count changes, as monitor just started\n        return (current - previous) * 1_000_000; // convert to nano\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Metrics.java."}, {"role": "assistant", "content": "The source code of java class Metrics.java:\n```java\npackage core.framework.internal.stat;\n\n/**\n * @author neo\n */\npublic interface Metrics {\n    void collect(Stats stats);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StatCollector.java."}, {"role": "assistant", "content": "The source code of java class StatCollector.java:\n```java\npackage core.framework.internal.stat;\n\nimport com.sun.management.OperatingSystemMXBean;\nimport core.framework.internal.async.VirtualThread;\nimport core.framework.util.Files;\nimport core.framework.util.Lists;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.management.GarbageCollectorMXBean;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MemoryMXBean;\nimport java.lang.management.MemoryUsage;\nimport java.lang.management.ThreadMXBean;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class StatCollector {\n    public final List<Metrics> metrics = Lists.newArrayList();\n\n    private final Logger logger = LoggerFactory.getLogger(StatCollector.class);\n    private final OperatingSystemMXBean os = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n    private final ThreadMXBean thread = ManagementFactory.getThreadMXBean();\n    private final MemoryMXBean memory = ManagementFactory.getMemoryMXBean();\n    private final List<GCStat> gcStats = new ArrayList<>(2);\n    private final boolean supportMemoryTracking;\n    private final Path procPath = Path.of(\"/proc/self/statm\");\n\n    public double highCPUUsageThreshold = 0.8;\n    public double highHeapUsageThreshold = 0.8;\n    public double highMemUsageThreshold = 0.8;  // the java process RSS usage\n\n    public StatCollector() {\n        List<GarbageCollectorMXBean> beans = ManagementFactory.getGarbageCollectorMXBeans();\n        for (GarbageCollectorMXBean bean : beans) {\n            GCStat stat = GCStat.of(bean);\n            if (stat != null) gcStats.add(stat);\n        }\n        supportMemoryTracking = java.nio.file.Files.exists(procPath);\n    }\n\n    public void collectJVMUsage(Stats stats) {\n        collectCPUUsage(stats);\n        stats.put(\"thread_count\", thread.getThreadCount());\n        stats.put(\"virtual_thread_count\", VirtualThread.COUNT.max());\n        collectHeapUsage(stats);\n\n        for (GCStat gcStat : gcStats) {\n            double count = gcStat.count();\n            double elapsed = gcStat.elapsed();\n            stats.put(\"jvm_gc_\" + gcStat.name + \"_count\", count);\n            stats.put(\"jvm_gc_\" + gcStat.name + \"_elapsed\", elapsed);\n        }\n    }\n\n    // collect VmRSS / cgroup ram limit\n    // refer to https://man7.org/linux/man-pages/man5/proc.5.html, /proc/[pid]/statm section\n    // e.g. 913415 52225 7215 1 0 66363 0\n    // the second number is VmRSS in pages (4k)\n    public void collectMemoryUsage(Stats stats) {\n        if (!supportMemoryTracking) return;\n\n        var content = new String(Files.bytes(procPath), StandardCharsets.US_ASCII);\n        double vmRSS = parseVmRSS(content);\n        stats.put(\"vm_rss\", vmRSS);\n        double maxMemory = os.getTotalMemorySize();\n        stats.put(\"mem_max\", maxMemory);\n        boolean highUsage = stats.checkHighUsage(vmRSS / maxMemory, highMemUsageThreshold, \"mem\");\n        if (highUsage) {\n            stats.info(\"proc_status\", new String(Files.bytes(Path.of(\"/proc/self/status\")), StandardCharsets.US_ASCII));\n            stats.info(\"native_memory\", Diagnostic.nativeMemory());\n        }\n    }\n\n    long parseVmRSS(String content) {\n        int index1 = content.indexOf(' ');\n        int index2 = content.indexOf(' ', index1 + 1);\n        return Long.parseLong(content.substring(index1 + 1, index2)) * 4096;\n    }\n\n    public void collectMetrics(Stats stats) {\n        for (Metrics metrics : metrics) {\n            try {\n                metrics.collect(stats);\n            } catch (Throwable e) {\n                logger.warn(\"failed to collect metrics, metrics={}, error={}\", metrics.getClass().getCanonicalName(), e.getMessage(), e);\n            }\n        }\n    }\n\n    private void collectHeapUsage(Stats stats) {\n        MemoryUsage heapUsage = memory.getHeapMemoryUsage();\n        double usedHeap = heapUsage.getUsed();\n        double maxHeap = heapUsage.getMax();\n        stats.put(\"jvm_heap_used\", usedHeap);\n        stats.put(\"jvm_heap_max\", maxHeap);\n        stats.checkHighUsage(usedHeap / maxHeap, highHeapUsageThreshold, \"heap\");\n\n        MemoryUsage nonHeapUsage = memory.getNonHeapMemoryUsage();\n        stats.put(\"jvm_non_heap_used\", nonHeapUsage.getUsed());\n    }\n\n    private void collectCPUUsage(Stats stats) {\n        stats.put(\"sys_load_avg\", os.getSystemLoadAverage());   // until java 15, OperatingSystemMXBean returns host level load and cpu usage, not container level\n\n        // since java 17, JVM is aware of container\n        // use \"java -XshowSettings:system -version\" to show container info\n        // refer to com.sun.management.internal.OperatingSystemImpl.ContainerCpuTicks.getContainerCpuLoad\n        double usage = os.getProcessCpuLoad();\n        stats.put(\"cpu_usage\", usage);\n        boolean highUsage = stats.checkHighUsage(usage, highCPUUsageThreshold, \"cpu\");\n        if (highUsage) {\n            stats.info(\"thread_dump\", Diagnostic.thread());\n            stats.info(\"virtual_thread_dump\", Diagnostic.virtualThread());\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Stats.java."}, {"role": "assistant", "content": "The source code of java class Stats.java:\n```java\npackage core.framework.internal.stat;\n\nimport core.framework.log.Severity;\nimport core.framework.util.ASCII;\n\nimport java.text.NumberFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class Stats {\n    public final Map<String, Double> stats = new HashMap<>(); // no need to keep insertion order, kibana will sort all keys on display\n    public Severity severity;\n    public String errorCode;\n    public String errorMessage;\n    public Map<String, String> info;\n\n    public String result() {\n        if (errorCode == null) return \"OK\";\n        return severity == Severity.ERROR ? \"ERROR\" : \"WARN\";   // default to warning\n    }\n\n    public void put(String key, double value) {\n        stats.put(key, value);\n    }\n\n    public boolean checkHighUsage(double usage, double threshold, String name) {\n        if (usage <= threshold) return false;\n\n        if (errorCode == null) {    // do not overwrite existing warning, framework will check resource in order of importance\n            NumberFormat format = NumberFormat.getPercentInstance();\n            errorCode = \"HIGH_\" + ASCII.toUpperCase(name) + \"_USAGE\";\n            errorMessage = name + \" usage is too high, usage=\" + format.format(usage);\n        }\n\n        return true;\n    }\n\n    public void info(String key, String value) {\n        if (info == null) {\n            info = new HashMap<>();\n        }\n        info.put(key, value);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CDNManager.java."}, {"role": "assistant", "content": "The source code of java class CDNManager.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author neo\n */\npublic class CDNManager {\n    private final Logger logger = LoggerFactory.getLogger(CDNManager.class);\n    private String host;\n\n    public String url(String url) {\n        if (url.startsWith(\"http://\") || url.startsWith(\"https://\") || url.startsWith(\"//\") || url.startsWith(\"data:\")) return url;\n        if (!Strings.startsWith(url, '/')) throw new Error(\"url must start with '/', url=\" + url);\n\n        if (host == null) return url;\n        return \"//\" + host + url;\n    }\n\n    public void host(String host) {\n        logger.info(\"set cdn host, host={}\", host);\n        this.host = host;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Expression.java."}, {"role": "assistant", "content": "The source code of java class Expression.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport core.framework.internal.template.TemplateContext;\n\n/**\n * @author neo\n */\npublic interface Expression {\n    Object eval(TemplateContext context);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExpressionBuilder.java."}, {"role": "assistant", "content": "The source code of java class ExpressionBuilder.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class ExpressionBuilder {\n    private final String expressionSource;\n    private final TemplateMetaContext context;\n    private final String location;\n    private final Token token;\n\n    public ExpressionBuilder(String expressionSource, TemplateMetaContext context, String location) {\n        this.expressionSource = expressionSource;\n        this.context = context;\n        this.location = location;\n        token = new ExpressionParser().parse(expressionSource);\n    }\n\n    public ExpressionHolder build() {\n        Expression expression = buildExpression();\n        Type returnType = returnType(token, context.rootClass);\n        return new ExpressionHolder(expression, returnType, expressionSource, location);\n    }\n\n    private Expression buildExpression() {\n        try {\n            DynamicInstanceBuilder<Expression> builder = new DynamicInstanceBuilder<>(Expression.class, null);\n            builder.addMethod(buildEvalMethod());\n            return builder.build();\n        } catch (Throwable e) {\n            throw new Error(format(\"failed to compile expression, expression={}, location={}\", expressionSource, location), e);\n        }\n    }\n\n    private String buildEvalMethod() {\n        var builder = new CodeBuilder();\n        builder.append(\"public Object eval({} context) {\\n\", type(TemplateContext.class));\n        String rootClassLiteral = type(context.rootClass);\n        builder.indent(1).append(\"{} $root = ({})context.root;\\n\", rootClassLiteral, rootClassLiteral);\n        context.paramClasses.forEach((name, paramClass) -> {\n            String paramClassLiteral = type(paramClass);\n            builder.indent(1).append(\"{} {} = ({})context.context(\\\"{}\\\");\\n\", paramClassLiteral, name, paramClassLiteral, name);\n        });\n        String translatedExpression = new ExpressionTranslator(token, context).translate();\n        builder.indent(1).append(\"return {};\\n\", translatedExpression);\n\n        builder.append(\"}\");\n        return builder.build();\n    }\n\n    private Type returnType(Token token, Class<?> modelClass) {\n        switch (token) {\n            case MethodToken methodToken -> {\n                String methodName = methodToken.name;\n                Type returnType = methodReturnType(modelClass, methodName);\n                if (methodToken.next != null) {\n                    return returnType(methodToken.next, GenericTypes.rawClass(returnType));\n                }\n                return returnType;\n            }\n            case FieldToken fieldToken -> {\n                Type fieldType = fieldType(modelClass, fieldToken.name);\n                if (fieldToken.next != null) {\n                    return returnType(fieldToken.next, GenericTypes.rawClass(fieldType));\n                }\n                return fieldType;\n            }\n            case ValueToken valueToken -> {\n                return valueToken.type;\n            }\n            default -> throw new Error(\"unexpected token, token=\" + token);\n        }\n    }\n\n    private Type fieldType(Class<?> modelClass, String fieldName) {\n        Class<?> fieldClass = context.paramClasses.get(fieldName);\n        if (fieldClass != null) return fieldClass;\n        try {\n            return modelClass.getField(fieldName).getGenericType();\n        } catch (NoSuchFieldException e) {\n            throw new Error(format(\"can not find field, class={}, field={}, expression={}, location={}\",\n                modelClass, fieldName, expressionSource, location), e);\n        }\n    }\n\n    private Type methodReturnType(Class<?> modelClass, String methodName) {\n        Method[] methods = modelClass.getMethods();\n        for (Method method : methods) {\n            if (method.getName().equals(methodName)) return method.getGenericReturnType();\n        }\n        throw new Error(format(\"can not find method, class={}, method={}, expression={}, location={}\", modelClass.getCanonicalName(), methodName, expressionSource, location));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExpressionHolder.java."}, {"role": "assistant", "content": "The source code of java class ExpressionHolder.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport core.framework.internal.template.TemplateContext;\n\nimport java.lang.reflect.Type;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class ExpressionHolder {\n    public final Type returnType;\n    private final Expression expression;\n    private final String expressionSource;\n    private final String location;\n\n    public ExpressionHolder(Expression expression, Type returnType, String expressionSource, String location) {\n        this.expression = expression;\n        this.returnType = returnType;\n        this.expressionSource = expressionSource;\n        this.location = location;\n    }\n\n    public Object eval(TemplateContext context) {\n        try {\n            return expression.eval(context);\n        } catch (Throwable e) {\n            throw new Error(format(\"failed to eval expression, location={}, expression={}, error={}\", location, expressionSource, e.getMessage()), e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExpressionParser.java."}, {"role": "assistant", "content": "The source code of java class ExpressionParser.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport java.util.regex.Pattern;\n\n/**\n * @author neo\n */\nclass ExpressionParser {\n    private static final Pattern NUMBER_PATTERN = Pattern.compile(\"[\\\\d\\\\.]+\");\n    private static final Pattern METHOD_PATTERN = Pattern.compile(\"[a-z][a-zA-Z\\\\d]*\");\n    private static final Pattern FIELD_PATTERN = Pattern.compile(\"[a-z][a-zA-Z\\\\d]*\");\n\n    public Token parse(String expression) {\n        int length = expression.length();\n        char firstChar = expression.charAt(0);\n        if (firstChar == '\"' || firstChar == '\\'') {\n            if (length <= 1 || expression.charAt(length - 1) != firstChar)\n                throw new Error(\"\\\" or \\' is not closed, expression=\" + expression);\n            return new ValueToken(\"\\\"\" + expression.substring(1, length - 1) + \"\\\"\", String.class);\n        }\n\n        for (int i = 0; i < length; i++) {\n            char ch = expression.charAt(i);\n            if (ch == '(') {\n                return parseMethod(expression, i);\n            } else if (ch == '.') {\n                if (i == length - 1) {\n                    throw new Error(\"expression must not end with '.'\");\n                }\n                String field = expression.substring(0, i);\n                if (NUMBER_PATTERN.matcher(field).matches()) continue;\n\n                if (!FIELD_PATTERN.matcher(field).matches())\n                    throw new Error(\"invalid field name, field=\" + field);\n                var token = new FieldToken(field);\n                token.next = parse(expression.substring(i + 1));\n                if (token.next instanceof ValueToken)\n                    throw new Error(\"value token must not be followed by '.', expression=\" + expression);\n                return token;\n            }\n        }\n\n        if (NUMBER_PATTERN.matcher(expression).matches()) {\n            return new ValueToken(expression, Number.class);\n        } else {\n            if (!FIELD_PATTERN.matcher(expression).matches())\n                throw new Error(\"invalid field name, field=\" + expression);\n            return new FieldToken(expression);\n        }\n    }\n\n    private Token parseMethod(String expression, int leftParenthesesIndex) {\n        int length = expression.length();\n        String method = expression.substring(0, leftParenthesesIndex);\n        if (!METHOD_PATTERN.matcher(method).matches()) throw new Error(\"invalid method name, method=\" + method);\n\n        MethodToken token = new MethodToken(method);\n        int endIndex = findMethodEnd(expression, leftParenthesesIndex + 1);\n        parseMethodParams(token, expression.substring(leftParenthesesIndex + 1, endIndex));\n        if (endIndex + 1 < length) {\n            if (expression.charAt(endIndex + 1) != '.')\n                throw new Error(\"method can only be followed by '.', expression=\" + expression);\n            if (endIndex + 2 == length)\n                throw new Error(\"method can only be followed by field or method, expression=\" + expression);\n            token.next = parse(expression.substring(endIndex + 2));\n            if (token.next instanceof ValueToken)\n                throw new Error(\"value token must not be followed by '.', expression=\" + expression);\n        }\n        return token;\n    }\n\n    private void parseMethodParams(MethodToken token, String params) {\n        var builder = new StringBuilder();\n        int length = params.length();\n        for (int i = 0; i < length; i++) {\n            char ch = params.charAt(i);\n            if (ch == ',') {\n                String param = builder.toString().trim();\n                if (param.isEmpty())\n                    throw new Error(\"expect param before ',', method=\" + token.name);\n                token.params.add(parse(param));\n                builder = new StringBuilder();\n            } else {\n                builder.append(ch);\n            }\n        }\n        String param = builder.toString().trim();\n        if (param.length() > 0)\n            token.params.add(parse(param));\n    }\n\n    private int findMethodEnd(String expression, int index) {\n        int leftParentheses = 0;\n        int length = expression.length();\n        for (int i = index; i < length; i++) {\n            char ch = expression.charAt(i);\n            if (ch == ')') {\n                if (leftParentheses == 0) return i;\n                else leftParentheses--;\n            } else if (ch == '(') {\n                leftParentheses++;\n            }\n        }\n        throw new Error(\"parentheses is not closed properly\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ExpressionTranslator.java."}, {"role": "assistant", "content": "The source code of java class ExpressionTranslator.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport core.framework.internal.template.TemplateMetaContext;\n\n/**\n * @author neo\n */\nclass ExpressionTranslator {\n    private final Token expression;\n    private final TemplateMetaContext context;\n\n    ExpressionTranslator(Token expression, TemplateMetaContext context) {\n        this.expression = expression;\n        this.context = context;\n    }\n\n    public String translate() {\n        if (expression instanceof ValueToken token) return token.value;\n\n        var builder = new StringBuilder();\n        append(builder, expression, true);\n        return builder.toString();\n    }\n\n    private void append(StringBuilder builder, Token token, boolean root) {\n        if (token instanceof FieldToken fieldToken) {\n            if (root && !context.paramClasses.containsKey(fieldToken.name)) {\n                builder.append(\"$root.\");\n            }\n            builder.append(fieldToken.name);\n            if (fieldToken.next != null) {\n                builder.append('.');\n                append(builder, fieldToken.next, false);\n            }\n        } else if (token instanceof final MethodToken methodToken) {\n            appendMethod(builder, methodToken, root);\n        } else if (token instanceof final ValueToken valueToken) {\n            builder.append(valueToken.value);\n        }\n    }\n\n    private void appendMethod(StringBuilder builder, MethodToken method, boolean root) {\n        if (root && !context.paramClasses.containsKey(method.name)) {\n            builder.append(\"$root.\");\n        }\n        builder.append(method.name).append('(');\n\n        int index = 0;\n        for (Token param : method.params) {\n            if (index > 0) builder.append(',');\n            append(builder, param, true);\n            index++;\n        }\n        builder.append(')');\n        if (method.next != null) {\n            builder.append('.');\n            append(builder, method.next, false);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FieldToken.java."}, {"role": "assistant", "content": "The source code of java class FieldToken.java:\n```java\npackage core.framework.internal.template.expression;\n\n/**\n * @author neo\n */\nclass FieldToken implements Token {\n    final String name;\n    Token next;\n\n    FieldToken(String name) {\n        this.name = name;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MethodToken.java."}, {"role": "assistant", "content": "The source code of java class MethodToken.java:\n```java\npackage core.framework.internal.template.expression;\n\nimport core.framework.util.Lists;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\nclass MethodToken implements Token {\n    final String name;\n    final List<Token> params = Lists.newArrayList();\n    Token next;\n\n    MethodToken(String name) {\n        this.name = name;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Token.java."}, {"role": "assistant", "content": "The source code of java class Token.java:\n```java\npackage core.framework.internal.template.expression;\n\n/**\n * @author neo\n */\npublic interface Token {\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ValueToken.java."}, {"role": "assistant", "content": "The source code of java class ValueToken.java:\n```java\npackage core.framework.internal.template.expression;\n\n/**\n * @author neo\n */\nclass ValueToken implements Token {\n    final String value;\n    final Class<?> type;\n\n    ValueToken(String value, Class<?> type) {\n        this.value = value;\n        this.type = type;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BooleanAttributeFragment.java."}, {"role": "assistant", "content": "The source code of java class BooleanAttributeFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class BooleanAttributeFragment implements Fragment {\n    private final String name;\n    private final ExpressionHolder expression;\n\n    public BooleanAttributeFragment(String name, String expression, TemplateMetaContext context, String location) {\n        this.name = name;\n        this.expression = new ExpressionBuilder(expression, context, location).build();\n        if (!Boolean.class.equals(GenericTypes.rawClass(this.expression.returnType)))\n            throw new Error(format(\"boolean attribute expression must return Boolean, condition={}, returnType={}, location={}\", expression, this.expression.returnType.getTypeName(), location));\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        Object result = expression.eval(context);\n        if (Boolean.TRUE.equals(result)) {\n            builder.append(' ').append(name);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ContainerFragment.java."}, {"role": "assistant", "content": "The source code of java class ContainerFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * @author neo\n */\npublic abstract class ContainerFragment implements Fragment {\n    private final Deque<Fragment> children = new ArrayDeque<>();\n\n    public void addStaticContent(String content) {\n        if (!children.isEmpty()) {\n            Fragment lastFragment = children.getLast();\n            if (lastFragment instanceof StaticFragment staticFragment) {\n                staticFragment.append(content);\n                return;\n            }\n        }\n        StaticFragment fragment = new StaticFragment();\n        fragment.append(content);\n        children.add(fragment);\n    }\n\n    public void add(Fragment fragment) {\n        children.add(fragment);\n    }\n\n    protected void processChildren(StringBuilder builder, TemplateContext context) {\n        for (Fragment child : children) {\n            child.process(builder, context);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ForFragment.java."}, {"role": "assistant", "content": "The source code of java class ForFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class ForFragment extends ContainerFragment {\n    private static final Pattern STATEMENT_PATTERN = Pattern.compile(\"([a-zA-Z0-9]+):([#a-zA-Z0-9\\\\.\\\\(\\\\)]+)\");\n    public final String variable;\n    public final Class<?> valueClass;\n    private final ExpressionHolder expression;\n\n    public ForFragment(String statement, TemplateMetaContext context, String location) {\n        Matcher matcher = STATEMENT_PATTERN.matcher(statement);\n        if (!matcher.matches())\n            throw new Error(format(\"statement must match \\\"var:list\\\", statement={}, location={}\", statement, location));\n\n        variable = matcher.group(1);\n        String list = matcher.group(2);\n\n        ExpressionBuilder builder = new ExpressionBuilder(list, context, location);\n        this.expression = builder.build();\n        if (!GenericTypes.isGenericList(expression.returnType))\n            throw new Error(format(\"for statement must return List<T>, list={}, returnType={}, location={}\", list, expression.returnType.getTypeName(), location));\n\n        valueClass = GenericTypes.listValueClass(expression.returnType);\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        List<?> list = (List<?>) expression.eval(context);\n        for (Object item : list) {\n            context.contextObjects.put(variable, item);\n            processChildren(builder, context);\n        }\n        context.contextObjects.remove(variable);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Fragment.java."}, {"role": "assistant", "content": "The source code of java class Fragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\n\n/**\n * @author neo\n */\npublic interface Fragment {\n    void process(StringBuilder builder, TemplateContext context);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLContentFragment.java."}, {"role": "assistant", "content": "The source code of java class HTMLContentFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\n\n/**\n * @author neo\n */\npublic class HTMLContentFragment implements Fragment {\n    private final ExpressionHolder expression;\n\n    public HTMLContentFragment(String expression, TemplateMetaContext context, String location) {\n        this.expression = new ExpressionBuilder(expression, context, location).build();\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        Object result = expression.eval(context);\n        if (result != null) {\n            builder.append(result);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class IfFragment.java."}, {"role": "assistant", "content": "The source code of java class IfFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class IfFragment extends ContainerFragment {\n    private static final Pattern STATEMENT_PATTERN = Pattern.compile(\"((!)?)([#a-zA-Z0-9\\\\.\\\\(\\\\)]+)\");\n    private final ExpressionHolder expression;\n    private final boolean reverse;\n\n    public IfFragment(String statement, TemplateMetaContext context, String location) {\n        Matcher matcher = STATEMENT_PATTERN.matcher(statement);\n        if (!matcher.matches())\n            throw new Error(format(\"statement must match \\\"(!)condition\\\", statement={}, location={}\", statement, location));\n\n        reverse = \"!\".equals(matcher.group(2));\n        String condition = matcher.group(3);\n\n        expression = new ExpressionBuilder(condition, context, location).build();\n        if (!Boolean.class.equals(GenericTypes.rawClass(expression.returnType)))\n            throw new Error(format(\"if statement must return Boolean, condition={}, returnType={}, location={}\", condition, expression.returnType.getTypeName(), location));\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        Object result = expression.eval(context);\n        Boolean expected = reverse ? Boolean.FALSE : Boolean.TRUE;\n        if (expected.equals(result)) {\n            processChildren(builder, context);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StaticFragment.java."}, {"role": "assistant", "content": "The source code of java class StaticFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\n\n/**\n * @author neo\n */\npublic class StaticFragment implements Fragment {\n    private final StringBuilder content = new StringBuilder();\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        builder.append(content);\n    }\n\n    void append(String content) {\n        this.content.append(content);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TextContentFragment.java."}, {"role": "assistant", "content": "The source code of java class TextContentFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\n\n/**\n * @author neo\n */\npublic class TextContentFragment implements Fragment {\n    static String escapeHTML(String text) {\n        int length = text.length();\n        int index = findHTMLReservedChar(text);\n        if (index == length) return text;\n        var builder = new StringBuilder(length * 2);\n        for (int i = 0; i < index; i++) builder.append(text.charAt(i));\n        for (; index < length; index++) {\n            char ch = text.charAt(index);\n            switch (ch) {\n                case '<' -> builder.append(\"&lt;\");\n                case '>' -> builder.append(\"&gt;\");\n                case '\"' -> builder.append(\"&quot;\");\n                case '&' -> builder.append(\"&amp;\");\n                case '\\'' -> builder.append(\"&#39;\");\n                case '/' -> builder.append(\"&#47;\");\n                default -> builder.append(ch);\n            }\n        }\n        return builder.toString();\n    }\n\n    private static int findHTMLReservedChar(String text) {\n        int length = text.length();\n        int index = 0;\n        for (; index < length; index++) {\n            char ch = text.charAt(index);\n            switch (ch) {\n                case '<':\n                case '>':\n                case '\"':\n                case '&':\n                case '\\'':\n                case '/':\n                    return index;\n                default:\n                    break;\n            }\n        }\n        return index;\n    }\n\n    private final ExpressionHolder expression;\n\n    public TextContentFragment(String expression, TemplateMetaContext context, String location) {\n        this.expression = new ExpressionBuilder(expression, context, location).build();\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        Object result = expression.eval(context);\n        if (result != null) {\n            builder.append(escapeHTML(String.valueOf(result)));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class URLFragment.java."}, {"role": "assistant", "content": "The source code of java class URLFragment.java:\n```java\npackage core.framework.internal.template.fragment;\n\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.expression.ExpressionBuilder;\nimport core.framework.internal.template.expression.ExpressionHolder;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.BitSet;\n\nimport static core.framework.log.Markers.errorCode;\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class URLFragment implements Fragment {  // this is for dynamic href/src only, static href won't be processed during compilation\n    /*\n       refer to http://www.ietf.org/rfc/rfc3986.txt\n       pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       pct-encoded   = \"%\" HEXDIG HEXDIG\n       unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       gen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n       segment       = *pchar\n       query         = *( pchar / \"/\" / \"?\" )\n       fragment      = *( pchar / \"/\" / \"?\" )\n    */\n    private static final BitSet VALID_URI = new BitSet(128);\n\n    static {\n        // unreserved\n        for (int i = 'a'; i <= 'z'; i++) {\n            VALID_URI.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            VALID_URI.set(i);\n        }\n        for (int i = '0'; i <= '9'; i++) {\n            VALID_URI.set(i);\n        }\n        VALID_URI.set('-');\n        VALID_URI.set('.');\n        VALID_URI.set('_');\n        VALID_URI.set('~');\n        // sub-delims\n        VALID_URI.set('!');\n        VALID_URI.set('$');\n        VALID_URI.set('&');\n        VALID_URI.set('\\'');\n        VALID_URI.set('(');\n        VALID_URI.set(')');\n        VALID_URI.set('*');\n        VALID_URI.set('+');\n        VALID_URI.set(',');\n        VALID_URI.set(';');\n        VALID_URI.set('=');\n        // \":\" and \"@\"\n        VALID_URI.set(':');\n        VALID_URI.set('@');\n        // fragment and query\n        VALID_URI.set('/');\n        VALID_URI.set('?');\n        // gen-delims\n        VALID_URI.set(':');\n        VALID_URI.set('/');\n        VALID_URI.set('?');\n        VALID_URI.set('#');\n        VALID_URI.set('[');\n        VALID_URI.set(']');\n        VALID_URI.set('@');\n        // escape char\n        VALID_URI.set('%');\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(URLFragment.class);\n    private final ExpressionHolder expression;\n    private final String location;\n    private final boolean cdn;\n\n    public URLFragment(String expression, TemplateMetaContext context, boolean cdn, String location) {\n        this.expression = new ExpressionBuilder(expression, context, location).build();\n        this.cdn = cdn;\n        this.location = location;\n\n        if (!String.class.equals(this.expression.returnType))\n            throw new Error(format(\"url statement must return String, expression={}, returnType={}, location={}\", expression, this.expression.returnType.getTypeName(), location));\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        String url = (String) expression.eval(context);\n        builder.append(url(url, context));\n    }\n\n    boolean isValidURL(String url) {\n        if (Strings.isBlank(url)) return false;\n        if (url.contains(\"javascript:\")) return false;\n        int length = url.length();\n        for (int i = 0; i < length; i++) {\n            char ch = url.charAt(i);\n            if (!VALID_URI.get(ch)) return false;\n        }\n        return true;\n    }\n\n    String url(String url, TemplateContext context) {\n        if (!isValidURL(url)) {\n            logger.warn(errorCode(\"INVALID_URL\"), \"invalid url detected, url={}, location={}\", url, location);\n            return \"\\\"\\\"\";\n        }\n        return cdn ? context.cdnManager.url(url) : url;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLTemplate.java."}, {"role": "assistant", "content": "The source code of java class HTMLTemplate.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.internal.template.fragment.ContainerFragment;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class HTMLTemplate extends ContainerFragment {\n    private final Class<?> modelClass;\n\n    HTMLTemplate(Class<?> modelClass) {\n        this.modelClass = modelClass;\n    }\n\n    public String process(TemplateContext context) {\n        if (context.root == null)\n            throw new Error(\"root must not be null\");\n\n        if (!modelClass.isInstance(context.root))\n            throw new Error(format(\"model class does not match, expectedClass={}, actualClass={}\", modelClass.getCanonicalName(), context.root.getClass().getCanonicalName()));\n\n        StringBuilder builder = new StringBuilder(2048);\n        process(builder, context);\n        return builder.toString();\n    }\n\n    @Override\n    public void process(StringBuilder builder, TemplateContext context) {\n        processChildren(builder, context);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLTemplateBuilder.java."}, {"role": "assistant", "content": "The source code of java class HTMLTemplateBuilder.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.internal.template.node.Document;\nimport core.framework.internal.template.parser.HTMLParser;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic class HTMLTemplateBuilder {\n    private final TemplateSource source;\n    private final Class<?> modelClass;\n    private final Document document;\n\n    public CDNManager cdn;\n    public MessageProvider message;\n\n    public HTMLTemplateBuilder(TemplateSource source, Class<?> modelClass) {\n        new ModelClassValidator(modelClass).validate();\n        this.source = source;\n        this.modelClass = modelClass;\n        document = new HTMLParser(source).parse();\n    }\n\n    public HTMLTemplate build() {\n        TemplateMetaContext context = new TemplateMetaContext(modelClass);\n        context.cdn = cdn;\n        context.message = message;\n        HTMLTemplate template = new HTMLTemplate(context.rootClass);\n        document.buildTemplate(template, context, source);\n        return template;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageProvider.java."}, {"role": "assistant", "content": "The source code of java class MessageProvider.java:\n```java\npackage core.framework.internal.template;\n\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic interface MessageProvider {\n    Optional<String> get(String key);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ModelClassValidator.java."}, {"role": "assistant", "content": "The source code of java class ModelClassValidator.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.internal.reflect.Methods;\nimport core.framework.internal.validate.ClassValidator;\nimport core.framework.internal.validate.ClassVisitor;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZonedDateTime;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nfinal class ModelClassValidator implements ClassVisitor {\n    private final ClassValidator validator;\n\n    ModelClassValidator(Class<?> modelClass) {\n        validator = new ClassValidator(modelClass);\n        validator.allowedValueClasses = Set.of(String.class, Boolean.class,\n            Integer.class, Long.class, Double.class, BigDecimal.class,\n            LocalDate.class, LocalDateTime.class, ZonedDateTime.class);\n        validator.visitor = this;\n    }\n\n    void validate() {\n        validator.validate();\n    }\n\n    @Override\n    public void visitClass(Class<?> objectClass, String path) {\n        Method[] methods = objectClass.getDeclaredMethods();\n        for (Method method : methods) {\n            if (Modifier.isPublic(method.getModifiers()) && method.getReturnType().isPrimitive()) {\n                throw new Error(format(\"primitive class as return type is not supported, please use object type, returnType={}, method={}\", method.getReturnType(), Methods.path(method)));\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Attribute.java."}, {"role": "assistant", "content": "The source code of java class Attribute.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.BooleanAttributeFragment;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.fragment.HTMLContentFragment;\nimport core.framework.internal.template.fragment.TextContentFragment;\nimport core.framework.internal.template.fragment.URLFragment;\nimport core.framework.internal.template.parser.HTMLParser;\nimport core.framework.internal.template.source.TemplateSource;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class Attribute {\n    public final String name;\n    public final String tagName;\n    public final String location;\n\n    public String value;\n    public boolean hasDoubleQuote;\n\n    public Attribute(String name, String tagName, String location) {\n        this.name = name;\n        this.tagName = tagName;\n        this.location = location;\n    }\n\n    boolean isDynamic() {\n        return name.startsWith(\"c:\");\n    }\n\n    boolean isMessage() {\n        return name.startsWith(\"m:\");\n    }\n\n    void addStaticContent(ContainerFragment parent) {\n        parent.addStaticContent(\" \");\n        parent.addStaticContent(name);\n        if (value != null) {\n            parent.addStaticContent(\"=\");\n            if (hasDoubleQuote) parent.addStaticContent(\"\\\"\");\n            parent.addStaticContent(value);\n            if (hasDoubleQuote) parent.addStaticContent(\"\\\"\");\n        }\n    }\n\n    boolean isDynamicBooleanAttribute() {\n        return \"c:checked\".equals(name)\n                || \"c:selected\".equals(name)\n                || \"c:disabled\".equals(name)\n                || \"c:readonly\".equals(name)\n                || \"c:multiple\".equals(name)\n                || \"c:ismap\".equals(name)\n                || \"c:defer\".equals(name);\n    }\n\n    void addBooleanAttribute(ContainerFragment parent, TemplateMetaContext context) {\n        parent.add(new BooleanAttributeFragment(name.substring(2), value, context, location));\n    }\n\n    boolean isCDNAttribute() {\n        if (\"link\".equals(tagName) && (\"c:href\".equals(name) || \"href\".equals(name))) return true;\n        if (\"script\".equals(tagName) && (\"c:src\".equals(name) || \"src\".equals(name))) return true;\n        if (\"img\".equals(tagName) && (\"c:src\".equals(name) || \"src\".equals(name))) return true;\n        return false;\n    }\n\n    void addCDNAttribute(ContainerFragment parent, TemplateMetaContext context) {\n        String attributeName = isDynamic() ? name.substring(2) : name;\n        if (isDynamic()) {\n            parent.addStaticContent(\" \");\n            parent.addStaticContent(attributeName);\n            parent.addStaticContent(\"=\");\n            parent.add(new URLFragment(value, context, true, location));\n        } else {\n            if (context.cdn != null) {  // expand cdn during compiling\n                parent.addStaticContent(\" \");\n                parent.addStaticContent(attributeName);\n                parent.addStaticContent(\"=\");\n                parent.addStaticContent(context.cdn.url(value));\n            } else {\n                addStaticContent(parent);\n            }\n        }\n    }\n\n    void addValueAttribute(ContainerFragment parent, TemplateMetaContext context) {\n        parent.addStaticContent(\" \");\n        parent.addStaticContent(name.substring(name.lastIndexOf(':') + 1));\n        if (\"c:href\".equals(name)) {\n            parent.addStaticContent(\"=\");\n            parent.add(new URLFragment(value, context, false, location));\n        } else if (name.startsWith(\"c:html:\")) {\n            parent.addStaticContent(\"=\\\"\");\n            parent.add(new HTMLContentFragment(value, context, location));\n            parent.addStaticContent(\"\\\"\");\n        } else {\n            parent.addStaticContent(\"=\\\"\");\n            parent.add(new TextContentFragment(value, context, location));\n            parent.addStaticContent(\"\\\"\");\n        }\n    }\n\n    void addMessageAttribute(ContainerFragment parent, TemplateMetaContext context) {\n        String message = context.message.get(value).orElseThrow(() -> new Error(format(\"can not find message, key={}, location={}\", value, location)));\n        parent.addStaticContent(\" \");\n        parent.addStaticContent(name.substring(2));\n        parent.addStaticContent(\"=\\\"\");\n        parent.addStaticContent(message);\n        parent.addStaticContent(\"\\\"\");\n    }\n\n    void addDynamicContent(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        switch (name) {\n            case \"c:text\" -> parent.add(new TextContentFragment(value, context, location));\n            case \"c:html\" -> parent.add(new HTMLContentFragment(value, context, location));\n            case \"m:text\" -> {\n                String message = context.message.get(value).orElseThrow(() -> new Error(format(\"can not find message, key={}, location={}\", value, location)));\n                parent.addStaticContent(message);\n            }\n            case \"c:include\" -> {\n                TemplateSource includedSource = source.resolve(value);\n                Document document = new HTMLParser(includedSource).parse();\n                document.buildTemplate(parent, context, includedSource);\n            }\n            default -> throw new Error(\"not supported dynamic content attribute, name=\" + name);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Attributes.java."}, {"role": "assistant", "content": "The source code of java class Attributes.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.util.Maps;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class Attributes {\n    public final Map<String, Attribute> attributes = Maps.newLinkedHashMap();\n\n    public void add(Attribute attribute) {\n        attributes.put(attribute.name, attribute);\n    }\n\n    void buildTemplate(ContainerFragment parent, TemplateMetaContext context) {\n        validate();\n\n        for (Attribute attribute : attributes.values()) {\n            if (skip(attribute)) continue;\n\n            if (attribute.isCDNAttribute()) {\n                attribute.addCDNAttribute(parent, context);\n            } else if (attribute.isDynamic()) {\n                if (attribute.isDynamicBooleanAttribute()) attribute.addBooleanAttribute(parent, context);\n                else attribute.addValueAttribute(parent, context);\n            } else if (attribute.isMessage()) {\n                attribute.addMessageAttribute(parent, context);\n            } else {\n                attribute.addStaticContent(parent);\n            }\n        }\n    }\n\n    private boolean skip(Attribute attribute) {\n        String name = attribute.name;\n\n        if (\"xmlns:c\".equals(name) || \"xmlns:m\".equals(name)\n            || \"c:text\".equals(name)\n            || \"c:html\".equals(name)\n            || \"m:text\".equals(name)\n            || \"c:include\".equals(name)\n            || \"c:for\".equals(name)\n            || \"c:if\".equals(name))\n            return true;\n\n        return !attribute.isDynamic() && (attributes.containsKey(\"c:\" + name) || attributes.containsKey(\"m:\" + name));   // there is dynamic attribute to overwrite\n    }\n\n    boolean containDynamicContent() {\n        return attributes.containsKey(\"c:text\")\n            || attributes.containsKey(\"m:text\")\n            || attributes.containsKey(\"c:html\")\n            || attributes.containsKey(\"c:include\");\n    }\n\n    Attribute dynamicContentAttribute() {\n        Attribute attribute = attributes.get(\"c:text\");\n        if (attribute != null) return attribute;\n        attribute = attributes.get(\"m:text\");\n        if (attribute != null) return attribute;\n        attribute = attributes.get(\"c:html\");\n        if (attribute != null) return attribute;\n        return attributes.get(\"c:include\");\n    }\n\n    List<Attribute> flowAttributes() {\n        List<Attribute> attributes = new ArrayList<>();\n        this.attributes.forEach((name, attr) -> {\n            if (\"c:if\".equals(name) || \"c:for\".equals(name)) attributes.add(attr);\n        });\n        return attributes;\n    }\n\n    private void validate() {\n        int count = 0;\n\n        Attribute attribute = attributes.get(\"c:text\");\n        if (attribute != null) count++;\n        attribute = attributes.get(\"m:text\");\n        if (attribute != null) count++;\n        attribute = attributes.get(\"c:html\");\n        if (attribute != null) count++;\n        attribute = attributes.get(\"c:include\");\n        if (attribute != null) count++;\n\n        if (count > 1 && attribute != null)\n            throw new Error(format(\"element must not have more than one dynamic content attribute, attribute={}, location={}\", attribute.name, attribute.location));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Comment.java."}, {"role": "assistant", "content": "The source code of java class Comment.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic class Comment implements Node {\n    private final String content;\n\n    public Comment(String content) {\n        this.content = content;\n    }\n\n    @Override\n    public void buildTemplate(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        parent.addStaticContent(\"<!--\");\n        parent.addStaticContent(content);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ContainerNode.java."}, {"role": "assistant", "content": "The source code of java class ContainerNode.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.util.Lists;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic abstract class ContainerNode implements Node {\n    public final List<Node> nodes = Lists.newArrayList();\n\n    public void add(Node node) {\n        this.nodes.add(node);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Document.java."}, {"role": "assistant", "content": "The source code of java class Document.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic class Document extends ContainerNode {\n    @Override\n    public void buildTemplate(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        for (Node node : nodes) {\n            node.buildTemplate(parent, context, source);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Element.java."}, {"role": "assistant", "content": "The source code of java class Element.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.fragment.ForFragment;\nimport core.framework.internal.template.fragment.IfFragment;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic class Element extends ContainerNode {\n    public final Attributes attributes = new Attributes();\n    public final String name;\n    public boolean hasEndTag;\n\n    public Element(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void buildTemplate(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        ContainerFragment currentParent = parent;\n        ForFragment forFragment = null;\n        for (Attribute attribute : attributes.flowAttributes()) {\n            if (\"c:if\".equals(attribute.name)) {\n                IfFragment ifFragment = new IfFragment(attribute.value, context, attribute.location);\n                currentParent.add(ifFragment);\n                currentParent = ifFragment;\n            } else if (\"c:for\".equals(attribute.name)) {\n                forFragment = new ForFragment(attribute.value, context, attribute.location);\n                context.paramClasses.put(forFragment.variable, forFragment.valueClass);\n                currentParent.add(forFragment);\n                currentParent = forFragment;\n            }\n        }\n\n        currentParent.addStaticContent(\"<\");\n\n        if (\"template\".equals(name)) {\n            currentParent.addStaticContent(\"script type=\\\"text/template\\\"\");\n        } else {\n            currentParent.addStaticContent(name);\n        }\n\n        attributes.buildTemplate(currentParent, context);\n\n        if (attributes.containDynamicContent()) {\n            currentParent.addStaticContent(\">\");\n\n            Attribute attribute = attributes.dynamicContentAttribute();\n            attribute.addDynamicContent(currentParent, context, source);\n\n            addEndTag(currentParent);\n        } else {\n            buildStaticContent(currentParent, context, source);\n        }\n\n        if (forFragment != null) {\n            context.paramClasses.remove(forFragment.variable);\n        }\n    }\n\n    private void buildStaticContent(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        parent.addStaticContent(\">\");\n\n        for (Node node : nodes) {\n            node.buildTemplate(parent, context, source);\n        }\n\n        if (hasEndTag) addEndTag(parent);\n    }\n\n    private void addEndTag(ContainerFragment parent) {\n        parent.addStaticContent(\"</\");\n        if (\"template\".equals(name)) {\n            parent.addStaticContent(\"script\");\n        } else {\n            parent.addStaticContent(name);\n        }\n        parent.addStaticContent(\">\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Node.java."}, {"role": "assistant", "content": "The source code of java class Node.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic interface Node {\n    void buildTemplate(ContainerFragment parent, TemplateMetaContext context, TemplateSource source);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Text.java."}, {"role": "assistant", "content": "The source code of java class Text.java:\n```java\npackage core.framework.internal.template.node;\n\nimport core.framework.internal.template.TemplateMetaContext;\nimport core.framework.internal.template.fragment.ContainerFragment;\nimport core.framework.internal.template.source.TemplateSource;\n\n/**\n * @author neo\n */\npublic class Text implements Node {\n    public final String content;\n\n    public Text(String content) {\n        this.content = content;\n    }\n\n    @Override\n    public void buildTemplate(ContainerFragment parent, TemplateMetaContext context, TemplateSource source) {\n        parent.addStaticContent(content);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLLexer.java."}, {"role": "assistant", "content": "The source code of java class HTMLLexer.java:\n```java\npackage core.framework.internal.template.parser;\n\n/**\n * @author neo\n */\nclass HTMLLexer {\n    private final String name;\n    private final String html;\n\n    private int startIndex;\n    private int currentIndex;\n\n    private int currentLine = 1;\n    private int currentColumn = 1;\n\n    HTMLLexer(String name, String html) {\n        this.name = name;\n        this.html = html;\n    }\n\n    HTMLTokenType nextNodeToken() {\n        reset();\n\n        if (currentIndex >= html.length()) {\n            return HTMLTokenType.EOF;\n        } else if (match(currentIndex, \"<!--\")) {\n            move(4);\n            return HTMLTokenType.START_COMMENT;\n        } else if (match(currentIndex, \"</\")) {\n            move(findEndTagLength());\n            return HTMLTokenType.END_TAG;\n        } else if (isStartTag(currentIndex)) {\n            move(findStartTagLength());\n            return HTMLTokenType.START_TAG;\n        } else {\n            move(findTextLength());\n            return HTMLTokenType.TEXT;\n        }\n    }\n\n    HTMLTokenType nextElementToken() {\n        skipWhitespaces();\n\n        if (currentIndex >= html.length()) {\n            return HTMLTokenType.EOF;\n        } else if (match(currentIndex, \">\")) {\n            move(1);\n            return HTMLTokenType.START_TAG_END;\n        } else if (match(currentIndex, \"/>\")) {\n            move(2);\n            return HTMLTokenType.START_TAG_END_CLOSE;\n        } else if (match(currentIndex, \"=\")) {\n            move(1);\n            skipWhitespaces();\n            int length = findAttributeValueLength();\n            if (length > 0) move(length);\n            return HTMLTokenType.ATTRIBUTE_VALUE;\n        } else {\n            move(findAttributeNameLength());\n            return HTMLTokenType.ATTRIBUTE_NAME;\n        }\n    }\n\n    HTMLTokenType nextEndCommentToken() {\n        reset();\n\n        int length = -1;\n        for (int i = currentIndex; i < html.length() - 3; i++) {\n            if (match(i, \"-->\")) {\n                length = i - currentIndex;\n                break;\n            }\n        }\n        if (length == -1) throw new Error(\"comment is not closed, location=\" + currentLocation());\n        move(length);\n\n        return HTMLTokenType.END_COMMENT;\n    }\n\n    HTMLTokenType nextScriptToken(String tagName) {\n        reset();\n        String closeTag = \"</\" + tagName + \">\";\n        int length = -1;\n        int maxIndex = html.length() - closeTag.length() + 1;\n        for (int i = currentIndex; i < maxIndex; i++) {\n            if (match(i, closeTag)) {\n                length = i - currentIndex;\n                break;\n            }\n        }\n        if (length == -1) throw new Error(\"script/css is not closed, location=\" + currentLocation());\n\n        if (length > 0) {\n            move(length);\n            return HTMLTokenType.TEXT;\n        } else {\n            return HTMLTokenType.END_TAG;   // empty tag\n        }\n    }\n\n    String currentToken() {\n        return html.substring(startIndex, currentIndex);\n    }\n\n    String currentLocation() {\n        return name + \":\" + currentLine + \":\" + currentColumn;\n    }\n\n    private void skipWhitespaces() {\n        int length = 0;\n        for (int i = currentIndex; i < html.length(); i++) {\n            if (!Character.isWhitespace(html.charAt(i))) {\n                break;\n            }\n            length++;\n        }\n        if (length > 0) move(length);\n        reset();\n    }\n\n    private boolean isStartTag(int index) {\n        if (index + 1 >= html.length()) return false;\n        return html.charAt(index) == '<' && Character.isLetter(html.charAt(index + 1));\n    }\n\n    private int findStartTagLength() {\n        for (int i = currentIndex + 1; i < html.length(); i++) {\n            char ch = html.charAt(i);\n            if (ch == '>' || ch == '/' || Character.isWhitespace(ch)) {\n                return i - currentIndex;\n            }\n        }\n        throw new Error(\"start tag is invalid, location=\" + currentLocation());\n    }\n\n    private int findEndTagLength() {\n        for (int i = currentIndex + 2; i < html.length(); i++) {\n            char ch = html.charAt(i);\n            if (Character.isWhitespace(ch)) break;\n            if (ch == '>') {\n                return i - currentIndex + 1;\n            }\n        }\n        throw new Error(\"end tag is invalid, location=\" + currentLocation());\n    }\n\n    private int findTextLength() {\n        int length = 0;\n        for (int i = currentIndex; i < html.length(); i++) {\n            if (isStartTag(i) || match(i, \"<!--\") || match(i, \"</\")) break;\n            length++;\n        }\n        return length;\n    }\n\n    private int findAttributeNameLength() {\n        for (int i = currentIndex; i < html.length(); i++) {\n            char ch = html.charAt(i);\n            if (ch == '=' || ch == '/' || ch == '>' || Character.isWhitespace(ch)) {\n                return i - currentIndex;\n            }\n            if (ch == '<') {\n                throw new Error(\"attribute name is invalid, location=\" + currentLocation());\n            }\n        }\n        throw new Error(\"attribute name is invalid, location=\" + currentLocation());\n    }\n\n    private int findAttributeValueLength() {\n        char currentChar = html.charAt(currentIndex);\n        if (currentChar == '\\'')\n            throw new Error(\"it is recommended to use double quote to delimit attribute value, location=\" + currentLocation());\n\n        boolean hasDoubleQuote = currentChar == '\"';\n        int i = hasDoubleQuote ? currentIndex + 1 : currentIndex;\n        for (; i < html.length(); i++) {\n            char ch = html.charAt(i);\n            if (!hasDoubleQuote && (ch == '>' || Character.isWhitespace(ch) || match(i, \"/>\"))) {\n                return i - currentIndex;\n            } else if (ch == '\"') {\n                return i - currentIndex + 1;\n            }\n        }\n        throw new Error(\"attribute value is invalid, location=\" + currentLocation());\n    }\n\n    private boolean match(int index, String token) {\n        if (index + token.length() > html.length()) return false;\n        for (int i = 0; i < token.length(); i++) {\n            if (html.charAt(index + i) != token.charAt(i)) return false;\n        }\n        return true;\n    }\n\n    private void reset() {\n        startIndex = currentIndex;\n    }\n\n    private void move(int length) {\n        if (length == 0) throw new Error(\"syntax is invalid, location=\" + currentLocation());\n        for (int i = 0; i < length; i++) {\n            char ch = html.charAt(currentIndex);\n            if (ch == '\\n') {\n                currentLine++;\n                currentColumn = 1;\n            } else {\n                currentColumn++;\n            }\n            currentIndex++;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLParser.java."}, {"role": "assistant", "content": "The source code of java class HTMLParser.java:\n```java\npackage core.framework.internal.template.parser;\n\nimport core.framework.internal.template.node.Attribute;\nimport core.framework.internal.template.node.Comment;\nimport core.framework.internal.template.node.ContainerNode;\nimport core.framework.internal.template.node.Document;\nimport core.framework.internal.template.node.Element;\nimport core.framework.internal.template.node.Text;\nimport core.framework.internal.template.source.TemplateSource;\nimport core.framework.util.Strings;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class HTMLParser {\n    private final Pattern tagNamePattern = Pattern.compile(\"[a-z]+[a-z0-9\\\\-]*\");\n\n    private final Set<String> voidElements = Set.of(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\");\n\n    // loose checking to cover common cases, precise checking will be like e.g. checked attribute on input tag can be boolean attribute\n    private final Set<String> booleanAttributes = Set.of(\"checked\", \"selected\", \"disabled\", \"readonly\", \"multiple\", \"ismap\", \"defer\", \"required\", \"sortable\", \"autofocus\", \"allowfullscreen\", \"async\", \"hidden\");\n\n    private final HTMLLexer lexer;\n    private final Deque<ContainerNode> nodes = new ArrayDeque<>();\n\n    public HTMLParser(TemplateSource source) {\n        this.lexer = new HTMLLexer(source.name(), source.content());\n    }\n\n    // only support subnet of HTML, which means enforce strict and consistence rules\n    public Document parse() {\n        Document document = new Document();\n        nodes.push(document);\n        end:\n        while (true) {\n            HTMLTokenType type = lexer.nextNodeToken();\n            switch (type) {\n                case EOF:\n                    break end;\n                case TEXT:\n                    nodes.peek().add(new Text(lexer.currentToken()));\n                    break;\n                case START_COMMENT:\n                    lexer.nextEndCommentToken();\n                    nodes.peek().add(new Comment(lexer.currentToken()));\n                    break;\n                case START_TAG:\n                    String tagName = validateTagName(lexer.currentToken().substring(1));\n                    parseElement(tagName);\n                    break;\n                case END_TAG:\n                    String endTag = lexer.currentToken();\n                    String endTagName = validateTagName(endTag.substring(2, endTag.length() - 1));\n                    if (voidElements.contains(endTagName))\n                        throw new Error(format(\"void element must not have close tag, tag={}, location={}\", endTagName, lexer.currentLocation()));\n                    closeTag(endTagName);\n                    break;\n                default:\n                    throw new Error(format(\"unexpected type, type={}, location={}\", type, lexer.currentLocation()));\n            }\n        }\n        return document;\n    }\n\n    private void parseElement(String tagName) {\n        Element currentElement = new Element(tagName);\n        nodes.peek().add(currentElement);\n\n        Attribute currentAttribute = null;\n        while (true) {\n            HTMLTokenType type = lexer.nextElementToken();\n            switch (type) {\n                case EOF -> {\n                    if (currentAttribute != null) validateAttribute(currentAttribute);\n                    return;\n                }\n                case START_TAG_END_CLOSE -> {\n                    validateSelfCloseTag(tagName);\n                    return;\n                }\n                case START_TAG_END -> {\n                    if (currentAttribute != null) validateAttribute(currentAttribute);\n                    if (!voidElements.contains(tagName)) nodes.push(currentElement);\n                    if (\"script\".equals(currentElement.name) || \"style\".equals(currentElement.name)) {\n                        HTMLTokenType contentType = lexer.nextScriptToken(currentElement.name);\n                        if (contentType == HTMLTokenType.TEXT) nodes.peek().add(new Text(lexer.currentToken()));\n                    }\n                    return;\n                }\n                case ATTRIBUTE_NAME -> {\n                    if (currentAttribute != null) validateAttribute(currentAttribute);\n                    currentAttribute = new Attribute(lexer.currentToken(), tagName, lexer.currentLocation());\n                    currentElement.attributes.add(currentAttribute);\n                }\n                case ATTRIBUTE_VALUE -> {\n                    if (currentAttribute == null)\n                        throw new Error(\"attribute syntax is invalid, location=\" + lexer.currentLocation());\n                    String attributeValue = lexer.currentToken();\n                    if (attributeValue.startsWith(\"\\\"\")) {\n                        currentAttribute.value = attributeValue.substring(1, attributeValue.length() - 1);\n                        currentAttribute.hasDoubleQuote = true;\n                    } else if (!\"\".equals(attributeValue)) {    // not assign null attribute value, e.g. <p class=/>\n                        currentAttribute.value = attributeValue;\n                    }\n                }\n                default -> throw new Error(format(\"unexpected type, type={}, location={}\", type, lexer.currentLocation()));\n            }\n        }\n    }\n\n    private void closeTag(String tagName) {\n        while (true) {\n            ContainerNode lastNode = nodes.pop();\n            if (lastNode instanceof Document)\n                throw new Error(format(\"can not find matched tag to close, tagName={}, location={}\", tagName, lexer.currentLocation()));\n            Element element = (Element) lastNode;\n            if (element.name.equals(tagName)) {\n                element.hasEndTag = true;\n                return;\n            }\n        }\n    }\n\n    private String validateTagName(String name) {\n        if (!tagNamePattern.matcher(name).matches())\n            throw new Error(format(\"tag name must match {}, name={}, location={}\", tagNamePattern.pattern(), name, lexer.currentLocation()));\n        return name;\n    }\n\n    private void validateSelfCloseTag(String tagName) {\n        if (voidElements.contains(tagName))\n            throw new Error(format(\"it is recommended not to close void element, tag={}, location={}\", tagName, lexer.currentLocation()));\n        else\n            throw new Error(format(\"non void element must not be self-closed, tag={}, location={}\", tagName, lexer.currentLocation()));\n    }\n\n    private void validateAttribute(Attribute attribute) {\n        boolean isBooleanAttribute = booleanAttributes.contains(attribute.name);\n        if (!isBooleanAttribute && attribute.value == null)\n            throw new Error(format(\"non boolean attribute must have value, attribute={}>{}, location={}\", attribute.tagName, attribute.name, attribute.location));\n        if (isBooleanAttribute && attribute.value != null)\n            throw new Error(format(\"it is recommended not to put value for boolean attribute, attribute={}>{}, location={}\", attribute.tagName, attribute.name, attribute.location));\n\n        if (\"link\".equals(attribute.tagName) && \"href\".equals(attribute.name)\n            || \"script\".equals(attribute.tagName) && \"src\".equals(attribute.name)\n            || \"img\".equals(attribute.tagName) && \"src\".equals(attribute.name)) {\n            validateStaticURI(attribute);\n        }\n    }\n\n    private void validateStaticURI(Attribute attribute) {\n        String value = attribute.value;\n        if (!value.startsWith(\"http://\")\n            && !value.startsWith(\"https://\")\n            && !value.startsWith(\"//\")\n            && !Strings.startsWith(value, '/')\n            && !value.startsWith(\"data:\"))\n            throw new Error(format(\"static uri value must be either absolute or start with '/', attribute={}>{}, value={}, location={}\", attribute.tagName, attribute.name, value, attribute.location));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTMLTokenType.java."}, {"role": "assistant", "content": "The source code of java class HTMLTokenType.java:\n```java\npackage core.framework.internal.template.parser;\n\n/**\n * @author neo\n */\npublic enum HTMLTokenType {\n    START_TAG,              // <tag\n    START_TAG_END,          // >\n    START_TAG_END_CLOSE,    // />\n    END_TAG,        // </tag>\n    TEXT,\n    ATTRIBUTE_NAME,      // attr\n    ATTRIBUTE_VALUE,     // =value or =\"value\"\n    START_COMMENT,  // <!--\n    END_COMMENT,    // comment-->\n    EOF\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ClasspathTemplateSource.java."}, {"role": "assistant", "content": "The source code of java class ClasspathTemplateSource.java:\n```java\npackage core.framework.internal.template.source;\n\nimport core.framework.util.ClasspathResources;\n\n/**\n * @author neo\n */\npublic final class ClasspathTemplateSource implements TemplateSource {\n    private final String classpath;\n\n    public ClasspathTemplateSource(String classpath) {\n        this.classpath = classpath;\n    }\n\n    @Override\n    public String name() {\n        return classpath;\n    }\n\n    @Override\n    public String content() {\n        return ClasspathResources.text(classpath);\n    }\n\n    @Override\n    public TemplateSource resolve(String path) {\n        return new ClasspathTemplateSource(path);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FileTemplateSource.java."}, {"role": "assistant", "content": "The source code of java class FileTemplateSource.java:\n```java\npackage core.framework.internal.template.source;\n\nimport core.framework.util.Files;\nimport core.framework.util.Strings;\n\nimport java.nio.file.Path;\n\n/**\n * @author neo\n */\npublic final class FileTemplateSource implements TemplateSource {\n    private final Path root;\n    private final Path path;\n\n    public FileTemplateSource(Path root, String path) {\n        this.root = root;\n        if (!Strings.startsWith(path, '/')) throw new Error(\"path must start with '/', path=\" + path);\n        this.path = root.resolve(path.substring(1));\n    }\n\n    @Override\n    public String name() {\n        return String.valueOf(path);\n    }\n\n    @Override\n    public String content() {\n        return Files.text(path);\n    }\n\n    @Override\n    public TemplateSource resolve(String path) {\n        return new FileTemplateSource(root, path);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StringTemplateSource.java."}, {"role": "assistant", "content": "The source code of java class StringTemplateSource.java:\n```java\npackage core.framework.internal.template.source;\n\n/**\n * @author neo\n */\npublic final class StringTemplateSource implements TemplateSource {\n    private final String name;\n    private final String template;\n\n    public StringTemplateSource(String name, String template) {\n        this.name = name;\n        this.template = template;\n    }\n\n    @Override\n    public String name() {\n        return name;\n    }\n\n    @Override\n    public String content() {\n        return template;\n    }\n\n    @Override\n    public TemplateSource resolve(String path) {\n        throw new Error(\"string template does not support include\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TemplateSource.java."}, {"role": "assistant", "content": "The source code of java class TemplateSource.java:\n```java\npackage core.framework.internal.template.source;\n\n/**\n * @author neo\n */\npublic interface TemplateSource {\n    String name();\n\n    String content();\n\n    TemplateSource resolve(String path);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TemplateContext.java."}, {"role": "assistant", "content": "The source code of java class TemplateContext.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class TemplateContext {\n    public final Object root;\n    public final Map<String, Object> contextObjects = Maps.newHashMap();\n    public final CDNManager cdnManager;\n\n    public TemplateContext(Object root, CDNManager cdnManager) {\n        this.root = root;\n        this.cdnManager = cdnManager;\n    }\n\n    // used by generated code\n    public Object context(String name) {\n        return contextObjects.get(name);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TemplateMetaContext.java."}, {"role": "assistant", "content": "The source code of java class TemplateMetaContext.java:\n```java\npackage core.framework.internal.template;\n\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class TemplateMetaContext {\n    public final Class<?> rootClass;\n    public final Map<String, Class<?>> paramClasses = Maps.newHashMap();\n    public CDNManager cdn;\n    public MessageProvider message;\n\n    public TemplateMetaContext(Class<?> rootClass) {\n        this.rootClass = rootClass;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LRUMap.java."}, {"role": "assistant", "content": "The source code of java class LRUMap.java:\n```java\npackage core.framework.internal.util;\n\nimport java.io.Serial;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class LRUMap<K, V> extends LinkedHashMap<K, V> { // not thread safe\n    @Serial\n    private static final long serialVersionUID = -191933814768129858L;\n\n    private final int maxSize;\n\n    public LRUMap(int maxSize) {\n        super(maxSize, 0.75F, true);\n        this.maxSize = maxSize;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > maxSize;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanValidator.java."}, {"role": "assistant", "content": "The source code of java class BeanValidator.java:\n```java\npackage core.framework.internal.validate;\n\n/**\n * @author neo\n */\npublic interface BeanValidator {\n    void validate(Object instance, ValidationErrors errors, boolean partial);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanValidatorBuilder.java."}, {"role": "assistant", "content": "The source code of java class BeanValidatorBuilder.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.api.validate.Digits;\nimport core.framework.api.validate.Max;\nimport core.framework.api.validate.Min;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\nimport core.framework.api.validate.Pattern;\nimport core.framework.api.validate.Size;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.internal.reflect.GenericTypes;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.regex.PatternSyntaxException;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.internal.asm.Literal.variable;\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class BeanValidatorBuilder {\n    private final Class<?> beanClass;\n    DynamicInstanceBuilder<BeanValidator> builder;\n    private int index = 0;\n\n    public BeanValidatorBuilder(Class<?> beanClass) {\n        this.beanClass = beanClass;\n    }\n\n    @Nullable\n    public BeanValidator build() {\n        validate(beanClass, null);\n        if (Classes.instanceFields(beanClass).stream().noneMatch(this::hasValidationAnnotation)) return null;\n\n        builder = new DynamicInstanceBuilder<>(BeanValidator.class, beanClass.getSimpleName());\n        String method = validateMethod(beanClass, null);\n        var code = new CodeBuilder().append(\"public void validate(Object instance, {} errors, boolean partial) {\\n\", type(ValidationErrors.class));\n        code.indent(1).append(\"{}(({}) instance, errors, partial);\\n\", method, type(beanClass));\n        code.append('}');\n        builder.addMethod(code.build());\n        return builder.build();\n    }\n\n    private String validateMethod(Class<?> beanClass, String parentPath) {\n        String methodName = \"validate\" + beanClass.getSimpleName() + (index++);\n        var builder = new CodeBuilder().append(\"private void {}({} bean, {} errors, boolean partial) {\\n\", methodName, type(beanClass), type(ValidationErrors.class));\n        for (Field field : Classes.instanceFields(beanClass)) {\n            if (!hasValidationAnnotation(field)) continue;\n\n            Type fieldType = field.getGenericType();\n            Class<?> fieldClass = GenericTypes.rawClass(fieldType);\n            String pathLiteral = variable(path(field, parentPath));\n\n            builder.indent(1).append(\"if (bean.{} == null) {\\n\", field.getName());\n            NotNull notNull = field.getDeclaredAnnotation(NotNull.class);\n            if (notNull != null)\n                builder.indent(2).append(\"if (!partial) errors.add({}, {}, null);\\n\", pathLiteral, variable(notNull.message()));\n            builder.indent(1).append(\"} else {\\n\");\n\n            if (String.class.equals(fieldClass)) {\n                buildStringValidation(builder, field, pathLiteral);\n            } else if (GenericTypes.isList(fieldType)) {\n                buildListValidation(builder, field, pathLiteral, parentPath);\n            } else if (GenericTypes.isMap(fieldType)) {\n                buildMapValidation(builder, field, pathLiteral, parentPath);\n            } else if (Number.class.isAssignableFrom(fieldClass)) {\n                buildNumberValidation(builder, field, pathLiteral);\n            } else if (beanClass(fieldClass)) {\n                String method = validateMethod(fieldClass, path(field, parentPath));\n                builder.indent(2).append(\"{}(bean.{}, errors, partial);\\n\", method, field.getName());\n            }\n\n            builder.indent(1).append(\"}\\n\");\n        }\n        builder.append('}');\n        this.builder.addMethod(builder.build());\n        return methodName;\n    }\n\n    private void buildNumberValidation(CodeBuilder builder, Field field, String pathLiteral) {\n        Min min = field.getDeclaredAnnotation(Min.class);\n        if (min != null)\n            builder.indent(2).append(\"if (bean.{}.doubleValue() < {}) errors.add({}, {}, java.util.Map.of(\\\"value\\\", String.valueOf(bean.{}), \\\"min\\\", \\\"{}\\\"));\\n\",\n                field.getName(), min.value(), pathLiteral, variable(min.message()),\n                field.getName(), min.value());\n        Max max = field.getDeclaredAnnotation(Max.class);\n        if (max != null)\n            builder.indent(2).append(\"if (bean.{}.doubleValue() > {}) errors.add({}, {}, java.util.Map.of(\\\"value\\\", String.valueOf(bean.{}), \\\"max\\\", \\\"{}\\\"));\\n\",\n                field.getName(), max.value(), pathLiteral, variable(max.message()),\n                field.getName(), max.value());\n        Digits digits = field.getDeclaredAnnotation(Digits.class);\n        if (digits != null) {\n            int integer = digits.integer();\n            int fraction = digits.fraction();\n            builder.indent(2).append(\"{}.validateDigits(bean.{}, {}, {}, {}, {}, errors);\\n\",\n                type(ValidatorHelper.class), field.getName(), integer, fraction, variable(digits.message()), pathLiteral);\n        }\n    }\n\n    private void buildMapValidation(CodeBuilder builder, Field field, String pathLiteral, String parentPath) {\n        buildSizeValidation(builder, field, pathLiteral, \"size\");\n\n        Type valueType = GenericTypes.mapValueType(field.getGenericType());\n        if (GenericTypes.isList(valueType)) return; // ensured by class validator, if it's list it must be List<Value>\n\n        Class<?> valueClass = GenericTypes.rawClass(valueType);\n        if (beanClass(valueClass)) {\n            String method = validateMethod(valueClass, path(field, parentPath));\n            builder.indent(2).append(\"for (java.util.Iterator iterator = bean.{}.entrySet().iterator(); iterator.hasNext(); ) {\\n\", field.getName())\n                .indent(3).append(\"java.util.Map.Entry entry = (java.util.Map.Entry) iterator.next();\\n\")\n                .indent(3).append(\"{} value = ({}) entry.getValue();\\n\", type(valueClass), type(valueClass))\n                .indent(3).append(\"if (value != null) {}(value, errors, partial);\\n\", method)\n                .indent(2).append(\"}\\n\");\n        }\n    }\n\n    private void buildListValidation(CodeBuilder builder, Field field, String pathLiteral, String parentPath) {\n        buildSizeValidation(builder, field, pathLiteral, \"size\");\n\n        Class<?> valueClass = GenericTypes.listValueClass(field.getGenericType());\n        if (beanClass(valueClass)) {\n            String method = validateMethod(valueClass, path(field, parentPath));\n            builder.indent(2).append(\"for (java.util.Iterator iterator = bean.{}.iterator(); iterator.hasNext(); ) {\\n\", field.getName())\n                .indent(3).append(\"{} value = ({}) iterator.next();\\n\", type(valueClass), type(valueClass))\n                .indent(3).append(\"if (value != null) {}(value, errors, partial);\\n\", method)\n                .indent(2).append(\"}\\n\");\n        }\n    }\n\n    private void buildStringValidation(CodeBuilder builder, Field field, String pathLiteral) {\n        NotBlank notBlank = field.getDeclaredAnnotation(NotBlank.class);\n        if (notBlank != null) builder.indent(2).append(\"if (bean.{}.isBlank()) errors.add({}, {}, null);\\n\", field.getName(), pathLiteral, variable(notBlank.message()));\n\n        buildSizeValidation(builder, field, pathLiteral, \"length\");\n\n        Pattern pattern = field.getDeclaredAnnotation(Pattern.class);\n        if (pattern != null) {\n            String patternFieldName = field.getName() + \"Pattern\" + (index++);\n            String patternVariable = variable(pattern.value());\n            this.builder.addField(\"private final java.util.regex.Pattern {} = java.util.regex.Pattern.compile({});\", patternFieldName, patternVariable);\n            builder.indent(2).append(\"if (!this.{}.matcher(bean.{}).matches()) errors.add({}, {}, java.util.Map.of(\\\"value\\\", bean.{}, \\\"pattern\\\", {}));\\n\",\n                patternFieldName, field.getName(), pathLiteral, variable(pattern.message()),\n                field.getName(), patternVariable);\n        }\n    }\n\n    private void buildSizeValidation(CodeBuilder builder, Field field, String pathLiteral, String sizeMethod) {\n        Size size = field.getDeclaredAnnotation(Size.class);\n        if (size != null) {\n            int min = size.min();\n            int max = size.max();\n            if (min > -1)\n                builder.indent(2).append(\"if (bean.{}.{}() < {}) errors.add({}, {}, java.util.Map.of(\\\"value\\\", String.valueOf(bean.{}.{}()), \\\"min\\\", \\\"{}\\\", \\\"max\\\", \\\"{}\\\"));\\n\",\n                    field.getName(), sizeMethod, min, pathLiteral, variable(size.message()),\n                    field.getName(), sizeMethod, min, max == -1 ? \"inf\" : max);\n            if (max > -1)\n                builder.indent(2).append(\"if (bean.{}.{}() > {}) errors.add({}, {}, java.util.Map.of(\\\"value\\\", String.valueOf(bean.{}.{}()), \\\"min\\\", \\\"{}\\\", \\\"max\\\", \\\"{}\\\"));\\n\",\n                    field.getName(), sizeMethod, max, pathLiteral, variable(size.message()),\n                    field.getName(), sizeMethod, min == -1 ? \"0\" : min, max);\n        }\n    }\n\n    private String path(Field field, String parentPath) {\n        String path = field.getName();\n        if (parentPath == null) return path;\n        return parentPath + \".\" + path;\n    }\n\n    private void validate(Class<?> beanClass, Field parentField) {\n        try {\n            Object beanWithDefaultValue = beanClass.getDeclaredConstructor().newInstance();\n            for (Field field : Classes.instanceFields(beanClass)) {\n                validateAnnotations(field, beanWithDefaultValue);\n                Class<?> targetClass = targetValidationClass(field);\n                if (beanClass(targetClass))\n                    validate(targetClass, field);\n            }\n        } catch (ReflectiveOperationException e) {\n            String path = parentField == null ? null : Fields.path(parentField);\n            throw new Error(format(\"failed to validate class, field={}, error={}\", path, e.getMessage()), e);\n        }\n    }\n\n    private boolean hasValidationAnnotation(Field field) {\n        boolean hasAnnotation = field.isAnnotationPresent(Digits.class)\n                                || field.isAnnotationPresent(NotNull.class)\n                                || field.isAnnotationPresent(NotBlank.class)\n                                || field.isAnnotationPresent(Max.class)\n                                || field.isAnnotationPresent(Min.class)\n                                || field.isAnnotationPresent(Pattern.class)\n                                || field.isAnnotationPresent(Size.class);\n        if (hasAnnotation) return true;\n\n        Class<?> targetClass = targetValidationClass(field);\n        if (beanClass(targetClass)) {\n            for (Field valueField : Classes.instanceFields(targetClass)) {\n                if (hasValidationAnnotation(valueField)) return true;\n            }\n        }\n        return false;\n    }\n\n    private Class<?> targetValidationClass(Field field) {\n        Type fieldType = field.getGenericType();\n        if (GenericTypes.isList(fieldType)) {\n            return GenericTypes.listValueClass(fieldType);\n        } else if (GenericTypes.isMap(fieldType)) {\n            Type mapValueType = GenericTypes.mapValueType(fieldType);\n            if (GenericTypes.isList(mapValueType)) {\n                return GenericTypes.listValueClass(mapValueType);\n            }\n            return GenericTypes.rawClass(mapValueType);\n        } else {\n            return GenericTypes.rawClass(fieldType);\n        }\n    }\n\n    private void validateAnnotations(Field field, Object beanWithDefaultValues) throws IllegalAccessException {\n        Type fieldType = field.getGenericType();\n\n        if (!field.isAnnotationPresent(NotNull.class) && field.get(beanWithDefaultValues) != null)\n            throw new Error(format(\"field with default value must have @NotNull, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n\n        Size size = field.getDeclaredAnnotation(Size.class);\n        if (size != null && !String.class.equals(fieldType) && !GenericTypes.isList(fieldType) && !GenericTypes.isMap(fieldType))\n            throw new Error(format(\"@Size must on String, List<?> or Map<String, ?>, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n\n        NotBlank notBlank = field.getDeclaredAnnotation(NotBlank.class);\n        if (notBlank != null && !String.class.equals(fieldType))\n            throw new Error(format(\"@NotBlank must on String, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n\n        Pattern pattern = field.getDeclaredAnnotation(Pattern.class);\n        if (pattern != null) {\n            if (!String.class.equals(fieldType)) throw new Error(format(\"@Pattern must on String, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n            try {\n                java.util.regex.Pattern.compile(pattern.value());\n            } catch (PatternSyntaxException e) {\n                throw new Error(format(\"@Pattern has invalid pattern, pattern={}, field={}, fieldType={}\", pattern.value(), Fields.path(field), fieldType.getTypeName()), e);\n            }\n        }\n\n        Class<?> fieldClass = GenericTypes.rawClass(fieldType);\n        Max max = field.getDeclaredAnnotation(Max.class);\n        if (max != null && !Number.class.isAssignableFrom(fieldClass))\n            throw new Error(format(\"@Max must on Number, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n\n        Min min = field.getDeclaredAnnotation(Min.class);\n        if (min != null && !Number.class.isAssignableFrom(fieldClass))\n            throw new Error(format(\"@Min must on Number, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n\n        Digits digits = field.getDeclaredAnnotation(Digits.class);\n        if (digits != null && !Number.class.isAssignableFrom(fieldClass))\n            throw new Error(format(\"@Digits must on Number, field={}, fieldType={}\", Fields.path(field), fieldType.getTypeName()));\n    }\n\n    // whether to check all fields inside\n    private boolean beanClass(Class<?> fieldClass) {\n        if (fieldClass.getPackageName().startsWith(\"java\")) return false;   // ignore all java built in class\n        if (fieldClass.isEnum()) return false;\n        if (\"org.bson.types.ObjectId\".equals(fieldClass.getCanonicalName())) return false; // not depends on mongo jar if application doesn't include mongo driver\n        return true;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ClassValidator.java."}, {"role": "assistant", "content": "The source code of java class ClassValidator.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.internal.reflect.Fields;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.util.Sets;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class ClassValidator {\n    public final Class<?> instanceClass;\n    private final Set<Class<?>> visitedClasses = Sets.newHashSet();\n    private final ClassValidatorSupport support = new ClassValidatorSupport();\n\n    public Set<Class<?>> allowedValueClasses = Set.of();\n    public ClassVisitor visitor;\n\n    public ClassValidator(Class<?> instanceClass) {\n        this.instanceClass = instanceClass;\n    }\n\n    public void validate() {\n        visitObject(instanceClass, null, null);\n    }\n\n    private void visitObject(Class<?> objectClass, Field owner, String path) {\n        if (visitedClasses.contains(objectClass))\n            throw new Error(\"class must not have circular reference, field=\" + Fields.path(owner));\n\n        visitedClasses.add(objectClass);\n\n        support.validateClass(objectClass);\n        if (visitor != null) visitor.visitClass(objectClass, path);\n\n        for (Field field : support.declaredFields(objectClass)) {\n            if (visitor != null) visitor.visitField(field, path);\n\n            String fieldPath = path(path, field.getName());\n            Type fieldType = field.getGenericType();\n            if (GenericTypes.isList(fieldType)) {\n                visitList(fieldType, field, fieldPath);\n            } else if (GenericTypes.isMap(fieldType)) {\n                visitMap(fieldType, field, fieldPath);\n            } else {\n                visitValue(GenericTypes.rawClass(fieldType), field, fieldPath);\n            }\n        }\n\n        visitedClasses.remove(objectClass);\n    }\n\n    private void visitValue(Class<?> valueClass, Field owner, String path) {\n        if (valueClass.isEnum()) {\n            if (visitor != null) visitor.visitEnum(valueClass);\n            return; // enum is allowed value type\n        }\n\n        if (allowedValueClasses.contains(valueClass)) return;\n\n        if (valueClass.getPackageName().startsWith(\"java\"))\n            throw new Error(format(\"field class is not supported, class={}, field={}\", valueClass.getCanonicalName(), Fields.path(owner)));\n\n        visitObject(valueClass, owner, path);\n    }\n\n    private void visitMap(Type fieldType, Field owner, String path) {\n        if (!GenericTypes.isGenericMap(fieldType))\n            throw new Error(\"map must be Map<K,V>, K must be String or Enum and V must be class or List<Value>, field=\" + Fields.path(owner));\n\n        Class<?> keyClass = GenericTypes.mapKeyClass(fieldType);\n        if (!String.class.equals(keyClass) && !keyClass.isEnum())\n            throw new Error(\"map key must be String or Enum, field=\" + Fields.path(owner));\n        if (visitor != null && keyClass.isEnum())\n            visitor.visitEnum(keyClass);\n\n        Type mapValueType = GenericTypes.mapValueType(fieldType);\n        if (GenericTypes.isList(mapValueType)) {\n            if (!GenericTypes.isGenericList(mapValueType))\n                throw new Error(\"map must be Map<K,List<V>> and V must be value class, field=\" + Fields.path(owner));\n\n            Class<?> listValueClass = GenericTypes.listValueClass(mapValueType);\n            if (!allowedValueClasses.contains(listValueClass)) {\n                throw new Error(format(\"map list value class is not supported, class={}, field={}\", listValueClass.getCanonicalName(), Fields.path(owner)));\n            }\n        } else {\n            visitValue(GenericTypes.rawClass(mapValueType), owner, path);\n        }\n    }\n\n    private void visitList(Type listType, Field owner, String path) {\n        if (!GenericTypes.isGenericList(listType))\n            throw new Error(\"list must be List<T> and T must be class, field=\" + Fields.path(owner));\n\n        Class<?> valueClass = GenericTypes.listValueClass(listType);\n        visitValue(valueClass, owner, path);\n    }\n\n    private String path(String parent, String field) {\n        if (parent == null) return field;\n        return parent + \"/\" + field;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ClassValidatorSupport.java."}, {"role": "assistant", "content": "The source code of java class ClassValidatorSupport.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.internal.reflect.Fields;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class ClassValidatorSupport {\n    public void validateClass(Class<?> objectClass) {\n        if (objectClass.isPrimitive() || objectClass.getPackageName().startsWith(\"java\") || objectClass.isEnum())\n            throw new Error(\"class must be bean class, class=\" + objectClass.getCanonicalName());\n        if (objectClass.isMemberClass() && !Modifier.isStatic(objectClass.getModifiers()))\n            throw new Error(\"class must be static, class=\" + objectClass.getCanonicalName());\n        if (objectClass.isInterface() || Modifier.isAbstract(objectClass.getModifiers()) || !Modifier.isPublic(objectClass.getModifiers()))\n            throw new Error(\"class must be public concrete, class=\" + objectClass.getCanonicalName());\n        if (!Object.class.equals(objectClass.getSuperclass()))\n            throw new Error(\"class must not have super class, class=\" + objectClass.getCanonicalName());\n\n        Constructor<?>[] constructors = objectClass.getDeclaredConstructors();\n        if (constructors.length > 1 || constructors[0].getParameterCount() > 0 || !Modifier.isPublic(constructors[0].getModifiers())) {\n            throw new Error(format(\"class must only have public default constructor, class={}, constructors={}\", objectClass.getCanonicalName(), Arrays.toString(constructors)));\n        }\n    }\n\n    // return fields to validate\n    public List<Field> declaredFields(Class<?> objectClass) {\n        Field[] fields = objectClass.getDeclaredFields();\n        List<Field> results = new ArrayList<>(fields.length);\n        for (Field field : fields) {\n            if (field.isSynthetic()) continue;  // ignore dynamic/generated field, e.g. jacoco\n            if (Modifier.isStatic(field.getModifiers()) && Modifier.isFinal(field.getModifiers())) continue;  // ignore all static final field\n\n            validateField(field);\n\n            results.add(field);\n        }\n        return results;\n    }\n\n    void validateField(Field field) {\n        int modifiers = field.getModifiers();\n        if (Modifier.isStatic(modifiers))\n            throw new Error(\"field must not be static, field=\" + Fields.path(field));\n        if (!Modifier.isPublic(modifiers))\n            throw new Error(\"field must be public, field=\" + Fields.path(field));\n        if (Modifier.isTransient(modifiers))\n            throw new Error(\"field must not be transient, field=\" + Fields.path(field));\n        if (Modifier.isFinal(modifiers))\n            throw new Error(\"field must not be final, field=\" + Fields.path(field));\n\n        Class<?> fieldClass = field.getType();\n        if (Date.class.isAssignableFrom(fieldClass))\n            throw new Error(\"java.util.Date is not supported, please use java.time instead, field=\" + Fields.path(field));\n        if (fieldClass.isPrimitive())\n            throw new Error(format(\"primitive class is not supported, please use object type, class={}, field={}\", fieldClass.getCanonicalName(), Fields.path(field)));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ClassVisitor.java."}, {"role": "assistant", "content": "The source code of java class ClassVisitor.java:\n```java\npackage core.framework.internal.validate;\n\nimport java.lang.reflect.Field;\n\n/**\n * @author neo\n */\npublic interface ClassVisitor {\n    default void visitClass(Class<?> objectClass, String path) {\n    }\n\n    default void visitField(Field field, String parentPath) {\n    }\n\n    default void visitEnum(Class<?> enumClass) {\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ValidationErrors.java."}, {"role": "assistant", "content": "The source code of java class ValidationErrors.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class ValidationErrors {\n    public Map<String, String> errors;\n\n    public void add(String field, String error, Map<String, String> arguments) {\n        if (errors == null) errors = Maps.newLinkedHashMap();\n        String errorMessage = message(error, arguments);\n        errors.put(field, errorMessage);\n    }\n\n    // assume var can only be used once, and there are only limited predefined vars, not considering i18n, just to make default message more friendly for engineers\n    String message(String error, Map<String, String> arguments) {\n        if (arguments == null) return error;\n        var builder = new StringBuilder(error);\n        for (Map.Entry<String, String> entry : arguments.entrySet()) {\n            String var = \"{\" + entry.getKey() + \"}\";\n            int index = builder.indexOf(var);\n            if (index >= 0) {\n                builder.replace(index, index + var.length(), entry.getValue());\n            }\n        }\n        return builder.toString();\n    }\n\n    public boolean hasError() {\n        return errors != null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ValidationException.java."}, {"role": "assistant", "content": "The source code of java class ValidationException.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.log.ErrorCode;\n\nimport java.io.Serial;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class ValidationException extends RuntimeException implements ErrorCode {\n    @Serial\n    private static final long serialVersionUID = -2784801858422440222L;\n    public final transient Map<String, String> errors;\n\n    public ValidationException(Map<String, String> errors) {\n        super(\"validation failed, error=\" + errors);\n        this.errors = errors;\n    }\n\n    @Override\n    public String errorCode() {\n        return \"VALIDATION_ERROR\";\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Validator.java."}, {"role": "assistant", "content": "The source code of java class Validator.java:\n```java\npackage core.framework.internal.validate;\n\nimport core.framework.internal.log.filter.BytesLogParam;\nimport core.framework.json.JSON;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class Validator<T> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Validator.class);\n    private static Map<Class<?>, Validator<?>> validators = new HashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Validator<T> of(Class<T> beanClass) {\n        // can only be used during config time within module, App will run cleanup after startup\n        return (Validator<T>) validators.computeIfAbsent(beanClass, Validator::new);\n    }\n\n    public static void cleanup() {\n        validators = null;\n    }\n\n    @Nullable\n    private final BeanValidator validator;\n\n    private Validator(Class<T> beanClass) {\n        var builder = new BeanValidatorBuilder(beanClass);\n        this.validator = builder.build();\n    }\n\n    public void validate(T bean, boolean partial) {\n        Map<String, String> errors = errors(bean, partial);\n        if (errors != null) throw new ValidationException(errors);\n    }\n\n    // used only internally, for places don't want to catch exception\n    public Map<String, String> errors(T bean, boolean partial) {\n        if (bean == null) {\n            return Map.of(\"bean\", \"bean must not be null\");\n        }\n\n        if (validator != null) { // validator can be null if no validation annotation presents\n            var errors = new ValidationErrors();\n            validator.validate(bean, errors, partial);\n            if (errors.hasError()) {\n                // all validatable beans can be converted to JSON, only log content on failure path, not to slow down happy path\n                // use debug level not to interfere error_code in action log\n                LOGGER.debug(\"validate, beanClass={}, bean={}, partial={}\", bean.getClass().getCanonicalName(),\n                        new BytesLogParam(Strings.bytes(JSON.toJSON(bean))),\n                        partial);\n                return errors.errors;\n            }\n        }\n        return null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ValidatorHelper.java."}, {"role": "assistant", "content": "The source code of java class ValidatorHelper.java:\n```java\npackage core.framework.internal.validate;\n\nimport java.math.BigDecimal;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class ValidatorHelper {  // used by generated BeanValidator\n    public static void validateDigits(Number value, int maxIntegerDigits, int maxFractionDigits, String message, String pathLiteral, ValidationErrors errors) {\n        BigDecimal number;\n        if (value instanceof BigDecimal) {\n            number = (BigDecimal) value;\n        } else {\n            number = new BigDecimal(value.toString()).stripTrailingZeros();\n        }\n        if (maxIntegerDigits > -1) {\n            int integerDigits = number.precision() - number.scale();\n            if (integerDigits > maxIntegerDigits) errors.add(pathLiteral, message,\n                    Map.of(\"value\", String.valueOf(value),\n                            \"integer\", String.valueOf(maxIntegerDigits),\n                            \"fraction\", maxFractionDigits == -1 ? \"inf\" : String.valueOf(maxFractionDigits)));\n        }\n        if (maxFractionDigits > -1) {\n            int fractionDigits = Math.max(number.scale(), 0);\n            if (fractionDigits > maxFractionDigits) errors.add(pathLiteral, message,\n                    Map.of(\"value\", String.valueOf(value),\n                            \"integer\", maxIntegerDigits == -1 ? \"inf\" : String.valueOf(maxIntegerDigits),\n                            \"fraction\", String.valueOf(maxFractionDigits)));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class APIDefinitionBuilder.java."}, {"role": "assistant", "content": "The source code of java class APIDefinitionBuilder.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.reflect.Params;\nimport core.framework.internal.web.service.HTTPMethods;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.UUID;\n\n/**\n * @author neo\n */\npublic class APIDefinitionBuilder {\n    private final Set<Class<?>> serviceInterfaces;\n    private final Set<Class<?>> beanClasses;\n    private final APITypeParser parser = new APITypeParser();\n\n    public APIDefinitionBuilder(Set<Class<?>> serviceInterfaces, Set<Class<?>> beanClasses) {\n        this.serviceInterfaces = serviceInterfaces;\n        this.beanClasses = beanClasses;\n    }\n\n    public APIDefinitionResponse build() {\n        var response = new APIDefinitionResponse();\n        response.app = LogManager.APP_NAME;\n        response.version = UUID.randomUUID().toString();\n        response.services = services();\n        for (Class<?> beanClass : beanClasses) {\n            if (beanClass.isEnum()) {\n                parser.parseEnumType(beanClass);\n            } else {\n                parser.parseBeanType(beanClass);\n            }\n        }\n        response.types = parser.types();\n        return response;\n    }\n\n    private List<APIDefinitionResponse.Service> services() {\n        var services = new ArrayList<APIDefinitionResponse.Service>(serviceInterfaces.size());\n        for (Class<?> serviceInterface : serviceInterfaces) {\n            services.add(service(serviceInterface));\n        }\n        return services;\n    }\n\n    private APIDefinitionResponse.Service service(Class<?> serviceInterface) {\n        var service = new APIDefinitionResponse.Service();\n        service.name = serviceInterface.getSimpleName();\n        Method[] methods = serviceInterface.getMethods();\n        Arrays.sort(methods, Comparator.comparing((Method method) -> method.getDeclaredAnnotation(Path.class).value()).thenComparing(method -> HTTPMethods.httpMethod(method).ordinal()));\n        service.operations = new ArrayList<>(methods.length);\n        for (Method method : methods) {\n            var operation = new APIDefinitionResponse.Operation();\n            operation.name = method.getName();\n            operation.method = String.valueOf(HTTPMethods.httpMethod(method));\n            operation.path = method.getDeclaredAnnotation(Path.class).value();\n            parseParams(operation, method);\n            operation.optional = GenericTypes.isOptional(method.getGenericReturnType());\n            operation.responseType = parseResponseType(method.getGenericReturnType(), operation.optional);\n            operation.deprecated = method.isAnnotationPresent(Deprecated.class);\n            service.operations.add(operation);\n        }\n        return service;\n    }\n\n    private String parseResponseType(Type returnType, boolean optional) {\n        // response can only be Optional<T> or Class\n        if (optional) {\n            return parser.parseType(GenericTypes.optionalValueClass(returnType)).type;\n        }\n        return parser.parseType(returnType).type;\n    }\n\n    private void parseParams(APIDefinitionResponse.Operation operation, Method method) {\n        Annotation[][] annotations = method.getParameterAnnotations();\n        Type[] paramTypes = method.getGenericParameterTypes();\n        for (int i = 0; i < paramTypes.length; i++) {\n            var type = parser.parseType(paramTypes[i]);\n            PathParam pathParam = Params.annotation(annotations[i], PathParam.class);\n            if (pathParam != null) {\n                var param = new APIDefinitionResponse.PathParam();\n                param.name = pathParam.value();\n                param.type = type.type; // path param type must be simple type\n                operation.pathParams.add(param);\n            } else {\n                operation.requestType = type.type;\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class APIDefinitionResponse.java."}, {"role": "assistant", "content": "The source code of java class APIDefinitionResponse.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.api.json.Property;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class APIDefinitionResponse {\n    @Property(name = \"app\")\n    public String app;\n\n    @Property(name = \"version\")\n    public String version;      // used to fast compare\n\n    @Property(name = \"services\")\n    public List<Service> services;\n\n    @Property(name = \"types\")\n    public List<APIType> types;\n\n    public static class Service {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"operations\")\n        public List<Operation> operations;\n    }\n\n    public static class Operation {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"method\")\n        public String method;\n\n        @Property(name = \"path\")\n        public String path;\n\n        @Property(name = \"pathParams\")\n        public List<PathParam> pathParams = new ArrayList<>();\n\n        @Property(name = \"requestType\")\n        public String requestType;\n\n        @Property(name = \"responseType\")\n        public String responseType;\n\n        @Property(name = \"optional\")\n        public Boolean optional;\n\n        @Property(name = \"deprecated\")\n        public Boolean deprecated;\n    }\n\n    public static class PathParam {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"type\")\n        public String type;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class APIType.java."}, {"role": "assistant", "content": "The source code of java class APIType.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.api.json.Property;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class APIType {\n    @Property(name = \"name\")\n    public String name;\n\n    @Property(name = \"type\")\n    public String type;     // bean or enum\n\n    @Property(name = \"fields\")\n    public List<Field> fields;\n\n    @Property(name = \"enumConstants\")\n    public List<EnumConstant> enumConstants;\n\n    public static class Field {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"type\")\n        public String type;\n\n        @Property(name = \"typeParams\")\n        public List<String> typeParams;\n\n        @Property(name = \"constraints\")\n        public Constraints constraints = new Constraints();\n    }\n\n    public static class Constraints {\n        @Property(name = \"notNull\")\n        public Boolean notNull;\n\n        @Property(name = \"notBlank\")\n        public Boolean notBlank;\n\n        @Property(name = \"min\")\n        public Double min;\n\n        @Property(name = \"max\")\n        public Double max;\n\n        @Property(name = \"size\")\n        public Size size;\n\n        @Property(name = \"pattern\")\n        public String pattern;\n    }\n\n    public static class Size {\n        @Property(name = \"min\")\n        public Integer min;\n\n        @Property(name = \"max\")\n        public Integer max;\n    }\n\n    public static class EnumConstant {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"value\")\n        public String value;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class APITypeParser.java."}, {"role": "assistant", "content": "The source code of java class APITypeParser.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.validate.Max;\nimport core.framework.api.validate.Min;\nimport core.framework.api.validate.NotBlank;\nimport core.framework.api.validate.NotNull;\nimport core.framework.api.validate.Pattern;\nimport core.framework.api.validate.Size;\nimport core.framework.api.web.service.QueryParam;\nimport core.framework.internal.reflect.Classes;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.util.Maps;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author neo\n */\nclass APITypeParser {\n    private final Map<String, APIType> types = Maps.newLinkedHashMap();\n    private final Set<Class<?>> valueClasses = Set.of(String.class, Boolean.class,\n        Integer.class, Long.class, Double.class, BigDecimal.class,\n        LocalDate.class, LocalDateTime.class, ZonedDateTime.class, LocalTime.class);\n\n    List<APIType> types() {\n        return new ArrayList<>(types.values());\n    }\n\n    TypeDefinition parseType(Type type) {\n        if (type == void.class) return new TypeDefinition(\"void\");\n        if (GenericTypes.isList(type)) {\n            var valueType = parseType(GenericTypes.listValueClass(type));\n            return new TypeDefinition(\"List\").addParam(valueType.type);\n        }\n        if (GenericTypes.isMap(type)) {\n            Class<?> keyClass = GenericTypes.mapKeyClass(type);\n            var definition = new TypeDefinition(\"Map\");\n            if (String.class.equals(keyClass)) {\n                definition.addParam(\"String\");\n            } else {        // Map key can only be String or enum\n                definition.addParam(parseEnumType(keyClass));\n            }\n            var valueType = parseType(GenericTypes.mapValueType(type));\n            definition.addParam(valueType.type);\n            if (valueType.params != null) definition.addParam(valueType.params.get(0));    // Map<T, List<V>> is most complex type\n            return definition;\n        }\n        Class<?> rawClass = GenericTypes.rawClass(type);  // it must be class type at this point\n        if (valueClasses.contains(rawClass)) return new TypeDefinition(rawClass.getSimpleName());\n        if (Instant.class.equals(type)) return new TypeDefinition(\"ZonedDateTime\");\n        if (rawClass.isEnum()) {\n            return new TypeDefinition(parseEnumType((Class<?>) type));\n        }\n        return new TypeDefinition(parseBeanType(rawClass));\n    }\n\n    String parseBeanType(Class<?> beanClass) {\n        String className = Classes.className(beanClass);\n        if (!types.containsKey(className)) {\n            List<Field> fields = Classes.instanceFields(beanClass);\n            var definition = new APIType();\n            definition.type = \"bean\";\n            definition.name = className;\n            definition.fields = new ArrayList<>(fields.size());\n            types.put(className, definition);  // put into map before parsing fields to handle circular reference\n            for (Field field : fields) {\n                var fieldDefinition = new APIType.Field();\n                fieldDefinition.name = fieldName(field);\n                var type = parseType(field.getGenericType());\n                fieldDefinition.type = type.type;\n                fieldDefinition.typeParams = type.params;\n                parseConstraints(field, fieldDefinition.constraints);\n                definition.fields.add(fieldDefinition);\n            }\n        }\n        return className;\n    }\n\n    String parseEnumType(Class<?> enumClass) {\n        String className = Classes.className(enumClass);\n        types.computeIfAbsent(className, key -> {\n            List<Field> fields = Classes.enumConstantFields(enumClass);\n            var definition = new APIType();\n            definition.type = \"enum\";\n            definition.name = className;\n            definition.enumConstants = new ArrayList<>(fields.size());\n            for (Field field : fields) {\n                var constant = new APIType.EnumConstant();\n                constant.name = field.getName();\n                constant.value = field.getDeclaredAnnotation(Property.class).name();\n                definition.enumConstants.add(constant);\n            }\n            return definition;\n        });\n        return className;\n    }\n\n    private void parseConstraints(Field field, APIType.Constraints constraints) {\n        constraints.notNull = field.isAnnotationPresent(NotNull.class);\n        constraints.notBlank = field.isAnnotationPresent(NotBlank.class);\n        Min min = field.getDeclaredAnnotation(Min.class);\n        if (min != null) constraints.min = min.value();\n        Max max = field.getDeclaredAnnotation(Max.class);\n        if (max != null) constraints.max = max.value();\n        Size size = field.getDeclaredAnnotation(Size.class);\n        if (size != null) {\n            constraints.size = new APIType.Size();\n            constraints.size.min = size.min();\n            constraints.size.max = size.max();\n        }\n        Pattern pattern = field.getDeclaredAnnotation(Pattern.class);\n        if (pattern != null) constraints.pattern = pattern.value();\n    }\n\n    private String fieldName(Field field) {\n        Property property = field.getDeclaredAnnotation(Property.class);\n        if (property != null) return property.name();\n        return field.getDeclaredAnnotation(QueryParam.class).name();\n    }\n\n    static class TypeDefinition {\n        final String type;\n        List<String> params;\n\n        TypeDefinition(String type) {\n            this.type = type;\n        }\n\n        TypeDefinition addParam(String param) {\n            if (params == null) params = new ArrayList<>();\n            params.add(param);\n            return this;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageAPIDefinitionBuilder.java."}, {"role": "assistant", "content": "The source code of java class MessageAPIDefinitionBuilder.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.internal.log.LogManager;\n\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * @author neo\n */\npublic class MessageAPIDefinitionBuilder {\n    private final Map<String, Class<?>> topics;\n    private final APITypeParser parser = new APITypeParser();\n\n    public MessageAPIDefinitionBuilder(Map<String, Class<?>> topics) {\n        this.topics = topics;\n    }\n\n    public MessageAPIDefinitionResponse build() {\n        var response = new MessageAPIDefinitionResponse();\n        response.app = LogManager.APP_NAME;\n        response.version = UUID.randomUUID().toString();\n        response.topics = new ArrayList<>(topics.size());\n        for (Map.Entry<String, Class<?>> entry : topics.entrySet()) {\n            var topic = new MessageAPIDefinitionResponse.Topic();\n            topic.name = entry.getKey();\n            topic.messageType = parser.parseBeanType(entry.getValue());\n            response.topics.add(topic);\n        }\n        response.types = parser.types();\n        return response;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageAPIDefinitionResponse.java."}, {"role": "assistant", "content": "The source code of java class MessageAPIDefinitionResponse.java:\n```java\npackage core.framework.internal.web.api;\n\nimport core.framework.api.json.Property;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class MessageAPIDefinitionResponse {\n    @Property(name = \"app\")\n    public String app;\n\n    @Property(name = \"version\")\n    public String version;      // used to fast compare\n\n    @Property(name = \"topics\")\n    public List<Topic> topics;\n\n    @Property(name = \"types\")\n    public List<APIType> types;\n\n    public static class Topic {\n        @Property(name = \"name\")\n        public String name;\n\n        @Property(name = \"messageType\")\n        public String messageType;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamClassValidator.java."}, {"role": "assistant", "content": "The source code of java class QueryParamClassValidator.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.api.json.Property;\nimport core.framework.api.web.service.QueryParam;\nimport core.framework.internal.bean.BeanClassNameValidator;\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.reflect.Fields;\nimport core.framework.internal.validate.ClassValidatorSupport;\nimport core.framework.internal.validate.ClassVisitor;\nimport core.framework.util.Sets;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nfinal class QueryParamClassValidator implements ClassVisitor {\n    private final ClassValidatorSupport support = new ClassValidatorSupport();\n    private final BeanClassNameValidator beanClassNameValidator;\n    private final Class<?> beanClass;\n    private final Set<Class<?>> allowedValueClasses = Set.of(String.class, Boolean.class,\n        Integer.class, Long.class, Double.class, BigDecimal.class,\n        LocalDate.class, LocalDateTime.class, ZonedDateTime.class, LocalTime.class);\n    private final Set<String> visitedParams = Sets.newHashSet();\n\n    QueryParamClassValidator(Class<?> beanClass, BeanClassNameValidator beanClassNameValidator) {\n        this.beanClass = beanClass;\n        this.beanClassNameValidator = beanClassNameValidator;\n    }\n\n    public void validate() {\n        support.validateClass(beanClass);\n        beanClassNameValidator.validate(beanClass);\n\n        for (Field field : support.declaredFields(beanClass)) {\n            validateAnnotations(field);\n            validateValueField(field);\n        }\n    }\n\n    private void validateAnnotations(Field field) {\n        QueryParam queryParam = field.getDeclaredAnnotation(QueryParam.class);\n        if (queryParam == null)\n            throw new Error(\"field must have @QueryParam, field=\" + Fields.path(field));\n\n        Property property = field.getDeclaredAnnotation(Property.class);\n        if (property != null)\n            throw new Error(\"field must not have @Property, field=\" + Fields.path(field));\n\n        String name = queryParam.name();\n        boolean added = visitedParams.add(name);\n        if (!added)\n            throw new Error(format(\"found duplicate query param, field={}, name={}\", Fields.path(field), name));\n    }\n\n    private void validateValueField(Field field) {\n        Class<?> fieldClass = field.getType();\n\n        if (fieldClass.isEnum()) {  // enum is allowed value type\n            beanClassNameValidator.validate(fieldClass);\n            JSONClassValidator.validateEnum(fieldClass);\n            return;\n        }\n\n        if (allowedValueClasses.contains(fieldClass)) return;\n\n        if (fieldClass.getPackageName().startsWith(\"java\"))\n            throw new Error(format(\"field class is not supported, class={}, field={}\", fieldClass.getCanonicalName(), Fields.path(field)));\n\n        throw new Error(format(\"child object is not allowed, class={}, field={}\", fieldClass.getCanonicalName(), Fields.path(field)));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamHelper.java."}, {"role": "assistant", "content": "The source code of java class QueryParamHelper.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.internal.web.service.PathParamHelper;\nimport core.framework.json.JSON;\nimport core.framework.web.exception.BadRequestException;\n\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\n\n/**\n * @author neo\n */\nfinal class QueryParamHelper {   // used by generated QueryParamMapper\n    public static String toString(Number value) {\n        if (value == null) return null;\n        return value.toString();\n    }\n\n    public static String toString(Boolean value) {\n        if (value == null) return null;\n        return value.toString();\n    }\n\n    public static String toString(LocalDateTime dateTime) {\n        if (dateTime == null) return null;\n        return DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(dateTime);\n    }\n\n    public static String toString(LocalDate date) {\n        if (date == null) return null;\n        return DateTimeFormatter.ISO_LOCAL_DATE.format(date);\n    }\n\n    public static String toString(LocalTime time) {\n        if (time == null) return null;\n        return DateTimeFormatter.ISO_LOCAL_TIME.format(time);\n    }\n\n    public static String toString(ZonedDateTime dateTime) {\n        if (dateTime == null) return null;\n        return DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(dateTime);\n    }\n\n    public static <T extends Enum<?>> String toString(T enumValue) {\n        if (enumValue == null) return null;\n        return JSON.toEnumValue(enumValue);\n    }\n\n    // deserialization helpers\n    public static String toString(String value) {\n        if (value.isEmpty()) return null;\n        return value;\n    }\n\n    public static Integer toInt(String value) {\n        if (value.isEmpty()) return null;\n        return PathParamHelper.toInt(value);\n    }\n\n    public static Long toLong(String value) {\n        if (value.isEmpty()) return null;\n        return PathParamHelper.toLong(value);\n    }\n\n    public static Double toDouble(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return Double.valueOf(value);\n        } catch (NumberFormatException e) {\n            throw new BadRequestException(\"failed to parse double, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static BigDecimal toBigDecimal(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return new BigDecimal(value);\n        } catch (NumberFormatException e) {\n            throw new BadRequestException(\"failed to parse big decimal, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static Boolean toBoolean(String value) {\n        if (value.isEmpty()) return null;\n        return Boolean.valueOf(value);  // Boolean.parseBoolean does not throw exception\n    }\n\n    public static <T extends Enum<?>> T toEnum(String value, Class<T> valueClass) {\n        if (value.isEmpty()) return null;\n        return PathParamHelper.toEnum(value, valueClass);\n    }\n\n    public static ZonedDateTime toZonedDateTime(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return ZonedDateTime.parse(value, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n        } catch (DateTimeParseException e) {\n            throw new BadRequestException(\"failed to parse zoned date time, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static LocalDateTime toDateTime(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return LocalDateTime.parse(value, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n        } catch (DateTimeParseException e) {\n            throw new BadRequestException(\"failed to parse local date time, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static LocalTime toTime(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return LocalTime.parse(value, DateTimeFormatter.ISO_LOCAL_TIME);\n        } catch (DateTimeParseException e) {\n            throw new BadRequestException(\"failed to parse local time, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static LocalDate toDate(String value) {\n        if (value.isEmpty()) return null;\n        try {\n            return LocalDate.parse(value, DateTimeFormatter.ISO_LOCAL_DATE);\n        } catch (DateTimeParseException e) {\n            throw new BadRequestException(\"failed to parse local date, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamReader.java."}, {"role": "assistant", "content": "The source code of java class QueryParamReader.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface QueryParamReader<T> {\n    // in query string or form url encoding body, key=value, the value can be empty string\n    // with use cases\n    //  1. api client calls web service (possibly client uses old version of QueryParamBean)\n    //  2. ajax from browser or js application to call web service\n    // by considering type safety, explicit style, default value, passing null value and validation handling\n    // the best trade off is to treat empty string as null,\n    // if one param is not present in query string, it will be skipped during deserialization, hence will be assigned with default value\n    // only downside is with string field, if client pass \"\" as value, the server side will see it as null\n    T fromParams(Map<String, String> params);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamReaderBuilder.java."}, {"role": "assistant", "content": "The source code of java class QueryParamReaderBuilder.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.api.web.service.QueryParam;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.ZonedDateTime;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.internal.asm.Literal.variable;\n\n/**\n * @author neo\n */\nclass QueryParamReaderBuilder<T> {\n    private final String helper = type(QueryParamHelper.class);\n    private final Class<T> beanClass;\n    DynamicInstanceBuilder<QueryParamReader<T>> builder;\n\n    QueryParamReaderBuilder(Class<T> beanClass) {\n        this.beanClass = beanClass;\n    }\n\n    public QueryParamReader<T> build() {\n        builder = new DynamicInstanceBuilder<>(QueryParamReader.class, beanClass.getSimpleName());\n        builder.addMethod(fromParamsMethod());\n        return builder.build();\n    }\n\n    private String fromParamsMethod() {\n        String beanClassLiteral = type(beanClass);\n        CodeBuilder builder = new CodeBuilder().append(\"public Object fromParams(java.util.Map params) {\\n\");\n        builder.indent(1).append(\"{} bean = new {}();\\n\", beanClassLiteral, beanClassLiteral);\n\n        for (Field field : Classes.instanceFields(beanClass)) {\n            String fieldName = field.getName();\n            Class<?> fieldClass = field.getType();\n            String name = field.getDeclaredAnnotation(QueryParam.class).name();\n            builder.indent(1).append(\"String ${} = (String)params.get(\\\"{}\\\");\\n\", fieldName, name);\n            builder.indent(1).append(\"if (${} != null) {\\n\", fieldName);    // query param won't have null values, null means the key doesn't exist\n            if (String.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toString(${});\\n\", fieldName, helper, fieldName);\n            } else if (Integer.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toInt(${});\\n\", fieldName, helper, fieldName);\n            } else if (Long.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toLong(${});\\n\", fieldName, helper, fieldName);\n            } else if (Double.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toDouble(${});\\n\", fieldName, helper, fieldName);\n            } else if (BigDecimal.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toBigDecimal(${});\\n\", fieldName, helper, fieldName);\n            } else if (Boolean.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toBoolean(${});\\n\", fieldName, helper, fieldName);\n            } else if (LocalDateTime.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toDateTime(${});\\n\", fieldName, helper, fieldName);\n            } else if (LocalDate.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toDate(${});\\n\", fieldName, helper, fieldName);\n            } else if (LocalTime.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toTime(${});\\n\", fieldName, helper, fieldName);\n            } else if (ZonedDateTime.class.equals(fieldClass)) {\n                builder.indent(2).append(\"bean.{} = {}.toZonedDateTime(${});\\n\", fieldName, helper, fieldName);\n            } else if (fieldClass.isEnum()) {\n                builder.indent(2).append(\"bean.{} = ({}){}.toEnum(${}, {});\\n\", fieldName, type(fieldClass), helper, fieldName, variable(fieldClass));\n            }\n            builder.indent(1).append(\"}\\n\", name);\n        }\n\n        builder.indent(1).append(\"return bean;\\n\");\n        builder.append(\"}\");\n\n        return builder.build();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamWriter.java."}, {"role": "assistant", "content": "The source code of java class QueryParamWriter.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic interface QueryParamWriter<T> {\n    Map<String, String> toParams(T bean);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class QueryParamWriterBuilder.java."}, {"role": "assistant", "content": "The source code of java class QueryParamWriterBuilder.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.api.web.service.QueryParam;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Classes;\n\nimport java.lang.reflect.Field;\n\nimport static core.framework.internal.asm.Literal.type;\n\n/**\n * @author neo\n */\nclass QueryParamWriterBuilder<T> {\n    private final String helper = type(QueryParamHelper.class);\n    private final Class<T> beanClass;\n    DynamicInstanceBuilder<QueryParamWriter<T>> builder;\n\n    QueryParamWriterBuilder(Class<T> beanClass) {\n        this.beanClass = beanClass;\n    }\n\n    public QueryParamWriter<T> build() {\n        builder = new DynamicInstanceBuilder<>(QueryParamWriter.class, beanClass.getSimpleName());\n        builder.addMethod(toParamsMethod());\n        return builder.build();\n    }\n\n    private String toParamsMethod() {\n        CodeBuilder builder = new CodeBuilder().append(\"public java.util.Map toParams(Object value) {\\n\");\n        builder.indent(1).append(\"java.util.Map params = new java.util.HashMap();\\n\");\n        builder.indent(1).append(\"{} bean = ({})value;\\n\", type(beanClass), type(beanClass));\n\n        for (Field field : Classes.instanceFields(beanClass)) {\n            String fieldName = field.getName();\n            Class<?> fieldClass = field.getType();\n            String name = field.getDeclaredAnnotation(QueryParam.class).name();\n            if (String.class.equals(fieldClass)) {\n                builder.indent(1).append(\"params.put(\\\"{}\\\", bean.{});\\n\", name, fieldName);\n            } else {\n                builder.indent(1).append(\"params.put(\\\"{}\\\", {}.toString(bean.{}));\\n\", name, helper, fieldName);\n            }\n        }\n        builder.indent(1).append(\"return params;\\n\");\n        builder.append(\"}\");\n\n        return builder.build();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RequestBeanReader.java."}, {"role": "assistant", "content": "The source code of java class RequestBeanReader.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.api.web.service.QueryParam;\nimport core.framework.internal.bean.BeanClassNameValidator;\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.validate.Validator;\nimport core.framework.util.Maps;\nimport core.framework.web.exception.BadRequestException;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class RequestBeanReader {    // used by controller and web service\n    public static boolean isQueryParamBean(Class<?> beanClass) {\n        Field[] fields = beanClass.getDeclaredFields();\n        if (fields.length == 0) return false;\n        return fields[0].isAnnotationPresent(QueryParam.class);\n    }\n\n    private final Map<Class<?>, QueryParamContext<?>> queryParamContext = Maps.newHashMap();\n    private final Map<Class<?>, BeanContext<?>> beanContext = Maps.newHashMap();\n\n    public <T> void registerQueryParam(Class<T> beanClass, BeanClassNameValidator beanClassNameValidator) {\n        if (!queryParamContext.containsKey(beanClass)) {\n            new QueryParamClassValidator(beanClass, beanClassNameValidator).validate();\n            queryParamContext.put(beanClass, new QueryParamContext<>(beanClass));\n        }\n    }\n\n    public void registerBean(Class<?> beanClass, BeanClassValidator validator) {\n        if (!beanContext.containsKey(beanClass)) {\n            validator.validate(beanClass);\n            beanContext.put(beanClass, new BeanContext<>(beanClass));\n        }\n    }\n\n    public boolean containsQueryParam(Class<?> beanClass) {\n        return queryParamContext.containsKey(beanClass);\n    }\n\n    public boolean containsBean(Class<?> beanClass) {\n        return beanContext.containsKey(beanClass);\n    }\n\n    public <T> T fromParams(Class<T> beanClass, Map<String, String> params) {\n        QueryParamContext<T> context = context(queryParamContext, beanClass, true);\n        T bean = context.reader.fromParams(params);\n        context.validator.validate(bean, false);\n        return bean;\n    }\n\n    public <T> T fromJSON(Class<T> beanClass, byte[] body) throws IOException {\n        BeanContext<T> context = context(beanContext, beanClass, false);\n        T bean = context.reader.fromJSON(body);\n        context.validator.validate(bean, false);\n        return bean;\n    }\n\n    private <T> T context(Map<Class<?>, ?> context, Class<?> beanClass, boolean expectQueryParam) {\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) context.get(beanClass);\n        if (result == null) {\n            if (beanClass.getPackageName().startsWith(\"java\")) {   // provide better error message for developer, rather than return class is not registered message\n                throw new Error(\"bean class must not be java built-in class, class=\" + beanClass.getCanonicalName());\n            }\n            if (expectQueryParam != isQueryParamBean(beanClass)) {\n                throw new BadRequestException(\"content-type not supported, class=\" + beanClass.getCanonicalName());\n            }\n            throw new Error(\"bean class is not registered, please use http().bean() to register, class=\" + beanClass.getCanonicalName());\n        }\n        return result;\n    }\n\n    private static class QueryParamContext<T> {\n        final QueryParamReader<T> reader;\n        final Validator<T> validator;\n\n        QueryParamContext(Class<T> beanClass) {\n            reader = new QueryParamReaderBuilder<>(beanClass).build();\n            validator = Validator.of(beanClass);\n        }\n    }\n\n    private static class BeanContext<T> {\n        final JSONReader<T> reader;\n        final Validator<T> validator;\n\n        BeanContext(Class<T> beanClass) {\n            reader = JSONMapper.reader(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RequestBeanWriter.java."}, {"role": "assistant", "content": "The source code of java class RequestBeanWriter.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.internal.bean.BeanClassNameValidator;\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.Validator;\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class RequestBeanWriter {    // used by webservice client\n    private final Map<Class<?>, QueryParamContext<?>> queryParamContext = Maps.newHashMap();\n    private final Map<Class<?>, BeanContext<?>> beanContext = Maps.newHashMap();\n\n    public <T> void registerQueryParam(Class<T> beanClass, BeanClassNameValidator beanClassNameValidator) {\n        if (!queryParamContext.containsKey(beanClass)) {\n            new QueryParamClassValidator(beanClass, beanClassNameValidator).validate();\n            queryParamContext.put(beanClass, new QueryParamContext<>(beanClass));\n        }\n    }\n\n    public void registerBean(Class<?> beanClass, BeanClassValidator validator) {\n        if (!beanContext.containsKey(beanClass)) {\n            validator.validate(beanClass);\n            beanContext.put(beanClass, new BeanContext<>(beanClass));\n        }\n    }\n\n    public <T> Map<String, String> toParams(Class<T> beanClass, T bean) {\n        @SuppressWarnings(\"unchecked\")\n        QueryParamContext<T> context = (QueryParamContext<T>) queryParamContext.get(beanClass);     // query param is registered thru APIConfig\n        context.validator.validate(bean, false);\n        return context.writer.toParams(bean);\n    }\n\n    public <T> byte[] toJSON(Class<T> beanClass, T bean) {\n        @SuppressWarnings(\"unchecked\")\n        BeanContext<T> context = (BeanContext<T>) beanContext.get(beanClass);       // bean is registered thru APIConfig\n        context.validator.validate(bean, false);\n        return context.writer.toJSON(bean);\n    }\n\n    private static class QueryParamContext<T> {\n        final QueryParamWriter<T> writer;\n        final Validator<T> validator;\n\n        QueryParamContext(Class<T> beanClass) {\n            writer = new QueryParamWriterBuilder<>(beanClass).build();\n            validator = Validator.of(beanClass);\n        }\n    }\n\n    private static class BeanContext<T> {\n        final JSONWriter<T> writer;\n        final Validator<T> validator;\n\n        BeanContext(Class<T> beanClass) {\n            writer = JSONMapper.writer(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResponseBeanReader.java."}, {"role": "assistant", "content": "The source code of java class ResponseBeanReader.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.validate.Validator;\nimport core.framework.internal.web.service.InternalErrorResponse;\nimport core.framework.util.Maps;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic class ResponseBeanReader {   // used by webservice client\n    static Class<?> responseBeanClass(Type responseType) {\n        return GenericTypes.isOptional(responseType) ? GenericTypes.optionalValueClass(responseType) : GenericTypes.rawClass(responseType);\n    }\n\n    final Map<Class<?>, Context<?>> context = Maps.newHashMap();\n\n    public ResponseBeanReader() {\n        context.put(InternalErrorResponse.class, new Context<>(InternalErrorResponse.class));   // webservice client doesn't need ErrorResponse\n    }\n\n    public void register(Type responseType, BeanClassValidator validator) {\n        Class<?> beanClass = responseBeanClass(responseType);\n\n        if (!context.containsKey(beanClass)) {\n            validator.validate(beanClass);\n            context.put(beanClass, new Context<>(beanClass));\n        }\n    }\n\n    public Object fromJSON(Type responseType, byte[] body) throws IOException {\n        if (void.class == responseType) return null;\n\n        Class<?> beanClass = responseBeanClass(responseType);\n        @SuppressWarnings(\"unchecked\")\n        Context<Object> context = (Context<Object>) this.context.get(beanClass);    // response type is registered thru APIConfig\n        Object bean = context.reader.fromJSON(body);\n        if (GenericTypes.isOptional(responseType)) {\n            if (bean == null) return Optional.empty();\n            context.validator.validate(bean, false);\n            return Optional.of(bean);\n        } else {\n            context.validator.validate(bean, false);\n            return bean;\n        }\n    }\n\n    static class Context<T> {\n        final JSONReader<T> reader;\n        final Validator<T> validator;\n\n        Context(Class<T> beanClass) {\n            reader = JSONMapper.reader(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResponseBeanWriter.java."}, {"role": "assistant", "content": "The source code of java class ResponseBeanWriter.java:\n```java\npackage core.framework.internal.web.bean;\n\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.Validator;\nimport core.framework.internal.web.service.ErrorResponse;\nimport core.framework.internal.web.service.InternalErrorResponse;\nimport core.framework.util.Maps;\nimport core.framework.util.Strings;\n\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic class ResponseBeanWriter {   // used by controller and web service\n    private final Map<Class<?>, Context<?>> context = Maps.newHashMap();\n\n    public ResponseBeanWriter() {\n        context.put(InternalErrorResponse.class, new Context<>(InternalErrorResponse.class));\n        context.put(ErrorResponse.class, new Context<>(ErrorResponse.class));\n    }\n\n    public void register(Type responseType, BeanClassValidator validator) {\n        Class<?> beanClass = ResponseBeanReader.responseBeanClass(responseType);\n\n        if (!context.containsKey(beanClass)) {\n            validator.validate(beanClass);\n            context.put(beanClass, new Context<>(beanClass));\n        }\n    }\n\n    public boolean contains(Class<?> beanClass) {\n        return context.containsKey(beanClass);\n    }\n\n    public byte[] toJSON(Object bean) {\n        if (bean instanceof Optional<?> optional) {  // only support Optional<T> as response bean type\n            if (optional.isEmpty()) return Strings.bytes(\"null\");\n            Object value = optional.get();\n            Context<Object> context = context(this.context, value.getClass());\n            context.validator.validate(value, false);\n            return context.writer.toJSON(value);\n        } else {\n            Context<Object> context = context(this.context, bean.getClass());\n            context.validator.validate(bean, false);\n            return context.writer.toJSON(bean);\n        }\n    }\n\n    private <T> T context(Map<Class<?>, ?> context, Class<?> beanClass) {\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) context.get(beanClass);\n        if (result == null) {\n            if (beanClass.getPackageName().startsWith(\"java\")) {   // provide better error message for developer, rather than return class is not registered message\n                throw new Error(\"bean class must not be java built-in class, class=\" + beanClass.getCanonicalName());\n            }\n            throw new Error(\"bean class is not registered, please use http().bean() to register, class=\" + beanClass.getCanonicalName());\n        }\n        return result;\n    }\n\n    private static class Context<T> {\n        final JSONWriter<T> writer;\n        final Validator<T> validator;\n\n        Context(Class<T> beanClass) {\n            writer = JSONMapper.writer(beanClass);\n            validator = Validator.of(beanClass);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ControllerClassValidator.java."}, {"role": "assistant", "content": "The source code of java class ControllerClassValidator.java:\n```java\npackage core.framework.internal.web.controller;\n\nimport core.framework.internal.reflect.Methods;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n/**\n * @author neo\n */\npublic class ControllerClassValidator {\n    private final Class<?> controllerClass;\n    private final Method controllerMethod;\n\n    public ControllerClassValidator(Class<?> controllerClass, Method controllerMethod) {\n        this.controllerClass = controllerClass;\n        this.controllerMethod = controllerMethod;\n    }\n\n    public void validate() {\n        if (!Object.class.equals(controllerClass.getSuperclass())) {\n            throw new Error(\"controller class must not have super class, class=\" + controllerClass.getCanonicalName());\n        }\n        if (!Modifier.isPublic(controllerMethod.getModifiers())) {\n            throw new Error(\"controller method must be public, method=\" + Methods.path(controllerMethod));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ControllerHolder.java."}, {"role": "assistant", "content": "The source code of java class ControllerHolder.java:\n```java\npackage core.framework.internal.web.controller;\n\nimport core.framework.internal.log.PerformanceWarning;\nimport core.framework.internal.log.WarningContext;\nimport core.framework.log.IOWarning;\nimport core.framework.web.Controller;\n\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Method;\n\n/**\n * @author neo\n */\npublic class ControllerHolder {\n    public final String controllerInfo;\n    public final Controller controller;\n    public final String action;\n    @Nullable\n    public final PerformanceWarning[] warnings;\n\n    final Method targetMethod;      // targetMethod is used to find associated annotation\n    final boolean skipInterceptor;\n\n    public ControllerHolder(Controller controller, Method targetMethod, String controllerInfo, String action, boolean skipInterceptor) {\n        this.controller = controller;\n        this.targetMethod = targetMethod;\n        this.controllerInfo = controllerInfo;\n        this.action = action;\n        this.skipInterceptor = skipInterceptor;\n\n        if (skipInterceptor) {  // skip warning for all internal controllers which skipInterceptor = true\n            warnings = null;\n        } else {\n            warnings = WarningContext.warnings(targetMethod.getDeclaredAnnotationsByType(IOWarning.class));\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ControllerInspector.java."}, {"role": "assistant", "content": "The source code of java class ControllerInspector.java:\n```java\npackage core.framework.internal.web.controller;\n\nimport core.framework.module.LambdaController;\nimport core.framework.web.Controller;\nimport core.framework.web.Request;\n\nimport java.lang.invoke.SerializedLambda;\nimport java.lang.reflect.Method;\n\n/**\n * due to Java 9+ doesn't provide normal way to reflect lambda method reference, here to use hack to retrieve referred method\n *\n * @author neo\n */\npublic class ControllerInspector {\n    public final Class<?> targetClass;\n    public final Method targetMethod;\n    public final String controllerInfo;\n\n    public ControllerInspector(Controller controller) {\n        Class<?> controllerClass = controller.getClass();\n\n        try {\n            if (controller instanceof LambdaController) {\n                Method writeReplace = controllerClass.getDeclaredMethod(\"writeReplace\");\n                if (!writeReplace.trySetAccessible()) {\n                    throw new Error(\"failed to inspect controller, cannot access writeReplace\");\n                }\n                SerializedLambda lambda = (SerializedLambda) writeReplace.invoke(controller);\n                Class<?> targetClass = Class.forName(lambda.getImplClass().replace('/', '.'));\n                String targetMethodName = lambda.getImplMethodName();\n                controllerInfo = targetClass.getCanonicalName() + \".\" + targetMethodName;\n                if (targetMethodName.contains(\"$\")) {   // for lambda\n                    this.targetClass = controllerClass;\n                    targetMethod = controllerClass.getMethod(\"execute\", Request.class);\n                } else {    // for method reference\n                    this.targetClass = targetClass;\n                    targetMethod = targetClass.getDeclaredMethod(targetMethodName, Request.class);\n                }\n            } else {\n                targetClass = controllerClass;\n                targetMethod = controllerClass.getMethod(\"execute\", Request.class);\n                controllerInfo = controllerClass.getCanonicalName() + \".execute\";\n            }\n        } catch (ReflectiveOperationException e) {\n            throw new Error(\"failed to inspect controller\", e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InvocationImpl.java."}, {"role": "assistant", "content": "The source code of java class InvocationImpl.java:\n```java\npackage core.framework.internal.web.controller;\n\nimport core.framework.web.Interceptor;\nimport core.framework.web.Invocation;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport core.framework.web.WebContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\n/**\n * @author neo\n */\npublic final class InvocationImpl implements Invocation {\n    private final Logger logger = LoggerFactory.getLogger(InvocationImpl.class);\n\n    private final ControllerHolder controller;\n    private final Interceptor[] interceptors;\n    private final Request request;\n    private final WebContextImpl context;\n    private int currentStack;\n\n    public InvocationImpl(ControllerHolder controller, Interceptor[] interceptors, Request request, WebContextImpl context) {\n        this.controller = controller;\n        this.interceptors = interceptors;\n        this.request = request;\n        this.context = context;\n    }\n\n    @Override\n    public <T extends Annotation> T annotation(Class<T> annotationClass) {\n        Method controllerMethod = controller.targetMethod;\n        T annotation = controllerMethod.getDeclaredAnnotation(annotationClass);\n        if (annotation == null)\n            annotation = controllerMethod.getDeclaringClass().getDeclaredAnnotation(annotationClass);\n        return annotation;\n    }\n\n    @Override\n    public WebContext context() {\n        return context;\n    }\n\n    @Override\n    public Response proceed() throws Exception {\n        if (controller.skipInterceptor || currentStack >= interceptors.length) {\n            logger.debug(\"execute controller, controller={}\", controller.controllerInfo);\n            Response response = controller.controller.execute(request);\n            if (response == null) throw new Error(\"controller must not return null response, controller=\" + controller.controllerInfo);\n            return response;\n        } else {\n            Interceptor interceptor = interceptors[currentStack];\n            currentStack++;\n            logger.debug(\"intercept, interceptorClass={}\", interceptor.getClass().getCanonicalName());\n            Response response = interceptor.intercept(this);\n            if (response == null) throw new Error(\"interceptor must not return null response, interceptor=\" + interceptor.getClass().getCanonicalName());\n            return response;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebContextImpl.java."}, {"role": "assistant", "content": "The source code of java class WebContextImpl.java:\n```java\npackage core.framework.internal.web.controller;\n\nimport core.framework.web.CookieSpec;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport core.framework.web.WebContext;\n\nimport javax.annotation.Nullable;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class WebContextImpl implements WebContext {\n    private static final ThreadLocal<Context> CONTEXT = new ThreadLocal<>();\n\n    @Override\n    public Object get(String key) {\n        Context context = CONTEXT.get();\n        if (context.context == null) return null;\n        return context.context.get(key);\n    }\n\n    @Override\n    public void put(String key, Object value) {\n        Context context = CONTEXT.get();\n        if (context.context == null) context.context = new HashMap<>();\n        context.context.put(key, value);\n    }\n\n    @Override\n    public Request request() {\n        return CONTEXT.get().request;\n    }\n\n    @Override\n    public void responseCookie(CookieSpec spec, @Nullable String value) {\n        Context context = CONTEXT.get();\n        if (context.responseCookies == null) context.responseCookies = new HashMap<>();\n        context.responseCookies.put(spec, value);\n    }\n\n    public void initialize(Request request) {\n        CONTEXT.set(new Context(request));\n    }\n\n    public void handleResponse(Response response) {\n        Context context = CONTEXT.get();\n        if (context.responseCookies != null) {\n            for (Map.Entry<CookieSpec, String> entry : context.responseCookies.entrySet()) {\n                response.cookie(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    public void cleanup() {\n        CONTEXT.remove();\n    }\n\n    static class Context {\n        final Request request;\n        Map<String, Object> context;\n        Map<CookieSpec, String> responseCookies;\n\n        Context(Request request) {\n            this.request = request;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class GZipPredicate.java."}, {"role": "assistant", "content": "The source code of java class GZipPredicate.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.http.ContentType;\nimport io.undertow.predicate.Predicate;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class GZipPredicate implements Predicate {\n    // from test, roughly the compressed value becomes smaller after text larger than 100B,\n    // by considering gzip cpu/ram overhead, use 200B as threshold\n    private static final int MIN_GZIP_LENGTH = 200;\n    private final Set<String> gzipContentTypes = Set.of(ContentType.TEXT_PLAIN.toString(),\n            ContentType.TEXT_HTML.toString(),\n            ContentType.TEXT_CSS.toString(),\n            ContentType.TEXT_XML.toString(),\n            ContentType.APPLICATION_JSON.toString(),\n            ContentType.APPLICATION_JAVASCRIPT.toString());\n\n    @Override\n    public boolean resolve(HttpServerExchange exchange) {\n        HeaderMap headers = exchange.getResponseHeaders();\n        return resolve(headers);\n    }\n\n    boolean resolve(HeaderMap headers) {\n        String contentType = headers.getFirst(Headers.CONTENT_TYPE);\n        if (contentType == null || !gzipContentTypes.contains(contentType)) return false;\n        String length = headers.getFirst(Headers.CONTENT_LENGTH);\n        return length == null || Long.parseLong(length) > MIN_GZIP_LENGTH;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class IPv4AccessControl.java."}, {"role": "assistant", "content": "The source code of java class IPv4AccessControl.java:\n```java\npackage core.framework.internal.web.http;\n\nimport core.framework.web.exception.ForbiddenException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * @author neo\n */\npublic class IPv4AccessControl {\n    private final Logger logger = LoggerFactory.getLogger(IPv4AccessControl.class);\n    public IPv4Ranges allow;\n    public IPv4Ranges deny;\n\n    public void validate(String clientIP) {\n        try {\n            InetAddress address = InetAddress.getByName(clientIP);\n            if (isLocal(address)) {\n                logger.debug(\"allow site local client address\");\n                return;\n            }\n\n            if (!allow(address.getAddress())) {\n                throw new ForbiddenException(\"access denied\", \"IP_ACCESS_DENIED\");\n            }\n        } catch (UnknownHostException e) {\n            throw new Error(e);  // client ip format is already validated in ClientIPParser, so here it won't resolve DNS\n        }\n    }\n\n    boolean isLocal(InetAddress address) {\n        return address.isLoopbackAddress() || address.isSiteLocalAddress();\n    }\n\n    boolean allow(byte[] address) {\n        if (address.length > 4) {   // only support ipv4, as Cloud LB generally uses ipv4 endpoint (gcloud supports both ipv4/v6, but ipv6 is not majority yet)\n            logger.debug(\"skip with ipv6 client address\");\n            return true;\n        }\n\n        if (allow != null && allow.matches(address)) {\n            logger.debug(\"allow client ip within allowed ranges\");\n            return true;\n        }\n\n        if (deny == null || deny.matches(address)) {    // if deny == null, it blocks all\n            logger.debug(\"deny client ip within denied ranges\");\n            return false;\n        }\n\n        logger.debug(\"allow client ip not within denied ranges\");\n        return true;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class IPv4Ranges.java."}, {"role": "assistant", "content": "The source code of java class IPv4Ranges.java:\n```java\npackage core.framework.internal.web.http;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class IPv4Ranges {\n    static byte[] address(String address) {\n        try {\n            return InetAddress.getByName(address).getAddress();\n        } catch (UnknownHostException e) {\n            throw new Error(e);\n        }\n    }\n\n    static boolean withinRanges(int[] ranges, int value) {\n        int low = 0;\n        int high = ranges.length - 1;\n        if (value < ranges[low] || value > ranges[high]) return false;\n\n        while (high - low > 1) {\n            int middle = (low + high) >>> 1;\n            long middleValue = ranges[middle];\n\n            if (middleValue < value)\n                low = middle;\n            else if (middleValue > value)\n                high = middle;\n            else {\n                return true;\n            }\n        }\n        return low % 2 == 0;\n    }\n\n    static int[] mergeRanges(int[][] ranges) {\n        int index;\n        Arrays.sort(ranges, Comparator.comparingInt(range -> range[0]));\n        int[] results = new int[ranges.length * 2];\n        index = 0;\n        for (int[] range : ranges) {\n            if (index > 1 && results[index - 1] >= range[0]) {\n                if (results[index - 1] < range[1]) {\n                    results[index - 1] = range[1];\n                }\n            } else {\n                results[index++] = range[0];\n                results[index++] = range[1];\n            }\n        }\n        if (index < results.length) {\n            return Arrays.copyOf(results, index);\n        } else {\n            return results;\n        }\n    }\n\n    private final int[] ranges;\n\n    public IPv4Ranges(List<String> cidrs) {\n        int[][] ranges = new int[cidrs.size()][];\n        int index = 0;\n        for (String cidr : cidrs) {\n            int[] range = comparableIPRanges(cidr);\n            ranges[index++] = range;\n        }\n        this.ranges = mergeRanges(ranges);\n    }\n\n    private int[] comparableIPRanges(String cidr) {\n        int index = cidr.indexOf('/');\n        if (index <= 0 || index >= cidr.length() - 1) throw new Error(\"invalid cidr, value=\" + cidr);\n        int address = toInteger(address(cidr.substring(0, index)));\n        int maskBits = Integer.parseInt(cidr.substring(index + 1));\n        long mask = -1L << (32 - maskBits);\n        int lowestIP = (int) (address & mask);\n        int highestIP = (int) (lowestIP + ~mask);\n        return new int[]{lowestIP ^ Integer.MIN_VALUE, highestIP ^ Integer.MIN_VALUE};\n    }\n\n    private int toInteger(byte[] address) {\n        if (address.length > 4) throw new Error(\"only support ipv4, address=\" + Arrays.toString(address));\n        int result = 0;\n        result |= (address[0] & 0xFF) << 24;\n        result |= (address[1] & 0xFF) << 16;\n        result |= (address[2] & 0xFF) << 8;\n        result |= address[3] & 0xFF;\n        return result;\n    }\n\n    /*\n     * with address ^ Integer.MIN_VALUE, it converts binary presentation to sortable int form\n     * where Integer.MIN_VALUE = 0.0.0.0\n     * and 0 = 128.0.0.0\n     * and Integer.MAX_VALUE = 255.255.255.255\n     * */\n    public boolean matches(byte[] address) {\n        if (ranges.length == 0) return false;\n        int comparableIP = toInteger(address) ^ Integer.MIN_VALUE;\n        return withinRanges(ranges, comparableIP);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LimitRateInterceptor.java."}, {"role": "assistant", "content": "The source code of java class LimitRateInterceptor.java:\n```java\npackage core.framework.internal.web.http;\n\nimport core.framework.web.Interceptor;\nimport core.framework.web.Invocation;\nimport core.framework.web.Response;\nimport core.framework.web.rate.LimitRate;\n\n/**\n * @author neo\n */\npublic class LimitRateInterceptor implements Interceptor {\n    private final RateControl rateControl;\n\n    public LimitRateInterceptor(RateControl rateControl) {\n        this.rateControl = rateControl;\n    }\n\n    @Override\n    public Response intercept(Invocation invocation) throws Exception {\n        LimitRate limitRate = invocation.annotation(LimitRate.class);\n        if (limitRate != null) {\n            String group = limitRate.value();\n            String clientIP = invocation.context().request().clientIP();\n            rateControl.validateRate(group, clientIP);\n        }\n        return invocation.proceed();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RateControl.java."}, {"role": "assistant", "content": "The source code of java class RateControl.java:\n```java\npackage core.framework.internal.web.http;\n\nimport core.framework.internal.util.LRUMap;\nimport core.framework.util.Maps;\nimport core.framework.web.exception.TooManyRequestsException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class RateControl {\n    private final Logger logger = LoggerFactory.getLogger(RateControl.class);\n\n    private Map<String, RateConfig> config;\n    private Map<String, Rate> rates;\n\n    public void maxEntries(int entries) {\n        synchronized (this) {\n            rates = new LRUMap<>(entries);\n        }\n    }\n\n    // config is always called during initialization, so no concurrency issue\n    public void config(String group, int maxPermits, int fillRate, Duration interval) {\n        if (config == null) config = Maps.newHashMap();\n        double fillRatePerNano = ratePerNano(fillRate, interval);\n        RateConfig previous = config.put(group, new RateConfig(maxPermits, fillRatePerNano));\n        if (previous != null) throw new Error(\"found duplicate group, group=\" + group);\n    }\n\n    public void validateRate(String group, String clientIP) {\n        logger.debug(\"acquire, group={}, clientIP={}\", group, clientIP);\n        boolean acquired = acquire(group, clientIP);\n        if (!acquired) {\n            throw new TooManyRequestsException(\"rate exceeded\");\n        }\n    }\n\n    public boolean hasGroup(String group) {\n        return config != null && config.containsKey(group);\n    }\n\n    double ratePerNano(int rate, Duration interval) {\n        return rate / (double) interval.toNanos();\n    }\n\n    boolean acquire(String group, String clientIP) {\n        RateConfig config = this.config.get(group);\n\n        if (config == null) {\n            logger.warn(\"can not find group, group={}\", group);\n            return true;    // skip if group is not defined\n        }\n\n        String key = group + \"/\" + clientIP;\n        Rate rate;\n        synchronized (this) {\n            rate = rates.computeIfAbsent(key, k -> new Rate(config.maxPermits));\n        }\n        long currentTime = System.nanoTime();\n        return rate.acquire(currentTime, config.maxPermits, config.fillRatePerNano);\n    }\n\n    record RateConfig(int maxPermits, double fillRatePerNano) {\n    }\n\n    static final class Rate {\n        volatile double currentPermits;\n        volatile long lastUpdateTime;\n\n        Rate(int currentPermits) {\n            this.currentPermits = currentPermits;\n            this.lastUpdateTime = System.nanoTime();\n        }\n\n        // under multi-thread condition, the order of acquires are not determined, currentTime can be earlier than lastUpdateTime (e.g. lastUpdateTime was updated by a later acquire first)\n        boolean acquire(long currentTime, int maxPermits, double fillRatePerNano) {\n            synchronized (this) {\n                long timeElapsed = Math.max(0, currentTime - lastUpdateTime);\n                currentPermits = Math.min(maxPermits, currentPermits + fillRatePerNano * timeElapsed);\n                lastUpdateTime = lastUpdateTime + timeElapsed;\n\n                if (currentPermits >= 1) {\n                    currentPermits -= 1;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPErrorHandler.java."}, {"role": "assistant", "content": "The source code of java class HTTPErrorHandler.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.http.ContentType;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.web.request.RequestImpl;\nimport core.framework.internal.web.response.ResponseHandler;\nimport core.framework.internal.web.response.ResponseImpl;\nimport core.framework.internal.web.service.ErrorResponse;\nimport core.framework.internal.web.service.InternalErrorResponse;\nimport core.framework.internal.web.service.WebServiceClient;\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\nimport core.framework.util.Exceptions;\nimport core.framework.web.ErrorHandler;\nimport core.framework.web.Response;\nimport core.framework.web.service.RemoteServiceException;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class HTTPErrorHandler {\n    private final Logger logger = LoggerFactory.getLogger(HTTPErrorHandler.class);\n    private final ResponseHandler responseHandler;\n    public ErrorHandler customErrorHandler;\n\n    HTTPErrorHandler(ResponseHandler responseHandler) {\n        this.responseHandler = responseHandler;\n    }\n\n    void handleError(Throwable e, HttpServerExchange exchange, RequestImpl request, ActionLog actionLog) {\n        if (exchange.isResponseStarted()) {\n            logger.error(\"response was sent, discard the current http transaction\");\n            return;\n        }\n\n        try {\n            Response errorResponse = null;\n            if (customErrorHandler != null) errorResponse = customErrorHandler.handle(request, e).orElse(null);\n            if (errorResponse == null) errorResponse = defaultErrorResponse(e, exchange, actionLog);\n            responseHandler.render(request, (ResponseImpl) errorResponse, exchange, actionLog);\n        } catch (Throwable error) {\n            logger.error(error.getMessage(), error);\n            if (exchange.isResponseStarted()) {\n                logger.error(\"failed to render error page, response was sent, discard the current http transaction\");\n                return;\n            }\n            renderDefaultErrorPage(error, exchange, actionLog);\n        }\n    }\n\n    private Response defaultErrorResponse(Throwable e, HttpServerExchange exchange, ActionLog actionLog) {\n        HTTPStatus status = httpStatus(e);\n\n        HeaderMap headers = exchange.getRequestHeaders();\n        String accept = headers.getFirst(Headers.ACCEPT);\n\n        if (accept != null && accept.contains(ContentType.APPLICATION_JSON.mediaType)) {\n            String userAgent = headers.getFirst(Headers.USER_AGENT);\n            return Response.bean(errorResponse(e, userAgent, actionLog.id)).status(status);\n        } else {\n            return Response.text(errorHTML(e, actionLog.id)).status(status).contentType(ContentType.TEXT_HTML);\n        }\n    }\n\n    Object errorResponse(Throwable e, String userAgent, String actionId) {\n        if (WebServiceClient.USER_AGENT.equals(userAgent)) {\n            var response = new InternalErrorResponse();\n            response.id = actionId;\n            response.message = e.getMessage();\n            response.stackTrace = Exceptions.stackTrace(e);\n            if (e instanceof ErrorCode errorCode) {\n                response.errorCode = errorCode.errorCode();\n                response.severity = errorCode.severity().name();\n            } else {\n                // internally LogManager logs exception class name as error code if not impl ErrorCode,\n                // here it uses INTERNAL_ERROR as it's border of internal, we don't want to expose internal details (exception class) to external which is part of api contract\n                response.errorCode = \"INTERNAL_ERROR\";\n                response.severity = Severity.ERROR.name();\n            }\n            return response;\n        } else {\n            var response = new ErrorResponse();\n            response.id = actionId;\n            response.message = e.getMessage();\n            if (e instanceof ErrorCode errorCode) {\n                response.errorCode = errorCode.errorCode();\n            } else {\n                response.errorCode = \"INTERNAL_ERROR\";\n            }\n            return response;\n        }\n    }\n\n    HTTPStatus httpStatus(Throwable e) {\n        ResponseStatus responseStatus = e.getClass().getDeclaredAnnotation(ResponseStatus.class);\n        if (responseStatus != null) return responseStatus.value();\n        if (e instanceof RemoteServiceException remoteServiceException) return remoteServiceException.status;    // propagate underlying status code for REST convention\n        return HTTPStatus.INTERNAL_SERVER_ERROR;\n    }\n\n    String errorHTML(Throwable e, String actionId) {\n        String errorCode = e instanceof ErrorCode code ? code.errorCode() : \"ERROR\";\n        return \"<html><body><h1>\" + errorCode + \"</h1><p>\" + e.getMessage() + \"</p><p>id: \" + actionId + \"</p></body></html>\";\n    }\n\n    private void renderDefaultErrorPage(Throwable e, HttpServerExchange exchange, ActionLog actionLog) {\n        exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ContentType.TEXT_HTML.toString());\n        exchange.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR.code);\n        actionLog.context.put(\"response_code\", List.of(String.valueOf(HTTPStatus.INTERNAL_SERVER_ERROR.code)));\n        logger.debug(\"[response] statusCode={}\", HTTPStatus.INTERNAL_SERVER_ERROR.code);\n        exchange.getResponseSender().send(errorHTML(e, actionLog.id));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPHandler.java."}, {"role": "assistant", "content": "The source code of java class HTTPHandler.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.async.ThreadPools;\nimport core.framework.internal.async.VirtualThread;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport core.framework.internal.web.bean.RequestBeanReader;\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.internal.web.controller.InvocationImpl;\nimport core.framework.internal.web.controller.WebContextImpl;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.internal.web.http.RateControl;\nimport core.framework.internal.web.request.RequestImpl;\nimport core.framework.internal.web.request.RequestParser;\nimport core.framework.internal.web.response.ResponseHandler;\nimport core.framework.internal.web.response.ResponseImpl;\nimport core.framework.internal.web.route.Route;\nimport core.framework.internal.web.session.SessionManager;\nimport core.framework.internal.web.site.TemplateManager;\nimport core.framework.internal.web.websocket.WebSocketHandler;\nimport core.framework.module.WebSocketConfig;\nimport core.framework.web.Interceptor;\nimport core.framework.web.Response;\nimport io.undertow.server.HttpHandler;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\nimport io.undertow.util.HttpString;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Semaphore;\n\n/**\n * @author neo\n */\npublic class HTTPHandler implements HttpHandler {\n    public static final HttpString HEADER_CORRELATION_ID = new HttpString(\"correlation-id\");\n    public static final HttpString HEADER_CLIENT = new HttpString(\"client\");\n    public static final HttpString HEADER_REF_ID = new HttpString(\"ref-id\");\n    public static final HttpString HEADER_TRACE = new HttpString(\"trace\");\n    public static final HttpString HEADER_TIMEOUT = new HttpString(\"timeout\");      // there is ietf draft to define Request-Timeout header, but didn't move on, so here to use shorter name\n\n    public final RequestParser requestParser = new RequestParser();\n    public final Route route = new Route();\n    public final WebContextImpl webContext = new WebContextImpl();\n    public final HTTPErrorHandler errorHandler;\n\n    public final RequestBeanReader requestBeanReader = new RequestBeanReader();\n    public final ResponseBeanWriter responseBeanWriter = new ResponseBeanWriter();\n\n    public final RateControl rateControl = new RateControl();\n    final ExecutorService worker = ThreadPools.virtualThreadExecutor(\"http-handler-\");\n\n    private final Logger logger = LoggerFactory.getLogger(HTTPHandler.class);\n    private final LogManager logManager;\n    private final SessionManager sessionManager;\n    private final ResponseHandler responseHandler;\n    private final Semaphore semaphore = new Semaphore(Runtime.getRuntime().availableProcessors() * 32);\n\n    public Interceptor[] interceptors;\n    public WebSocketHandler webSocketHandler;\n    public IPv4AccessControl accessControl;\n    public long maxProcessTimeInNano = Duration.ofSeconds(30).toNanos();    // the default backend timeout of popular cloud lb (gcloud/azure) is 30s\n\n    HTTPHandler(LogManager logManager, SessionManager sessionManager, TemplateManager templateManager) {\n        this.logManager = logManager;\n        this.sessionManager = sessionManager;\n        responseHandler = new ResponseHandler(responseBeanWriter, templateManager, sessionManager);\n        errorHandler = new HTTPErrorHandler(responseHandler);\n    }\n\n    @Override\n    public void handleRequest(HttpServerExchange exchange) {\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(worker, this);  // in io handler form parser will dispatch to current io thread\n            return;\n        }\n\n        handle(exchange);\n    }\n\n    private void handle(HttpServerExchange exchange) {\n        semaphore.acquireUninterruptibly();\n        VirtualThread.COUNT.increase();\n        long httpDelay = System.nanoTime() - exchange.getRequestStartTime();\n        ActionLog actionLog = logManager.begin(\"=== http transaction begin ===\", null);\n        var request = new RequestImpl(exchange, requestBeanReader);\n        try {\n            webContext.initialize(request);\n\n            logger.debug(\"httpDelay={}\", httpDelay);    // http delay includes request body parsing time, it could be long if client sent post body slowly, and it is usually low, so not to use Duration format\n            actionLog.stats.put(\"http_delay\", (double) httpDelay);\n\n            requestParser.parse(request, exchange, actionLog);\n\n            if (accessControl != null) accessControl.validate(request.clientIP());  // check ip before checking routing/web socket, return 403 asap\n\n            HeaderMap headers = exchange.getRequestHeaders();\n            linkContext(actionLog, headers);\n\n            if (webSocketHandler != null && webSocketHandler.checkWebSocket(request.method(), headers)) {\n                rateControl.validateRate(WebSocketConfig.WS_OPEN_GROUP, request.clientIP());\n                webSocketHandler.handle(exchange, request, actionLog);\n                return; // with WebSocket, not save session\n            }\n\n            ControllerHolder controller = route.get(request.path(), request.method(), request.pathParams, actionLog);\n            actionLog.action(controller.action);\n            actionLog.context.put(\"controller\", List.of(controller.controllerInfo));\n            logger.debug(\"controller={}\", controller.controllerInfo);\n            if (controller.warnings != null) actionLog.initializeWarnings(controller.warnings);\n\n            request.session = sessionManager.load(request, actionLog);  // load session as late as possible, so for sniffer/scan request with sessionId, it won't call redis every time even for 404/405\n\n            Response response = new InvocationImpl(controller, interceptors, request, webContext).proceed();\n            webContext.handleResponse(response);\n\n            addKeepAliveHeader(exchange);\n            responseHandler.render(request, (ResponseImpl) response, exchange, actionLog);\n        } catch (Throwable e) {\n            logManager.logError(e);\n            errorHandler.handleError(e, exchange, request, actionLog);\n        } finally {\n            // refer to io.undertow.io.AsyncSenderImpl.send(java.nio.ByteBuffer, io.undertow.io.IoCallback),\n            // sender.send() will write response until can't write more, then call channel.resumeWrites(), which will resume after this finally block finished, so this can be small delay\n            webContext.cleanup();\n            logManager.end(\"=== http transaction end ===\");\n            VirtualThread.COUNT.decrease();\n            semaphore.release();\n        }\n    }\n\n    void addKeepAliveHeader(HttpServerExchange exchange) {\n        String keepAlive = Headers.KEEP_ALIVE.toString();\n        if (keepAlive.equals(exchange.getRequestHeaders().getFirst(Headers.CONNECTION))) {\n            exchange.getResponseHeaders().put(Headers.CONNECTION, keepAlive);\n        }\n    }\n\n    void linkContext(ActionLog actionLog, HeaderMap headers) {\n        String client = headers.getFirst(HEADER_CLIENT);\n        if (client != null) actionLog.clients = List.of(client);\n\n        String refId = headers.getFirst(HEADER_REF_ID);\n        if (refId != null) actionLog.refIds = List.of(refId);\n\n        String correlationId = headers.getFirst(HEADER_CORRELATION_ID);\n        if (correlationId != null) actionLog.correlationIds = List.of(correlationId);\n\n        String trace = headers.getFirst(HEADER_TRACE);\n        if (trace != null) actionLog.trace = Trace.parse(trace);\n\n        actionLog.warningContext.maxProcessTimeInNano(maxProcessTime(headers.getFirst(HEADER_TIMEOUT)));\n    }\n\n    long maxProcessTime(String timeout) {\n        if (timeout != null) {\n            try {\n                return Long.parseLong(timeout);\n            } catch (NumberFormatException e) {\n                // ignore if got invalid timeout header from internet\n                return maxProcessTimeInNano;\n            }\n        }\n        return maxProcessTimeInNano;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPHost.java."}, {"role": "assistant", "content": "The source code of java class HTTPHost.java:\n```java\npackage core.framework.internal.web;\n\n/**\n * @author neo\n */\npublic record HTTPHost(String host, int port) {\n    public static HTTPHost parse(String value) {\n        int index = value.indexOf(':');\n        if (index > 0) return new HTTPHost(value.substring(0, index), Integer.parseInt(value.substring(index + 1)));\n        return new HTTPHost(\"0.0.0.0\", Integer.parseInt(value));\n    }\n\n    @Override\n    public String toString() {\n        return host + \":\" + port;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPIOHandler.java."}, {"role": "assistant", "content": "The source code of java class HTTPIOHandler.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.web.request.RequestBodyReader;\nimport io.undertow.server.HttpHandler;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.server.handlers.form.FormDataParser;\nimport io.undertow.server.handlers.form.FormParserFactory;\nimport io.undertow.util.HttpString;\nimport io.undertow.util.Methods;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xnio.channels.StreamSourceChannel;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic class HTTPIOHandler implements HttpHandler {\n    public static final String HEALTH_CHECK_PATH = \"/health-check\";\n    private final Logger logger = LoggerFactory.getLogger(HTTPIOHandler.class);\n    private final FormParserFactory formParserFactory;\n    private final HTTPHandler handler;\n    private final ShutdownHandler shutdownHandler;\n    private final long maxEntitySize;\n\n    HTTPIOHandler(HTTPHandler handler, ShutdownHandler shutdownHandler, long maxEntitySize) {\n        this.handler = handler;\n        this.shutdownHandler = shutdownHandler;\n        this.maxEntitySize = maxEntitySize;\n        var builder = FormParserFactory.builder();\n        builder.setDefaultCharset(UTF_8.name());\n        formParserFactory = builder.build();\n    }\n\n    @Override\n    public void handleRequest(HttpServerExchange exchange) throws Exception {\n        if (HEALTH_CHECK_PATH.equals(exchange.getRequestPath())) {      // not treat health-check as action\n            handler.addKeepAliveHeader(exchange);\n            exchange.endExchange(); // end exchange will send 200 / content-length=0\n            return;\n        }\n\n        long contentLength = exchange.getRequestContentLength();\n        if (!checkContentLength(contentLength, exchange)) return;\n\n        boolean shutdown = shutdownHandler.handle(exchange);\n        if (shutdown) return;\n\n        if (hasBody(contentLength, exchange.getRequestMethod())) {    // parse body early, not process until body is read (e.g. for chunked), to save one blocking thread during read\n            FormDataParser parser = formParserFactory.createParser(exchange);   // no need to close, refer to io.undertow.server.handlers.form.MultiPartParserDefinition.create, it closes on ExchangeCompletionListener\n            if (parser != null) {\n                parser.parse(handler);\n                return;\n            }\n\n            var reader = new RequestBodyReader(exchange, handler);\n            StreamSourceChannel channel = exchange.getRequestChannel();\n            reader.read(channel);  // channel will be null if getRequestChannel() is already called, but here should not be that case\n            if (!reader.complete()) {\n                channel.getReadSetter().set(reader);\n                channel.resumeReads();\n                return;\n            }\n        }\n\n        exchange.dispatch(handler.worker, handler);\n    }\n\n    // undertow is not handling max entity size checking correctly, it terminates request directly and bypass exchange.endExchange() in certain cases, and log errors in debug level\n    // thus ExchangeCompleteListener will not be triggered, and cause problem on graceful shutdown\n    // for http/1.1, refer to io.undertow.conduits.FixedLengthStreamSourceConduit.checkMaxSize,\n    //      io.undertow.server.handlers.form.MultiPartParserDefinition.MultiPartUploadHandler.NonBlockingParseTask\n    // for http/2.0, refer to io.undertow.server.protocol.framed.AbstractFramedStreamSourceChannel.handleStreamTooLarge\n    //\n    // here to mitigate the issue by checking content length before shutdown handler\n    //\n    // for H2 and \"Transfer-Encoding: chunked\", there is no easy way to handle graceful shutdown correctly, this is flaw of current undertow h2 implementation\n    boolean checkContentLength(long contentLength, HttpServerExchange exchange) {\n        if (contentLength > maxEntitySize) {\n            logger.warn(\"content length is too large, requestURL={}, contentLength={}, maxEntitySize={}\", exchange.getRequestURL(), contentLength, maxEntitySize);\n            exchange.setStatusCode(413);    // 413 Payload Too Large (RFC 7231), it doesn't matter as undertow terminates connection, and browser will see protocol error\n            exchange.endExchange();\n            return false;\n        }\n        return true;\n    }\n\n    boolean hasBody(long contentLength, HttpString method) {\n        if (contentLength == 0) return false;  // if body is empty, skip reading\n        return Methods.POST.equals(method) || Methods.PUT.equals(method) || Methods.PATCH.equals(method);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPServer.java."}, {"role": "assistant", "content": "The source code of java class HTTPServer.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.web.site.SiteManager;\nimport core.framework.util.StopWatch;\nimport core.framework.web.Interceptor;\nimport io.undertow.Undertow;\nimport io.undertow.UndertowOptions;\nimport io.undertow.server.HttpHandler;\nimport io.undertow.server.handlers.encoding.ContentEncodingRepository;\nimport io.undertow.server.handlers.encoding.EncodingHandler;\nimport io.undertow.server.handlers.encoding.GzipEncodingProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xnio.Options;\nimport org.xnio.Xnio;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic class HTTPServer {\n    static {\n        System.setProperty(\"org.jboss.logging.provider\", \"slf4j\");      // make undertow to use slf4j, refer to org.jboss.logging.LoggerProviders\n        // disable jboss custom thread pool, to use java built in DefaultThreadPoolExecutor\n        // they offer similar performance with typical setup, so to pick simpler one\n        // refer to org.jboss.threads.EnhancedQueueExecutor.DISABLE_HINT\n        System.setProperty(\"jboss.threads.eqe.disable\", \"true\");\n    }\n\n    public final SiteManager siteManager = new SiteManager();\n    public final HTTPHandler handler;\n    final ShutdownHandler shutdownHandler = new ShutdownHandler();\n\n    private final Logger logger = LoggerFactory.getLogger(HTTPServer.class);\n    private Undertow server;\n\n    public HTTPServer(LogManager logManager) {\n        handler = new HTTPHandler(logManager, siteManager.sessionManager, siteManager.templateManager);\n    }\n\n    public void start(HTTPServerConfig config) {\n        var watch = new StopWatch();\n        handler.interceptors = config.interceptors.toArray(new Interceptor[0]);\n        HTTPHost httpHost = config.httpHost;\n        HTTPHost httpsHost = config.httpsHost();\n        try {\n            Undertow.Builder builder = Undertow.builder();\n            if (httpHost != null) builder.addHttpListener(httpHost.port(), httpHost.host());\n            if (httpsHost != null) builder.addHttpsListener(httpsHost.port(), httpsHost.host(), new SSLContextBuilder().build());\n\n            builder.setHandler(handler(config))\n                // undertow accepts incoming connection very quick, backlog is hard to be filled even under load test, this setting is more for DDOS protection\n                // and not necessary under cloud env, here to set to match linux default value\n                // to use larger value, it requires to update kernel accordingly, e.g. sysctl -w net.core.somaxconn=1024 && sysctl -w net.ipv4.tcp_max_syn_backlog=4096\n                .setSocketOption(Options.BACKLOG, 1024)\n                .setServerOption(UndertowOptions.DECODE_URL, Boolean.FALSE)\n                .setServerOption(UndertowOptions.ENABLE_HTTP2, Boolean.TRUE)\n                .setServerOption(UndertowOptions.ENABLE_RFC6265_COOKIE_VALIDATION, Boolean.TRUE)\n                // since we don't use Expires or Last-Modified header, so it's not necessary to set Date header, for cache, prefer cache-control/max-age\n                // refer to https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.18.1\n                .setServerOption(UndertowOptions.ALWAYS_SET_DATE, Boolean.FALSE)\n                .setServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE, Boolean.FALSE)\n                // set tcp idle timeout to 620s, by default AWS ALB uses 60s, GCloud LB uses 600s, since it is always deployed with LB, longer timeout doesn't hurt\n                // refer to https://cloud.google.com/load-balancing/docs/https/#timeouts_and_retries\n                // refer to https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#connection-idle-timeout\n                .setServerOption(UndertowOptions.NO_REQUEST_TIMEOUT, 620_000)         // 620s\n                .setServerOption(UndertowOptions.SHUTDOWN_TIMEOUT, 10_000)            // 10s\n                .setServerOption(UndertowOptions.MAX_ENTITY_SIZE, config.maxEntitySize)\n                .setServerOption(UndertowOptions.RECORD_REQUEST_START_TIME, Boolean.TRUE);\n\n            builder.setWorker(Xnio.getInstance().createWorkerBuilder()\n                .setWorkerIoThreads(Math.max(Runtime.getRuntime().availableProcessors(), 2))\n                .setExternalExecutorService(handler.worker)\n                .build());\n\n            server = builder.build();\n            server.start();\n        } finally {\n            logger.info(\"http server started, http={}, https={}, gzip={}, elapsed={}\", httpHost, httpsHost, config.gzip, watch.elapsed());\n        }\n    }\n\n    private HttpHandler handler(HTTPServerConfig config) {\n        HttpHandler handler = new HTTPIOHandler(this.handler, shutdownHandler, config.maxEntitySize);\n        if (config.gzip) {\n            // only support gzip, deflate is less popular\n            handler = new EncodingHandler(handler, new ContentEncodingRepository()\n                .addEncodingHandler(\"gzip\", new GzipEncodingProvider(), 100, new GZipPredicate()));\n        }\n        return handler;\n    }\n\n    public void shutdown() {\n        if (server != null) {\n            logger.info(\"shutting down http server\");\n            shutdownHandler.shutdown();\n            if (handler.webSocketHandler != null)\n                handler.webSocketHandler.shutdown();\n        }\n    }\n\n    public void awaitRequestCompletion(long timeoutInMs) throws InterruptedException {\n        if (server != null) {\n            boolean success = shutdownHandler.awaitTermination(timeoutInMs);\n            if (!success) {\n                logger.warn(errorCode(\"FAILED_TO_STOP\"), \"failed to wait active http requests to complete\");\n                handler.worker.shutdownNow();\n            } else {\n                logger.info(\"active http requests completed\");\n            }\n        }\n    }\n\n    public void awaitTermination() {\n        if (server != null) {\n            server.stop();\n            logger.info(\"http server stopped\");\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPServerConfig.java."}, {"role": "assistant", "content": "The source code of java class HTTPServerConfig.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.util.Lists;\nimport core.framework.web.Interceptor;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class HTTPServerConfig {\n    public final List<Interceptor> interceptors = Lists.newArrayList();\n    public HTTPHost httpHost;\n    public HTTPHost httpsHost;\n    public boolean gzip;\n    public long maxEntitySize = 10_000_000;    // limit max post body to 10M, apply to multipart as well\n\n    public HTTPHost httpsHost() {\n        if (httpHost == null && httpsHost == null) return new HTTPHost(\"0.0.0.0\", 8443);    // by default start https only\n        return httpsHost;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPServerMetrics.java."}, {"role": "assistant", "content": "The source code of java class HTTPServerMetrics.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\n\n/**\n * @author neo\n */\npublic class HTTPServerMetrics implements Metrics {\n    private final HTTPServer server;\n\n    public HTTPServerMetrics(HTTPServer server) {\n        this.server = server;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        int activeRequests = server.shutdownHandler.activeRequests.max();\n        stats.put(\"http_active_requests\", activeRequests);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ClientIPParser.java."}, {"role": "assistant", "content": "The source code of java class ClientIPParser.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.util.Strings;\nimport core.framework.web.exception.BadRequestException;\n\n/**\n * @author neo\n */\npublic class ClientIPParser {\n    // for common scenarios, e.g. Google LB(appends 2 ips)->kube service, AWS->nginx->webapp,\n    // for google lb, it appends <immediate client IP>, <global forwarding rule external IP>, refer to https://cloud.google.com/load-balancing/docs/https#target-proxies\n    public int maxForwardedIPs = 2;\n\n    String parse(String remoteAddress, String xForwardedFor) {\n        if (Strings.isBlank(xForwardedFor)) return remoteAddress;\n\n        int foundForwardedIPs = 1;\n        int index = xForwardedFor.length() - 1;\n        int start;\n        int end = index + 1;    // substring end index is exclusive\n        while (true) {\n            char ch = xForwardedFor.charAt(index);\n            if (ch == ',') {\n                foundForwardedIPs++;\n                if (foundForwardedIPs > maxForwardedIPs) {\n                    start = index + 1;\n                    break;\n                } else {\n                    end = index;\n                }\n            }\n            if (index == 0) {\n                start = index;\n                break;\n            }\n            index--;\n        }\n\n        // according to https://tools.ietf.org/html/rfc7239\n        // x-forwarded-for = node, node, ...\n        // node     = nodename [ \":\" node-port ]\n        // nodename = IPv4address / \"[\" IPv6address \"]\" / \"unknown\" / obfnode\n        // currently only Azure Application Gateway may use ipv4:port, and it doesn't support ipv6 yet\n        // so here only to support ipv4, ipv4:port, ipv6 format\n        String node = xForwardedFor.substring(start, end).trim();\n        return extractIP(node);\n    }\n\n    // could be x-forwarded-for spoofing or pass thru http forward proxies\n    boolean hasMoreThanMaxForwardedIPs(String xForwardedFor) {\n        if (xForwardedFor == null) return false;    // maxForwardedIPs must greater than 0\n        int foundIPs = 1;\n        int length = xForwardedFor.length();\n        for (int i = 0; i < length; i++) {\n            if (xForwardedFor.charAt(i) == ',') foundIPs++;\n        }\n        return foundIPs > maxForwardedIPs;\n    }\n\n    // check loosely to avoid unnecessary overhead, especially x-forwarded-for is extracted from right to left, where values are from trusted LB\n    // ipv4 must have 3 dots and 1 optional colon, with hex chars\n    // ipv6 must have only colons with hex chars\n    String extractIP(String node) {\n        int length = node.length();\n        int dots = 0;\n        int lastDotIndex = -1;\n        int colons = 0;\n        int lastColonIndex = -1;\n        for (int i = 0; i < length; i++) {\n            char ch = node.charAt(i);\n            if (ch == '.') {\n                dots++;\n                lastDotIndex = i;\n            } else if (ch == ':') {\n                colons++;\n                lastColonIndex = i;\n            } else if (Character.digit(ch, 16) == -1) {\n                throw new BadRequestException(\"invalid client ip address\");\n            }\n        }\n        if (dots == 0) return node; // should be ipv6 format\n        if (dots == 3 && (colons == 0\n                          || colons == 1 && lastColonIndex > lastDotIndex && lastColonIndex < length - 1)) {\n            if (lastColonIndex > 0) return node.substring(0, lastColonIndex);   // should be ipv4:port\n            return node;    // should be ipv4\n        }\n        throw new BadRequestException(\"invalid client ip address\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HeaderLogParam.java."}, {"role": "assistant", "content": "The source code of java class HeaderLogParam.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.internal.log.filter.LogParam;\nimport core.framework.internal.log.filter.LogParamHelper;\nimport io.undertow.util.HeaderValues;\nimport io.undertow.util.HttpString;\n\nimport java.util.Set;\n\n/**\n * @author neo\n */\nclass HeaderLogParam implements LogParam {\n    private final HttpString header;\n    private final HeaderValues values;\n\n    HeaderLogParam(HttpString header, HeaderValues values) {\n        this.header = header;\n        this.values = values;\n    }\n\n    @Override\n    public void append(StringBuilder builder, Set<String> maskedFields, int maxParamLength) {\n        if (maskedFields.contains(header.toString())) {\n            builder.append(\"******\");\n        } else if (values.size() == 1) {\n            String value = values.getFirst();\n            LogParamHelper.append(builder, value, maxParamLength);\n        } else {\n            LogParamHelper.append(builder, values.toArray(), maxParamLength);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PathParams.java."}, {"role": "assistant", "content": "The source code of java class PathParams.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.util.Encodings;\nimport core.framework.util.Maps;\nimport core.framework.web.exception.BadRequestException;\n\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class PathParams {\n    private final Map<String, String> params = Maps.newHashMap();\n\n    public void put(String name, String value) {\n        if (value.isEmpty()) throw new BadRequestException(format(\"path param must not be empty, name={}, value={}\", name, value), \"INVALID_HTTP_REQUEST\");\n        try {\n            params.put(name, Encodings.decodeURIComponent(value));  // value here is not decoded, see io.undertow.UndertowOptions.DECODE_URL and core.framework.internal.web.HTTPServer\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(e.getMessage(), \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public String get(String name) {\n        String value = params.get(name);\n        if (value == null) throw new Error(\"path param not found, name=\" + name);\n        return value;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RequestBodyReader.java."}, {"role": "assistant", "content": "The source code of java class RequestBodyReader.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.internal.web.HTTPHandler;\nimport core.framework.web.exception.BadRequestException;\nimport io.undertow.connector.PooledByteBuffer;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.AttachmentKey;\nimport org.xnio.ChannelListener;\nimport org.xnio.IoUtils;\nimport org.xnio.channels.StreamSourceChannel;\n\nimport java.nio.ByteBuffer;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class RequestBodyReader implements ChannelListener<StreamSourceChannel> {\n    static final AttachmentKey<RequestBody> REQUEST_BODY = AttachmentKey.create(RequestBody.class);\n\n    private final HttpServerExchange exchange;\n    private final HTTPHandler handler;\n    private final int contentLength;\n    private boolean complete;\n    private byte[] body;\n    private int position = 0;\n\n    public RequestBodyReader(HttpServerExchange exchange, HTTPHandler handler) {\n        this.exchange = exchange;\n        this.handler = handler;\n        contentLength = (int) exchange.getRequestContentLength();\n        if (contentLength >= 0) body = new byte[contentLength];\n    }\n\n    @Override\n    public void handleEvent(StreamSourceChannel channel) {\n        read(channel);\n        if (complete) {\n            exchange.dispatch(handler);\n        }\n    }\n\n    public void read(StreamSourceChannel channel) {\n        try (PooledByteBuffer poolItem = exchange.getConnection().getByteBufferPool().allocate()) {\n            ByteBuffer buffer = poolItem.getBuffer();\n            int bytesRead;\n            while (true) {\n                buffer.clear();\n                bytesRead = channel.read(buffer);\n                if (bytesRead <= 0) break;\n                buffer.flip();\n                ensureCapacity(bytesRead);\n                buffer.get(body, position, bytesRead);\n                position += bytesRead;\n            }\n            if (bytesRead == -1) {\n                if (contentLength >= 0 && position < body.length) {\n                    throw new Error(format(\"body ends prematurely, expected={}, actual={}\", contentLength, position));\n                } else if (body == null) {\n                    body = new byte[0]; // without content length and has no body\n                }\n                complete = true;\n                exchange.putAttachment(REQUEST_BODY, new RequestBody(body, null));\n            }\n        } catch (Throwable e) { // catch all errors during IO, to pass error to action log\n            IoUtils.safeClose(channel);\n            complete = true;\n            exchange.putAttachment(REQUEST_BODY, new RequestBody(null, e));\n        }\n    }\n\n    private void ensureCapacity(int bytesRead) {\n        if (contentLength >= 0) {\n            if (bytesRead + position > contentLength) throw new Error(\"body exceeds expected content length, expected=\" + contentLength);\n        } else {\n            if (body == null) { // undertow buffer is 16k, if there is no content length, in most of cases, it's best just to create exact buffer as first read thru\n                body = new byte[bytesRead];\n            } else {\n                int newLength = position + bytesRead;   // without content length, position will always be current length,\n                byte[] bytes = new byte[newLength];     // just expend to exact read size, which is simplest way for best scenario\n                System.arraycopy(body, 0, bytes, 0, position);\n                body = bytes;\n            }\n        }\n    }\n\n    public boolean complete() {\n        return complete;\n    }\n\n    public static class RequestBody {\n        private final byte[] body;\n        private final Throwable exception;\n\n        RequestBody(byte[] body, Throwable exception) {\n            this.body = body;\n            this.exception = exception;\n        }\n\n        public byte[] body() {\n            if (exception != null) throw new BadRequestException(exception.getMessage(), \"FAILED_TO_READ_HTTP_REQUEST\", exception);\n            return this.body;\n        }\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RequestImpl.java."}, {"role": "assistant", "content": "The source code of java class RequestImpl.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.validate.ValidationException;\nimport core.framework.internal.web.bean.RequestBeanReader;\nimport core.framework.util.Maps;\nimport core.framework.web.CookieSpec;\nimport core.framework.web.MultipartFile;\nimport core.framework.web.Request;\nimport core.framework.web.Session;\nimport core.framework.web.exception.BadRequestException;\nimport io.undertow.server.HttpServerExchange;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class RequestImpl implements Request {\n    public final PathParams pathParams = new PathParams();\n\n    final Map<String, String> queryParams = Maps.newHashMap();\n    final Map<String, String> formParams = Maps.newHashMap();\n    final Map<String, MultipartFile> files = Maps.newHashMap();\n\n    private final HttpServerExchange exchange;\n    private final RequestBeanReader reader;\n    public Session session;\n\n    HTTPMethod method;\n    String clientIP;\n    String scheme;\n    String hostname;\n    int port;\n    String path;\n    String requestURL;\n    ContentType contentType;\n    byte[] body;\n    Map<String, String> cookies;\n\n    public RequestImpl(HttpServerExchange exchange, RequestBeanReader reader) {\n        this.exchange = exchange;\n        this.reader = reader;\n    }\n\n    @Override\n    public String requestURL() {\n        return requestURL;\n    }\n\n    @Override\n    public String scheme() {\n        return scheme;\n    }\n\n    @Override\n    public String hostname() {\n        return hostname;\n    }\n\n    @Override\n    public String path() {\n        return path;\n    }\n\n    @Override\n    public String clientIP() {\n        return clientIP;\n    }\n\n    @Override\n    public Optional<String> cookie(CookieSpec spec) {\n        if (cookies == null) return Optional.empty();\n        return Optional.ofNullable(cookies.get(spec.name));\n    }\n\n    @Override\n    public Session session() {\n        if (!\"https\".equals(scheme)) throw new Error(\"session must be used with https\");\n        if (session == null) throw new Error(\"site().session() must be configured\");\n        return session;\n    }\n\n    @Override\n    public HTTPMethod method() {\n        return method;\n    }\n\n    @Override\n    public Optional<String> header(String name) {\n        return Optional.ofNullable(exchange.getRequestHeaders().getFirst(name));\n    }\n\n    @Override\n    public String pathParam(String name) {\n        return pathParams.get(name);\n    }\n\n    @Override\n    public Map<String, String> queryParams() {\n        return queryParams;\n    }\n\n    @Override\n    public Map<String, String> formParams() {\n        return formParams;\n    }\n\n    @Override\n    public Map<String, MultipartFile> files() {\n        return files;\n    }\n\n    @Override\n    public Optional<byte[]> body() {\n        return Optional.ofNullable(body);\n    }\n\n    @Override\n    public <T> T bean(Class<T> beanClass) {\n        try {\n            if (method == HTTPMethod.GET || method == HTTPMethod.DELETE) {\n                return reader.fromParams(beanClass, queryParams);\n            } else if (method == HTTPMethod.POST || method == HTTPMethod.PUT || method == HTTPMethod.PATCH) {\n                if (!formParams.isEmpty()) {\n                    return reader.fromParams(beanClass, formParams);\n                } else if (body != null && contentType != null && ContentType.APPLICATION_JSON.mediaType.equals(contentType.mediaType)) {\n                    return reader.fromJSON(beanClass, body);\n                }\n                throw new BadRequestException(format(\"body is missing or unsupported content type, method={}, contentType={}\", method, contentType), \"INVALID_HTTP_REQUEST\");\n            } else {\n                throw new Error(\"not supported method, method=\" + method);\n            }\n        } catch (ValidationException e) {\n            throw new BadRequestException(e.getMessage(), e.errorCode(), e);\n        } catch (IOException e) {  // for invalid json string\n            // for security concern, to hide original error message, jackson may return detailed info, e.g. possible allowed values for enum\n            // detailed info can still be found in trace log or exception stack trace\n            throw new BadRequestException(\"failed to deserialize request, beanClass=\" + beanClass.getCanonicalName(), \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RequestParser.java."}, {"role": "assistant", "content": "The source code of java class RequestParser.java:\n```java\npackage core.framework.internal.web.request;\n\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.http.BodyLogParam;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.filter.FieldLogParam;\nimport core.framework.util.Strings;\nimport core.framework.web.MultipartFile;\nimport core.framework.web.exception.BadRequestException;\nimport core.framework.web.exception.MethodNotAllowedException;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.server.handlers.Cookie;\nimport io.undertow.server.handlers.form.FormData;\nimport io.undertow.server.handlers.form.FormDataParser;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.HeaderValues;\nimport io.undertow.util.Headers;\nimport io.undertow.util.HttpString;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.log.Markers.errorCode;\nimport static core.framework.util.Encodings.decodeURIComponent;\nimport static core.framework.util.Strings.format;\nimport static java.net.URLDecoder.decode;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic final class RequestParser {\n    static final int MAX_URL_LENGTH = 2000;\n    public final ClientIPParser clientIPParser = new ClientIPParser();\n    private final Logger logger = LoggerFactory.getLogger(RequestParser.class);\n    private final Set<HTTPMethod> withBodyMethods = EnumSet.of(HTTPMethod.POST, HTTPMethod.PUT, HTTPMethod.PATCH);\n    public boolean logSiteHeaders;\n\n    public void parse(RequestImpl request, HttpServerExchange exchange, ActionLog actionLog) throws Throwable {\n        HeaderMap headers = exchange.getRequestHeaders();\n\n        request.scheme = scheme(exchange.getRequestScheme(), headers.getFirst(Headers.X_FORWARDED_PROTO));\n        request.hostname = hostname(exchange.getHostName(), headers.getFirst(Headers.X_FORWARDED_HOST));\n        int requestPort = requestPort(headers.getFirst(Headers.HOST), request.scheme, exchange);\n        request.port = port(requestPort, headers.getFirst(Headers.X_FORWARDED_PORT));\n\n        String method = exchange.getRequestMethod().toString();\n        actionLog.context.put(\"method\", List.of(method));\n\n        String path = exchange.getRequestPath();\n        request.path = path.isEmpty() ? \"/\" : path; // according to https://www.rfc-editor.org/rfc/rfc2616#section-5.1.2, empty path must be normalized as '/'\n\n        request.requestURL = requestURL(request, exchange);\n        putContext(actionLog, \"request_url\", request.requestURL);   // record request url even if attacker passes long string\n        logger.debug(\"[request] method={}, requestURL={}\", method, request.requestURL);\n\n        logHeaders(headers);\n        parseClientIP(request, exchange, actionLog, headers.getFirst(Headers.X_FORWARDED_FOR)); // parse client ip after logging header, as ip in x-forwarded-for may be invalid\n        parseCookies(request, exchange);\n\n        // parse method, validate url length after logging header/etc, to gather more info in case we see arbitrary attacking request from internet\n        request.method = httpMethod(method);\n        if (request.requestURL.length() > MAX_URL_LENGTH) throw new BadRequestException(format(\"requestURL is too long, requestURL={}...(truncated)\", request.requestURL.substring(0, 50)), \"INVALID_HTTP_REQUEST\");\n\n        logSiteHeaders(headers, actionLog);\n        parseQueryParams(request, exchange.getQueryParameters());\n\n        if (withBodyMethods.contains(request.method)) {\n            String contentType = headers.getFirst(Headers.CONTENT_TYPE);\n            request.contentType = contentType == null ? null : ContentType.parse(contentType);\n            parseBody(request, exchange);\n            actionLog.stats.put(\"request_body_length\", (double) exchange.getRequestContentLength());\n        }\n    }\n\n    String hostname(String hostname, String xForwardedHost) {\n        if (Strings.isBlank(xForwardedHost)) return hostname;\n        return xForwardedHost;\n    }\n\n    void parseCookies(RequestImpl request, HttpServerExchange exchange) {\n        HeaderValues cookieHeaders = exchange.getRequestHeaders().get(Headers.COOKIE);\n        if (cookieHeaders != null) {\n            try {\n                request.cookies = decodeCookies(exchange.requestCookies());\n            } catch (IllegalArgumentException | IllegalStateException e) {\n                logger.debug(\"[request:header] {}={}\", Headers.COOKIE, new HeaderLogParam(Headers.COOKIE, cookieHeaders));\n                // entire cookie will be failed to parse if there is poison cookie value, undertow doesn't provide API to parse cookie individually\n                // since it's rare case, here is to use simplified solution to block entire request, rather than hide which may cause potential issues, e.g. never get SESSION_ID to login\n                // so this force client to clear all cookies and refresh\n                // refer to io.undertow.UndertowMessages.couldNotParseCookie\n                // refer to io.undertow.UndertowMessages.tooManyCookies\n                throw new BadRequestException(\"invalid cookie\", \"INVALID_COOKIE\", e);\n            }\n        }\n    }\n\n    private void parseClientIP(RequestImpl request, HttpServerExchange exchange, ActionLog actionLog, String xForwardedFor) {\n        String remoteAddress = exchange.getSourceAddress().getAddress().getHostAddress();\n        request.clientIP = clientIPParser.parse(remoteAddress, xForwardedFor);\n        actionLog.context.put(\"client_ip\", List.of(request.clientIP));\n        if (clientIPParser.hasMoreThanMaxForwardedIPs(xForwardedFor)) {\n            actionLog.context.put(\"x_forwarded_for\", List.of(xForwardedFor));\n        }\n        logger.debug(\"[request] remoteAddress={}, clientIP={}\", remoteAddress, request.clientIP);\n    }\n\n    String scheme(String requestScheme, String xForwardedProto) {       // xForwardedProto is single value, refer to https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto\n        return xForwardedProto != null ? xForwardedProto : requestScheme;\n    }\n\n    private void logHeaders(HeaderMap headers) {\n        for (HeaderValues header : headers) {\n            HttpString name = header.getHeaderName();\n            if (!Headers.COOKIE.equals(name)) {\n                logger.debug(\"[request:header] {}={}\", name, new HeaderLogParam(name, header));\n            }\n        }\n    }\n\n    void logSiteHeaders(HeaderMap headers, ActionLog actionLog) {\n        if (logSiteHeaders) {\n            String userAgent = headers.getFirst(Headers.USER_AGENT);\n            if (userAgent != null) putContext(actionLog, \"user_agent\", userAgent);\n            String referer = headers.getFirst(Headers.REFERER);\n            if (referer != null) putContext(actionLog, \"referer\", referer);\n        }\n    }\n\n    Map<String, String> decodeCookies(Iterable<Cookie> cookies) {\n        Map<String, String> cookieValues = new HashMap<>();\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            String value = cookie.getValue();\n            try {\n                String cookieName = decodeURIComponent(name);\n                String cookieValue = decodeURIComponent(value);\n                logger.debug(\"[request:cookie] {}={}\", cookieName, new FieldLogParam(cookieName, cookieValue));\n                cookieValues.put(cookieName, cookieValue);\n            } catch (IllegalArgumentException e) {\n                // cookies is persistent in browser, here is to ignore, in case user may not be able to access website with legacy cookie\n                logger.warn(errorCode(\"INVALID_COOKIE\"), \"ignore invalid encoded cookie, name={}, value={}\", name, value, e);\n            }\n        }\n        return cookieValues;\n    }\n\n    void parseQueryParams(RequestImpl request, Map<String, Deque<String>> params) {\n        for (Map.Entry<String, Deque<String>> entry : params.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue().getFirst(); // params deque won't be empty so don't expect exception here\n            try {\n                String paramName = decode(key, UTF_8);\n                String paramValue = decode(value, UTF_8);\n                logger.debug(\"[request:query] {}={}\", paramName, paramValue);\n                request.queryParams.put(paramName, paramValue);\n            } catch (IllegalArgumentException e) {\n                throw new BadRequestException(format(\"failed to parse query param, name={}, value={}\", key, value), \"INVALID_HTTP_REQUEST\", e);\n            }\n        }\n    }\n\n    HTTPMethod httpMethod(String method) {\n        try {\n            return HTTPMethod.valueOf(method);\n        } catch (IllegalArgumentException e) {\n            throw new MethodNotAllowedException(\"method not allowed, method=\" + method, e);\n        }\n    }\n\n    void parseBody(RequestImpl request, HttpServerExchange exchange) throws Throwable {\n        var body = exchange.getAttachment(RequestBodyReader.REQUEST_BODY);\n        if (body != null) {\n            request.body = body.body();\n            logger.debug(\"[request] body={}\", BodyLogParam.of(request.body, request.contentType));\n        } else {\n            parseForm(request, exchange);\n        }\n    }\n\n    private void parseForm(RequestImpl request, HttpServerExchange exchange) throws IOException {\n        FormData formData = exchange.getAttachment(FormDataParser.FORM_DATA);\n        if (formData == null) return;\n\n        for (String name : formData) {\n            FormData.FormValue value = formData.getFirst(name);\n            if (value.isFileItem()) {\n                String fileName = value.getFileName();\n                if (!Strings.isBlank(fileName)) {    // browser passes blank file name if not choose file in form\n                    FormData.FileItem item = value.getFileItem();\n                    logger.debug(\"[request:file] {}={}, size={}\", name, fileName, item.getFileSize());\n                    request.files.put(name, new MultipartFile(item.getFile(), fileName, value.getHeaders().getFirst(Headers.CONTENT_TYPE)));\n                }\n            } else {\n                logger.debug(\"[request:form] {}={}\", name, new FieldLogParam(name, value.getValue()));\n                request.formParams.put(name, value.getValue());\n            }\n        }\n    }\n\n    int port(int requestPort, String xForwardedPort) {\n        if (xForwardedPort != null) {\n            try {\n                int index = xForwardedPort.indexOf(',');\n                if (index > 0) {\n                    return Integer.parseInt(xForwardedPort.substring(0, index));\n                } else {\n                    return Integer.parseInt(xForwardedPort);\n                }\n            } catch (NumberFormatException e) {\n                // to protect X-Forwarded-Port spoofing\n                throw new BadRequestException(\"invalid port\", \"INVALID_HTTP_REQUEST\", e);\n            }\n        }\n        return requestPort;\n    }\n\n    // due to google cloud LB does not forward x-forwarded-port, here is to use x-forwarded-proto to determine port if any\n    int requestPort(String host, String scheme, HttpServerExchange exchange) {    // refer to io.undertow.server.HttpServerExchange.getHostPort(), use x-forwarded-proto as request scheme\n        if (host != null) {     // HOST header is must for http/1.1, refer to https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n            int colonIndex;\n            if (Strings.startsWith(host, '[')) { //for ipv6 addresses make sure to take out the first part, which can have multiple occurrences of ':', e.g. Host: [::1]:5001\n                colonIndex = host.indexOf(':', host.indexOf(']'));\n            } else {\n                colonIndex = host.indexOf(':');\n            }\n            if (colonIndex > 0 && colonIndex + 1 < host.length()) { // parse port only if ':' is in middle of string\n                return Integer.parseInt(host.substring(colonIndex + 1));\n            }\n            // return default port according to scheme\n            if (\"https\".equals(scheme)) return 443;\n            if (\"http\".equals(scheme)) return 80;\n        }\n        return exchange.getDestinationAddress().getPort();\n    }\n\n    String requestURL(RequestImpl request, HttpServerExchange exchange) {\n        var builder = new StringBuilder(128);\n\n        // GET can use absolute url as request uri, http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html, when client sends request via forward proxy\n        if (!exchange.isHostIncludedInRequestURI()) {\n            String scheme = request.scheme;\n            int port = request.port;\n\n            builder.append(scheme)\n                .append(\"://\")\n                .append(request.hostname);\n\n            if (!(port == 80 && \"http\".equals(scheme)) && !(port == 443 && \"https\".equals(scheme))) {\n                builder.append(':').append(port);\n            }\n        }\n\n        builder.append(exchange.getRequestURI());\n\n        String queryString = exchange.getQueryString();\n        if (!queryString.isEmpty()) builder.append('?').append(queryString);\n\n        return builder.toString();\n    }\n\n    // directly put to actionLog context with truncation, to handle attacking request gracefully\n    // to unify request logging, and to be slightly efficient\n    void putContext(ActionLog actionLog, String key, String value) {\n        String contextValue = value.length() <= ActionLog.MAX_CONTEXT_VALUE_LENGTH ? value : value.substring(0, ActionLog.MAX_CONTEXT_VALUE_LENGTH);\n        actionLog.context.put(key, List.of(contextValue));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class BeanBody.java."}, {"role": "assistant", "content": "The source code of java class BeanBody.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.internal.log.filter.BytesLogParam;\nimport io.undertow.io.Sender;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.ByteBuffer;\n\n/**\n * @author neo\n */\npublic final class BeanBody implements Body {\n    private static final Logger LOGGER = LoggerFactory.getLogger(BeanBody.class);\n    public final Object bean;\n\n    public BeanBody(Object bean) {\n        this.bean = bean;\n    }\n\n    @Override\n    public long send(Sender sender, ResponseHandlerContext context) {\n        byte[] body = context.writer.toJSON(bean);\n        LOGGER.debug(\"[response] body={}\", new BytesLogParam(body));\n        sender.send(ByteBuffer.wrap(body));\n        return body.length;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Body.java."}, {"role": "assistant", "content": "The source code of java class Body.java:\n```java\npackage core.framework.internal.web.response;\n\nimport io.undertow.io.Sender;\n\n/**\n * @author neo\n */\ninterface Body {\n    // return body length\n    long send(Sender sender, ResponseHandlerContext context);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ByteArrayBody.java."}, {"role": "assistant", "content": "The source code of java class ByteArrayBody.java:\n```java\npackage core.framework.internal.web.response;\n\nimport io.undertow.io.Sender;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.ByteBuffer;\n\n/**\n * @author rainbow.cai\n */\npublic final class ByteArrayBody implements Body {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ByteArrayBody.class);\n    private final byte[] bytes;\n\n    public ByteArrayBody(byte[] bytes) {\n        this.bytes = bytes;\n    }\n\n    @Override\n    public long send(Sender sender, ResponseHandlerContext context) {\n        LOGGER.debug(\"[response] body=bytes[{}]\", bytes.length);\n        sender.send(ByteBuffer.wrap(bytes));\n        return bytes.length;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class FileBody.java."}, {"role": "assistant", "content": "The source code of java class FileBody.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.log.ErrorCode;\nimport core.framework.log.Severity;\nimport core.framework.util.Files;\nimport io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.io.Serial;\nimport java.io.UncheckedIOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\n/**\n * @author neo\n */\npublic final class FileBody implements Body {\n    private static final Logger LOGGER = LoggerFactory.getLogger(FileBody.class);\n    private final Path path;\n\n    public FileBody(Path path) {\n        this.path = path;\n    }\n\n    @Override\n    public long send(Sender sender, ResponseHandlerContext context) {\n        LOGGER.debug(\"[response] file={}\", path);\n        try {\n            long size = Files.size(path);\n            FileChannel channel = FileChannel.open(path, StandardOpenOption.READ);\n            sender.transferFrom(channel, new FileBodyCallback(channel));\n            return size;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    static class FileBodyCallback implements IoCallback {\n        private final FileChannel channel;\n\n        FileBodyCallback(FileChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public void onComplete(HttpServerExchange exchange, Sender sender) {\n            IoUtils.safeClose(channel);\n            END_EXCHANGE.onComplete(exchange, sender);\n        }\n\n        @Override\n        public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n            IoUtils.safeClose(channel);\n            END_EXCHANGE.onException(exchange, sender, exception);\n            throw convertException(exception);\n        }\n\n        UncheckedIOException convertException(IOException exception) {\n            // convert client abort exception to warning, e.g. user closed browser before content is transferred completely\n            if (exception instanceof ClosedChannelException) {\n                return new ClientAbortException(exception);\n            }\n            return new UncheckedIOException(exception);\n        }\n    }\n\n    static class ClientAbortException extends UncheckedIOException implements ErrorCode {\n        @Serial\n        private static final long serialVersionUID = 3981103270777664274L;\n\n        ClientAbortException(IOException cause) {\n            super(cause);\n        }\n\n        @Override\n        public String errorCode() {\n            return \"CLIENT_ABORT\";\n        }\n\n        @Override\n        public Severity severity() {\n            return Severity.WARN;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResponseHandler.java."}, {"role": "assistant", "content": "The source code of java class ResponseHandler.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.filter.FieldLogParam;\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.internal.web.request.RequestImpl;\nimport core.framework.internal.web.session.SessionManager;\nimport core.framework.internal.web.site.TemplateManager;\nimport core.framework.util.Encodings;\nimport core.framework.web.CookieSpec;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.server.handlers.CookieImpl;\nimport io.undertow.server.handlers.CookieSameSiteMode;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.HttpString;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class ResponseHandler {\n    private final Logger logger = LoggerFactory.getLogger(ResponseHandler.class);\n    private final ResponseHandlerContext context;\n    private final SessionManager sessionManager;\n\n    public ResponseHandler(ResponseBeanWriter writer, TemplateManager templateManager, SessionManager sessionManager) {\n        context = new ResponseHandlerContext(writer, templateManager);\n        this.sessionManager = sessionManager;\n    }\n\n    public void render(RequestImpl request, ResponseImpl response, HttpServerExchange exchange, ActionLog actionLog) {\n        // always try to save session before response, even for exception flow in case it's invalidated or generated new sessionId\n        sessionManager.save(request, response, actionLog);\n\n        HTTPStatus status = response.status();\n        exchange.setStatusCode(status.code);\n        actionLog.context.put(\"response_code\", List.of(String.valueOf(status.code)));\n        logger.debug(\"[response] statusCode={}\", status.code);\n\n        putHeaders(response, exchange);\n        putCookies(response, exchange);\n\n        long bodyLength = response.body.send(exchange.getResponseSender(), context);\n        // due to exchange.sender is async, exchange.getResponseBytesSent() won't return accurate body length at this point,\n        // use actual body bytes size prior to gzip, to match http client perf_http stats\n        logger.debug(\"[response] bodyLength={}\", bodyLength);\n        actionLog.stats.put(\"response_body_length\", (double) bodyLength);\n    }\n\n    private void putHeaders(ResponseImpl response, HttpServerExchange exchange) {\n        HeaderMap headers = exchange.getResponseHeaders();\n        for (var entry : response.headers.entrySet()) {\n            HttpString name = entry.getKey();\n            String value = entry.getValue();\n            headers.put(name, value);\n            logger.debug(\"[response:header] {}={}\", name, new FieldLogParam(name.toString(), value));\n        }\n    }\n\n    private void putCookies(ResponseImpl response, HttpServerExchange exchange) {\n        if (response.cookies != null) {\n            for (var entry : response.cookies.entrySet()) {\n                CookieSpec spec = entry.getKey();\n                String value = entry.getValue();\n                CookieImpl cookie = cookie(spec, value);\n                exchange.setResponseCookie(cookie);\n                logger.debug(\"[response:cookie] name={}, value={}, domain={}, path={}, secure={}, httpOnly={}, maxAge={}\",\n                    spec.name, new FieldLogParam(spec.name, cookie.getValue()), cookie.getDomain(), cookie.getPath(), cookie.isSecure(), cookie.isHttpOnly(), cookie.getMaxAge());\n            }\n        }\n    }\n\n    CookieImpl cookie(CookieSpec spec, String value) {\n        var cookie = new CookieImpl(spec.name);\n        if (value == null) {\n            cookie.setMaxAge(0);\n            cookie.setValue(\"\");\n        } else {\n            if (spec.maxAge != null) cookie.setMaxAge((int) spec.maxAge.getSeconds());\n            cookie.setValue(Encodings.uriComponent(value));     // recommended to use URI encoding for cookie value, https://curl.haxx.se/rfc/cookie_spec.html\n        }\n        cookie.setDomain(spec.domain);\n        cookie.setPath(spec.path);\n        cookie.setSecure(spec.secure);\n        cookie.setHttpOnly(spec.httpOnly);\n        // refer to https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute,\n        // lax is good enough for common scenario, as long as webapp doesn't make sensitive side effect thru TOP LEVEL navigation\n        if (spec.sameSite) cookie.setSameSiteMode(CookieSameSiteMode.LAX.toString());\n        return cookie;\n    }\n\n    String cookieKey(CookieSpec spec) {\n        return spec.name + \":\" + spec.domain + \":\" + spec.path;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResponseHandlerContext.java."}, {"role": "assistant", "content": "The source code of java class ResponseHandlerContext.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.internal.web.site.TemplateManager;\n\n/**\n * @author neo\n */\nfinal class ResponseHandlerContext {\n    final ResponseBeanWriter writer;\n    final TemplateManager templateManager;\n\n    ResponseHandlerContext(ResponseBeanWriter writer, TemplateManager templateManager) {\n        this.writer = writer;\n        this.templateManager = templateManager;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ResponseImpl.java."}, {"role": "assistant", "content": "The source code of java class ResponseImpl.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.http.ContentType;\nimport core.framework.util.Maps;\nimport core.framework.web.CookieSpec;\nimport core.framework.web.Response;\nimport io.undertow.util.Headers;\nimport io.undertow.util.HttpString;\n\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic final class ResponseImpl implements Response {\n    public final Body body;\n    final Map<HttpString, String> headers = Maps.newHashMap();\n    Map<CookieSpec, String> cookies;\n    private ContentType contentType;\n    private HTTPStatus status = HTTPStatus.OK;\n\n    public ResponseImpl(Body body) {\n        this.body = body;\n    }\n\n    @Override\n    public HTTPStatus status() {\n        return status;\n    }\n\n    @Override\n    public Response status(HTTPStatus status) {\n        this.status = status;\n        return this;\n    }\n\n    @Override\n    public Optional<String> header(String name) {\n        return Optional.ofNullable(headers.get(new HttpString(name)));\n    }\n\n    @Override\n    public Response header(String name, String value) {\n        if (Headers.CONTENT_TYPE.equalToString(name)) throw new Error(\"must not use header() to update content type, please use response.contentType()\");\n        headers.put(new HttpString(name), value);\n        return this;\n    }\n\n    @Override\n    public Optional<ContentType> contentType() {\n        return Optional.ofNullable(contentType);\n    }\n\n    @Override\n    public Response contentType(ContentType contentType) {\n        this.contentType = contentType;\n        headers.put(Headers.CONTENT_TYPE, contentType.toString());\n        return this;\n    }\n\n    @Override\n    public Response cookie(CookieSpec spec, String value) {\n        if (cookies == null) cookies = Maps.newHashMap();\n        cookies.put(spec, value);\n        return this;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TemplateBody.java."}, {"role": "assistant", "content": "The source code of java class TemplateBody.java:\n```java\npackage core.framework.internal.web.response;\n\nimport io.undertow.io.Sender;\n\n/**\n * @author neo\n */\npublic final class TemplateBody implements Body {\n    private final String templatePath;\n    private final Object model;\n    private final String language;\n\n    public TemplateBody(String templatePath, Object model, String language) {\n        this.templatePath = templatePath;\n        this.model = model;\n        this.language = language;\n    }\n\n    @Override\n    public long send(Sender sender, ResponseHandlerContext context) {\n        String content = context.templateManager.process(templatePath, model, language);\n        sender.send(content);\n        return content.length();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TextBody.java."}, {"role": "assistant", "content": "The source code of java class TextBody.java:\n```java\npackage core.framework.internal.web.response;\n\nimport core.framework.util.Strings;\nimport io.undertow.io.Sender;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.ByteBuffer;\n\n/**\n * @author neo\n */\npublic final class TextBody implements Body {\n    private final Logger logger = LoggerFactory.getLogger(TextBody.class);\n\n    private final String text;\n\n    public TextBody(String text) {\n        this.text = text;\n    }\n\n    @Override\n    public long send(Sender sender, ResponseHandlerContext context) {\n        byte[] bytes = Strings.bytes(text);\n        logger.debug(\"[response] body={}\", text);\n        sender.send(ByteBuffer.wrap(bytes));\n        return bytes.length;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Path.java."}, {"role": "assistant", "content": "The source code of java class Path.java:\n```java\npackage core.framework.internal.web.route;\n\n/**\n * @author neo\n */\npublic final class Path {\n    public static Path parse(String path) {\n        Path root = new Path(\"/\");\n        if (\"/\".equals(path)) return root;\n\n        Path current = root;\n        int length = path.length();\n        int from = 1;\n\n        for (int i = 1; i < length; i++) {\n            char ch = path.charAt(i);\n            if (ch == '/') {\n                current.next = new Path(path.substring(from, i));\n                current = current.next;\n                from = i + 1;\n            }\n        }\n\n        String lastPath = from == length ? \"/\" : path.substring(from);\n        current.next = new Path(lastPath);\n\n        return root;\n    }\n\n    public final String value;\n    public Path next;\n\n    private Path(String value) {\n        this.value = value;\n    }\n\n    String subPath() {\n        var builder = new StringBuilder();\n        Path current = this;\n\n        while (current != null) {\n            if (builder.length() > 1 && !\"/\".equals(current.value)) builder.append('/');\n            builder.append(current.value);\n            current = current.next;\n        }\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PathNode.java."}, {"role": "assistant", "content": "The source code of java class PathNode.java:\n```java\npackage core.framework.internal.web.route;\n\nimport core.framework.internal.web.request.PathParams;\nimport core.framework.util.Strings;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nclass PathNode {\n    private final String param;\n    private URLHandler handler;\n    private Map<String, PathNode> staticNodes;\n    private PathNode dynamicNode;\n    private PathNode wildcardNode;\n\n    PathNode(String param) {\n        this.param = param;\n    }\n\n    URLHandler register(String pathPattern) {\n        return register(pathPattern, Path.parse(pathPattern).next);\n    }\n\n    private URLHandler register(String pathPattern, Path currentPath) {\n        if (currentPath == null) {\n            if (handler == null) handler = new URLHandler(pathPattern);\n            return handler;\n        } else if (Strings.startsWith(currentPath.value, ':')) {\n            int paramIndex = currentPath.value.indexOf('(');\n            int endIndex = paramIndex > 0 ? paramIndex : currentPath.value.length();\n            String param = currentPath.value.substring(1, endIndex);\n            boolean wildcard = paramIndex > 0;\n            if (wildcard) {\n                return registerWildcardNode(pathPattern, currentPath, param);\n            } else {\n                return registerDynamicNode(pathPattern, currentPath, param);\n            }\n        } else {\n            if (staticNodes == null) staticNodes = new HashMap<>();\n            PathNode staticNode = staticNodes.computeIfAbsent(currentPath.value, key -> new PathNode(null));\n            return staticNode.register(pathPattern, currentPath.next);\n        }\n    }\n\n    private URLHandler registerWildcardNode(String pathPattern, Path currentPath, String param) {\n        if (currentPath.next != null) throw new Error(format(\"wildcard path variable must be the last, path={}, param={}\", pathPattern, param));\n        if (wildcardNode != null) {\n            if (!Strings.equals(wildcardNode.param, param))\n                throw new Error(format(\"found conflict dynamic pattern, path={}, param={}, conflictedParam={}\", pathPattern, param, wildcardNode.param));\n        } else {\n            wildcardNode = new PathNode(param);\n        }\n        return wildcardNode.register(pathPattern, currentPath.next);\n    }\n\n    private URLHandler registerDynamicNode(String pathPattern, Path currentPath, String param) {\n        if (dynamicNode != null) {\n            if (!Strings.equals(dynamicNode.param, param))\n                throw new Error(format(\"found conflict dynamic pattern, path={}, param={}, conflictedParam={}\", pathPattern, param, dynamicNode.param));\n        } else {\n            dynamicNode = new PathNode(param);\n        }\n        return dynamicNode.register(pathPattern, currentPath.next);\n    }\n\n    URLHandler find(String path, PathParams pathParams) {\n        return find(Path.parse(path), pathParams);\n    }\n\n    private URLHandler find(Path currentPath, PathParams pathParams) {\n        Path nextPath = currentPath.next;\n        if (nextPath == null) return handler;\n\n        URLHandler handler = findStatic(nextPath, pathParams);\n        if (handler != null) return handler;\n\n        if (!\"/\".equals(nextPath.value)) {  // dynamic node should not match trailing slash\n            handler = findDynamic(nextPath, pathParams);\n            if (handler != null) return handler;\n        }\n\n        if (wildcardNode != null) {\n            pathParams.put(wildcardNode.param, nextPath.subPath());\n            return wildcardNode.handler;\n        }\n\n        return null;\n    }\n\n    private URLHandler findStatic(Path nextPath, PathParams pathParams) {\n        if (staticNodes != null) {\n            PathNode nextNode = staticNodes.get(nextPath.value);\n            if (nextNode != null) {\n                return nextNode.find(nextPath, pathParams);\n            }\n        }\n        return null;\n    }\n\n    private URLHandler findDynamic(Path nextPath, PathParams pathParams) {\n        if (dynamicNode != null) {\n            URLHandler handler = dynamicNode.find(nextPath, pathParams);\n            if (handler != null) {\n                pathParams.put(dynamicNode.param, nextPath.value);\n                return handler;\n            }\n        }\n        return null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PathPatternValidator.java."}, {"role": "assistant", "content": "The source code of java class PathPatternValidator.java:\n```java\npackage core.framework.internal.web.route;\n\nimport core.framework.util.ASCII;\nimport core.framework.util.Sets;\nimport core.framework.util.Strings;\n\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class PathPatternValidator {\n    private final String pattern;\n    private final boolean allowWildcard;\n\n    public PathPatternValidator(String pattern, boolean allowWildcard) {\n        this.pattern = pattern;\n        this.allowWildcard = allowWildcard;\n    }\n\n    public void validate() {\n        if (Strings.isBlank(pattern)) throw new Error(\"path pattern must not be blank, pattern=\" + pattern);\n\n        if (!Strings.startsWith(pattern, '/')) throw new Error(\"path pattern must start with '/', pattern=\" + pattern);\n\n        Set<String> variables = Sets.newHashSet();\n        String[] tokens = Strings.split(pattern, '/');\n        for (String token : tokens) {\n            if (Strings.startsWith(token, ':')) {\n                validateVariable(token, pattern, variables);\n            } else {\n                validatePathSegment(token, pattern);\n            }\n        }\n    }\n\n    private void validateVariable(String token, String pattern, Set<String> variables) {\n        int patternIndex = token.indexOf('(');\n        int endIndex = patternIndex > 0 ? patternIndex : token.length();\n\n        String variable = token.substring(1, endIndex);\n        int length = variable.length();\n        for (int i = 0; i < length; i++) {\n            char ch = variable.charAt(i);\n            if (!ASCII.isLetter(ch))\n                throw new Error(format(\"path variable must be letter, variable={}, pattern={}\", variable, pattern));\n        }\n\n        boolean isNew = variables.add(variable);\n        if (!isNew) throw new Error(\"found duplicate param name, path=\" + pattern);\n\n        if (patternIndex > 0) {\n            String variablePattern = token.substring(patternIndex);\n            if (!\"(*)\".equals(variablePattern))\n                throw new Error(format(\"path variable must be :name or :name(*), variable={}, pattern={}\", token, pattern));\n            if (!allowWildcard)\n                throw new Error(format(\"wildcard path variable is not allowed, variable={}, pattern={}\", token, pattern));\n        }\n    }\n\n    private void validatePathSegment(String segment, String pattern) {\n        int length = segment.length();\n        if (length == 0) return;\n\n        if (segment.charAt(length - 1) == '.')\n            throw new Error(format(\"path segment must not end with '.', segment={}, pattern={}\", segment, pattern));\n\n        for (int i = 0; i < length; i++) {\n            char ch = segment.charAt(i);\n            if (ch != '_' && ch != '-' && ch != '.' && !ASCII.isLetter(ch) && !ASCII.isDigit(ch)) {\n                throw new Error(format(\"path segment must only contain (letter/digit/_/-/.), segment={}, pattern={}\", segment, pattern));\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class Route.java."}, {"role": "assistant", "content": "The source code of java class Route.java:\n```java\npackage core.framework.internal.web.route;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.internal.web.request.PathParams;\nimport core.framework.util.Maps;\nimport core.framework.web.exception.NotFoundException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic final class Route {\n    private final Logger logger = LoggerFactory.getLogger(Route.class);\n\n    private final Map<String, URLHandler> staticHandlers = Maps.newHashMap();\n    private final PathNode dynamicRoot = new PathNode(null);\n\n    public void add(HTTPMethod method, String path, ControllerHolder controller) {\n        logger.info(\"route, method={}, path={}, controller={}\", method, path, controller.controllerInfo);\n\n        URLHandler handler;\n        if (path.contains(\"/:\")) {\n            handler = dynamicRoot.register(path);\n        } else {\n            handler = staticHandlers.computeIfAbsent(path, URLHandler::new);\n        }\n        handler.put(method, controller);\n    }\n\n    public ControllerHolder get(String path, HTTPMethod method, PathParams pathParams, ActionLog actionLog) {\n        URLHandler handler = staticHandlers.get(path);\n        if (handler == null) handler = dynamicRoot.find(path, pathParams);\n        if (handler == null) {\n            throw new NotFoundException(\"not found, path=\" + path, \"PATH_NOT_FOUND\");\n        }\n        actionLog.context.put(\"path_pattern\", List.of(handler.pathPattern));\n        logger.debug(\"pathPattern={}\", handler.pathPattern);\n        return handler.get(method);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class URLHandler.java."}, {"role": "assistant", "content": "The source code of java class URLHandler.java:\n```java\npackage core.framework.internal.web.route;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.web.controller.ControllerHolder;\nimport core.framework.util.Maps;\nimport core.framework.web.exception.MethodNotAllowedException;\n\nimport java.util.Map;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\nclass URLHandler {\n    final String pathPattern;\n    private final Map<HTTPMethod, ControllerHolder> controllers = Maps.newEnumMap(HTTPMethod.class);\n\n    URLHandler(String pathPattern) {\n        this.pathPattern = pathPattern;\n    }\n\n    void put(HTTPMethod method, ControllerHolder controller) {\n        ControllerHolder previous = controllers.putIfAbsent(method, controller);\n        if (previous != null) {\n            throw new Error(format(\"found duplicate controller, path={}, method={}\", pathPattern, method));\n        }\n    }\n\n    ControllerHolder get(HTTPMethod method) {\n        ControllerHolder controller = controllers.get(method);\n        if (controller == null) {\n            throw new MethodNotAllowedException(\"method not allowed, method=\" + method);\n        }\n        return controller;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ErrorResponse.java."}, {"role": "assistant", "content": "The source code of java class ErrorResponse.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic class ErrorResponse {\n    @Property(name = \"id\")\n    public String id;\n\n    @Property(name = \"errorCode\")\n    public String errorCode;\n\n    @Property(name = \"message\")\n    public String message;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class HTTPMethods.java."}, {"role": "assistant", "content": "The source code of java class HTTPMethods.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.web.service.DELETE;\nimport core.framework.api.web.service.GET;\nimport core.framework.api.web.service.PATCH;\nimport core.framework.api.web.service.POST;\nimport core.framework.api.web.service.PUT;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.reflect.Methods;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author neo\n */\npublic class HTTPMethods {\n    public static HTTPMethod httpMethod(Method method) {\n        if (method.isAnnotationPresent(GET.class)) return HTTPMethod.GET;\n        if (method.isAnnotationPresent(POST.class)) return HTTPMethod.POST;\n        if (method.isAnnotationPresent(PUT.class)) return HTTPMethod.PUT;\n        if (method.isAnnotationPresent(DELETE.class)) return HTTPMethod.DELETE;\n        if (method.isAnnotationPresent(PATCH.class)) return HTTPMethod.PATCH;\n        throw new Error(\"unsupported http method, method=\" + Methods.path(method));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class InternalErrorResponse.java."}, {"role": "assistant", "content": "The source code of java class InternalErrorResponse.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.json.Property;\n\n/**\n * @author neo\n */\npublic class InternalErrorResponse {    // keep compatible with ErrorResponse with additional severity/stackTrace fields\n    @Property(name = \"id\")\n    public String id;\n\n    @Property(name = \"severity\")\n    public String severity;\n\n    @Property(name = \"errorCode\")\n    public String errorCode;\n\n    @Property(name = \"message\")\n    public String message;\n\n    @Property(name = \"stackTrace\")\n    public String stackTrace;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PathParamHelper.java."}, {"role": "assistant", "content": "The source code of java class PathParamHelper.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.json.JSON;\nimport core.framework.util.Encodings;\nimport core.framework.web.exception.BadRequestException;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic final class PathParamHelper {    // used by generated WebServiceController and WebServiceClient\n    public static <T extends Enum<?>> T toEnum(String value, Class<T> valueClass) {\n        try {\n            return JSON.fromEnumValue(valueClass, value);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(format(\"failed to parse enum, enumClass={}, value={}\", valueClass.getCanonicalName(), value), \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static Long toLong(String value) {\n        try {\n            return Long.valueOf(value);\n        } catch (NumberFormatException e) {\n            throw new BadRequestException(\"failed to parse long, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static Integer toInt(String value) {\n        try {\n            return Integer.valueOf(value);\n        } catch (NumberFormatException e) {\n            throw new BadRequestException(\"failed to parse int, value=\" + value, \"INVALID_HTTP_REQUEST\", e);\n        }\n    }\n\n    public static String toString(String value) {\n        return Encodings.uriComponent(value);\n    }\n\n    public static String toString(Number value) {\n        return Encodings.uriComponent(String.valueOf(value));\n    }\n\n    public static <T extends Enum<?>> String toString(T enumValue) {\n        return Encodings.uriComponent(JSON.toEnumValue(enumValue));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceClient.java."}, {"role": "assistant", "content": "The source code of java class WebServiceClient.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPClient;\nimport core.framework.http.HTTPMethod;\nimport core.framework.http.HTTPRequest;\nimport core.framework.http.HTTPResponse;\nimport core.framework.internal.http.HTTPClientImpl;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport core.framework.internal.web.HTTPHandler;\nimport core.framework.internal.web.bean.RequestBeanWriter;\nimport core.framework.internal.web.bean.ResponseBeanReader;\nimport core.framework.log.Severity;\nimport core.framework.util.Maps;\nimport core.framework.web.service.RemoteServiceException;\nimport core.framework.web.service.WebServiceClientInterceptor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class WebServiceClient {\n    public static final String USER_AGENT = \"APIClient\";\n    private static final Logger LOGGER = LoggerFactory.getLogger(WebServiceClient.class);\n    private static final Map<Integer, HTTPStatus> HTTP_STATUSES;\n\n    static {\n        HTTPStatus[] values = HTTPStatus.values();\n        HTTP_STATUSES = Maps.newHashMapWithExpectedSize(values.length);\n        for (HTTPStatus status : values) {\n            HTTP_STATUSES.put(status.code, status);\n        }\n    }\n\n    static HTTPStatus parseHTTPStatus(int statusCode) {\n        HTTPStatus status = HTTP_STATUSES.get(statusCode);\n        if (status == null) throw new Error(\"unsupported http status code, code=\" + statusCode);\n        return status;\n    }\n\n    private final String serviceURL;\n    private final HTTPClient httpClient;\n    private final RequestBeanWriter writer;\n    private final ResponseBeanReader reader;\n    private WebServiceClientInterceptor interceptor;\n\n    public WebServiceClient(String serviceURL, HTTPClient httpClient, RequestBeanWriter writer, ResponseBeanReader reader) {\n        this.serviceURL = serviceURL;\n        this.httpClient = httpClient;\n        this.writer = writer;\n        this.reader = reader;\n    }\n\n    // used by generated code, must be public\n    public <T> Object execute(HTTPMethod method, String path, Class<T> requestBeanClass, T requestBean, Type responseType) {\n        var request = new HTTPRequest(method, serviceURL + path);\n        request.accept(ContentType.APPLICATION_JSON);\n        linkContext(request);\n\n        if (requestBeanClass != null) {\n            putRequestBean(request, requestBeanClass, requestBean);\n        }\n\n        if (interceptor != null) {\n            LOGGER.debug(\"interceptor={}\", interceptor.getClass().getCanonicalName());\n            interceptor.onRequest(request);\n        }\n        HTTPResponse response = httpClient.execute(request);\n        if (interceptor != null) {\n            interceptor.onResponse(response);\n        }\n\n        validateResponse(response);\n        try {\n            return reader.fromJSON(responseType, response.body);\n        } catch (IOException e) {\n            // for security concern, to hide original error message, jackson may return detailed info, e.g. possible allowed values for enum\n            // detailed info can still be found in trace log or exception stack trace\n            throw new UncheckedIOException(\"failed to deserialize remote service response, responseType=\" + responseType.getTypeName(), e);\n        }\n    }\n\n    // used by generated code, must be public\n    public void intercept(WebServiceClientInterceptor interceptor) {\n        if (this.interceptor != null) throw new Error(\"found duplicate interceptor, previous=\" + this.interceptor.getClass().getCanonicalName());\n        this.interceptor = interceptor;\n    }\n\n    // used by generated code, must be public\n    public void logCallWebService(String method) {\n        LOGGER.debug(\"call web service, method={}\", method);\n    }\n\n    <T> void putRequestBean(HTTPRequest request, Class<T> requestBeanClass, T requestBean) {\n        HTTPMethod method = request.method;\n        if (method == HTTPMethod.GET || method == HTTPMethod.DELETE) {\n            Map<String, String> queryParams = writer.toParams(requestBeanClass, requestBean);\n            request.params.putAll(queryParams);\n        } else if (method == HTTPMethod.POST || method == HTTPMethod.PUT || method == HTTPMethod.PATCH) {\n            byte[] json = writer.toJSON(requestBeanClass, requestBean);\n            request.body(json, ContentType.APPLICATION_JSON);\n        } else {\n            throw new Error(\"not supported method, method=\" + method);\n        }\n    }\n\n    void linkContext(HTTPRequest request) {\n        Map<String, String> headers = request.headers;\n        headers.put(HTTPHandler.HEADER_CLIENT.toString(), LogManager.APP_NAME);\n\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        if (actionLog == null) return;  // web service client may be used without action log context\n\n        headers.put(HTTPHandler.HEADER_CORRELATION_ID.toString(), actionLog.correlationId());\n        if (actionLog.trace == Trace.CASCADE) headers.put(HTTPHandler.HEADER_TRACE.toString(), actionLog.trace.name());\n        headers.put(HTTPHandler.HEADER_REF_ID.toString(), actionLog.id);\n\n        long timeout = ((HTTPClientImpl) httpClient).timeoutInNano; // not count connect timeout, as action starts after connecting\n        long remainingTime = actionLog.remainingProcessTimeInNano();\n        if (remainingTime > 0 && remainingTime < timeout) timeout = remainingTime;  // if remaining time is 0, means current action already triggered LONG_PROCESS, no need to propagate to child actions, to reduce unnecessary trace\n        headers.put(HTTPHandler.HEADER_TIMEOUT.toString(), String.valueOf(timeout));\n    }\n\n    void validateResponse(HTTPResponse response) {\n        int statusCode = response.statusCode;\n        if (statusCode >= 200 && statusCode < 300) return;\n\n        // handle empty body gracefully, e.g. 503 during deployment\n        // handle html error message gracefully, e.g. public cloud LB failed to connect to backend\n        if (response.body.length > 0 && response.contentType != null && ContentType.APPLICATION_JSON.mediaType.equals(response.contentType.mediaType)) {\n            InternalErrorResponse error = errorResponse(response);\n            if (error.id != null && error.errorCode != null) {  // use manual validation rather than annotation to keep the flow straightforward and less try/catch, check if valid error response json\n                LOGGER.debug(\"failed to call remote service, statusCode={}, id={}, severity={}, errorCode={}, remoteStackTrace={}\", statusCode, error.id, error.severity, error.errorCode, error.stackTrace);\n                throw new RemoteServiceException(error.message, parseSeverity(error.severity), error.errorCode, parseHTTPStatus(statusCode));\n            }\n        }\n        throw new RemoteServiceException(\"failed to call remote service, statusCode=\" + statusCode, Severity.ERROR, \"REMOTE_SERVICE_ERROR\", parseHTTPStatus(statusCode));\n    }\n\n    private InternalErrorResponse errorResponse(HTTPResponse response) {\n        try {\n            return (InternalErrorResponse) reader.fromJSON(InternalErrorResponse.class, response.body);\n        } catch (Throwable e) {\n            int statusCode = response.statusCode;\n            throw new RemoteServiceException(\"failed to deserialize remote service error response, statusCode=\" + statusCode, Severity.ERROR, \"REMOTE_SERVICE_ERROR\", parseHTTPStatus(statusCode), e);\n        }\n    }\n\n    private Severity parseSeverity(String severity) {\n        if (severity == null) return Severity.ERROR;\n        return Severity.valueOf(severity);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceClientBuilder.java."}, {"role": "assistant", "content": "The source code of java class WebServiceClientBuilder.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Methods;\nimport core.framework.internal.reflect.Params;\nimport core.framework.util.Maps;\nimport core.framework.web.service.WebServiceClientInterceptor;\nimport core.framework.web.service.WebServiceClientProxy;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Map;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.internal.asm.Literal.variable;\n\n/**\n * @author neo\n */\npublic class WebServiceClientBuilder<T> {\n    final DynamicInstanceBuilder<T> builder;\n    private final Class<T> serviceInterface;\n    private final WebServiceClient client;\n\n    public WebServiceClientBuilder(Class<T> serviceInterface, WebServiceClient client) {\n        this.serviceInterface = serviceInterface;\n        this.client = client;\n        builder = new DynamicInstanceBuilder<>(serviceInterface, \"Client\");\n    }\n\n    public T build() {\n        builder.addField(\"private final {} client;\", type(WebServiceClient.class));\n        builder.constructor(new Class<?>[]{WebServiceClient.class}, \"this.client = $1;\");\n\n        Method[] methods = serviceInterface.getMethods();\n        Arrays.sort(methods, Comparator.comparing(Method::getName));    // to make generated code deterministic\n        for (Method method : methods) {\n            builder.addMethod(buildImplMethod(method));\n        }\n\n        // all client will impl proxy interface to additional configuration\n        builder.addInterface(WebServiceClientProxy.class);\n        builder.addMethod(buildInterceptMethod());\n\n        return builder.build(client);\n    }\n\n    private String buildInterceptMethod() {\n        var builder = new CodeBuilder();\n        builder.append(\"public void intercept({} interceptor) {\\n\", type(WebServiceClientInterceptor.class))\n            .indent(1).append(\"client.intercept(interceptor);\\n\")\n            .append(\"}\");\n        return builder.build();\n    }\n\n    private String buildImplMethod(Method method) {\n        var builder = new CodeBuilder();\n\n        Type returnType = method.getGenericReturnType();\n        Class<?> returnClass = method.getReturnType();\n\n        Map<String, Integer> pathParamIndexes = Maps.newHashMap();\n        Class<?> requestBeanClass = null;\n        Integer requestBeanIndex = null;\n        builder.append(\"public {} {}(\", type(returnClass), method.getName());\n        Annotation[][] annotations = method.getParameterAnnotations();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            Class<?> paramClass = parameterTypes[i];\n            if (i > 0) builder.append(\", \");\n            builder.append(\"{} param{}\", type(paramClass), i);\n\n            PathParam pathParam = Params.annotation(annotations[i], PathParam.class);\n            if (pathParam != null) {\n                pathParamIndexes.put(pathParam.value(), i);\n            } else {\n                requestBeanIndex = i;\n                requestBeanClass = paramClass;\n            }\n        }\n        builder.append(\") {\\n\");\n        builder.indent(1).append(\"client.logCallWebService({});\\n\", variable(Methods.path(method)));\n\n        buildPath(builder, method.getDeclaredAnnotation(Path.class).value(), pathParamIndexes);\n        builder.indent(1).append(\"Class requestBeanClass = {};\\n\", requestBeanClass == null ? \"null\" : variable(requestBeanClass));\n        builder.indent(1).append(\"Object requestBean = {};\\n\", requestBeanIndex == null ? \"null\" : \"param\" + requestBeanIndex);\n\n        builder.indent(1);\n        if (returnType != void.class) builder.append(\"return ({}) \", type(returnClass));\n        builder.append(\"client.execute({}, path, requestBeanClass, requestBean, {});\\n\", variable(HTTPMethods.httpMethod(method)), variable(returnType));\n\n        builder.append(\"}\");\n        return builder.build();\n    }\n\n    void buildPath(CodeBuilder builder, String path, Map<String, Integer> pathParamIndexes) {\n        if (pathParamIndexes.isEmpty()) {\n            builder.indent(1).append(\"String path = {};\\n\", variable(path)); // to pass path as string literal, not escaping char, like \\\\ which is not allowed, refer to core.framework.internal.web.route.PathPatternValidator\n        } else {\n            for (Map.Entry<String, Integer> entry : pathParamIndexes.entrySet()) {\n                builder.indent(1).append(\"if (param{} == null) throw new Error(\\\"path param must not be null, name={}\\\");\\n\", entry.getValue(), entry.getKey());\n            }\n\n            builder.indent(1).append(\"StringBuilder builder = new StringBuilder();\\n\");\n            int currentIndex = 0;\n            while (true) {\n                int variableStart = path.indexOf(':', currentIndex);\n                if (variableStart < 0) break;\n                int variableEnd = path.indexOf('/', variableStart);\n                if (variableEnd < 0) variableEnd = path.length();\n                builder.indent(1).append(\"builder.append({}).append({}.toString(param{}));\\n\", variable(path.substring(currentIndex, variableStart)),\n                    type(PathParamHelper.class), pathParamIndexes.get(path.substring(variableStart + 1, variableEnd)));\n                currentIndex = variableEnd;\n            }\n            if (currentIndex < path.length()) {\n                builder.indent(1).append(\"builder.append({});\\n\", variable(path.substring(currentIndex)));\n            }\n            builder.indent(1).append(\"String path = builder.toString();\\n\");\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceController.java."}, {"role": "assistant", "content": "The source code of java class WebServiceController.java:\n```java\npackage core.framework.internal.web.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic final class WebServiceController {\n    private static final Logger LOGGER = LoggerFactory.getLogger(WebServiceController.class);\n\n    // used by generated class, must be public\n    public static void logDeprecation(String method) {\n        LOGGER.warn(errorCode(\"DEPRECATION\"), \"web service has been deprecated, please notify consumer to update, method={}\", method);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceControllerBuilder.java."}, {"role": "assistant", "content": "The source code of java class WebServiceControllerBuilder.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.web.service.PathParam;\nimport core.framework.api.web.service.ResponseStatus;\nimport core.framework.internal.asm.CodeBuilder;\nimport core.framework.internal.asm.DynamicInstanceBuilder;\nimport core.framework.internal.reflect.Methods;\nimport core.framework.internal.reflect.Params;\nimport core.framework.web.Controller;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static core.framework.internal.asm.Literal.type;\nimport static core.framework.internal.asm.Literal.variable;\n\n/**\n * @author neo\n */\npublic class WebServiceControllerBuilder<T> {\n    final DynamicInstanceBuilder<Controller> builder;\n    private final Class<T> serviceInterface;\n    private final T service;\n    private final Method method;\n\n    public WebServiceControllerBuilder(Class<T> serviceInterface, T service, Method method) {\n        this.serviceInterface = serviceInterface;\n        this.service = service;\n        this.method = method;\n        builder = new DynamicInstanceBuilder<>(Controller.class, service.getClass().getSimpleName() + \"$\" + method.getName());\n    }\n\n    public Controller build() {\n        builder.addField(\"private final {} delegate;\", type(serviceInterface));\n        builder.constructor(new Class<?>[]{serviceInterface}, \"this.delegate = $1;\");\n\n        boolean deprecated = method.isAnnotationPresent(Deprecated.class);\n        builder.addMethod(buildMethod(deprecated));\n\n        return builder.build(service);\n    }\n\n    private String buildMethod(boolean deprecated) {\n        var builder = new CodeBuilder();\n        builder.append(\"public {} execute({} request) throws Exception {\\n\", type(Response.class), type(Request.class));\n\n        if (deprecated) builder.indent(1).append(\"{}.logDeprecation({});\\n\", type(WebServiceController.class), variable(Methods.path(method)));\n\n        Annotation[][] annotations = method.getParameterAnnotations();\n        List<String> params = new ArrayList<>(annotations.length);\n        Class<?>[] paramClasses = method.getParameterTypes();\n        for (int i = 0; i < annotations.length; i++) {\n            Class<?> paramClass = paramClasses[i];\n            String paramClassLiteral = type(paramClass);\n            PathParam pathParam = Params.annotation(annotations[i], PathParam.class);\n            if (pathParam != null) {\n                params.add(\"$\" + pathParam.value());\n                if (String.class.equals(paramClass)) {\n                    builder.indent(1).append(\"String ${} = request.pathParam(\\\"{}\\\");\\n\", pathParam.value(), pathParam.value());\n                } else if (Integer.class.equals(paramClass)) {\n                    builder.indent(1).append(\"Integer ${} = {}.toInt(request.pathParam(\\\"{}\\\"));\\n\", pathParam.value(), type(PathParamHelper.class), pathParam.value());\n                } else if (Long.class.equals(paramClass)) {\n                    builder.indent(1).append(\"Long ${} = {}.toLong(request.pathParam(\\\"{}\\\"));\\n\", pathParam.value(), type(PathParamHelper.class), pathParam.value());\n                } else if (paramClass.isEnum()) {\n                    builder.indent(1).append(\"{} ${} = ({}){}.toEnum(request.pathParam(\\\"{}\\\"), {});\\n\", paramClassLiteral, pathParam.value(), paramClassLiteral, type(PathParamHelper.class), pathParam.value(), variable(paramClass));\n                } else {\n                    throw new Error(\"not supported path param type, type=\" + paramClass.getCanonicalName());\n                }\n            } else {\n                params.add(\"bean\");\n                builder.indent(1).append(\"{} bean = ({}) request.bean({});\\n\", paramClassLiteral, paramClassLiteral, variable(paramClass));\n            }\n        }\n\n        if (void.class == method.getReturnType()) {\n            builder.indent(1).append(\"delegate.{}(\", method.getName());\n        } else {\n            builder.indent(1).append(\"{} response = delegate.{}(\", type(method.getReturnType()), method.getName());\n        }\n        builder.appendCommaSeparatedValues(params).append(\");\\n\");\n\n        if (void.class == method.getReturnType()) {\n            builder.indent(1).append(\"return {}.empty()\", type(Response.class));\n        } else {\n            builder.indent(1).append(\"return {}.bean(response)\", type(Response.class));\n        }\n\n        ResponseStatus status = method.getDeclaredAnnotation(ResponseStatus.class);\n        if (status == null) {\n            builder.append(\";\\n\");\n        } else {\n            builder.append(\".status({});\\n\", variable(status.value()));\n        }\n\n        builder.append(\"}\");\n        return builder.build();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceImplValidator.java."}, {"role": "assistant", "content": "The source code of java class WebServiceImplValidator.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.web.service.PathParam;\nimport core.framework.internal.reflect.Methods;\nimport core.framework.internal.reflect.Params;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class WebServiceImplValidator<T> {\n    private final Class<T> serviceInterface;\n    private final T service;\n\n    public WebServiceImplValidator(Class<T> serviceInterface, T service) {\n        this.serviceInterface = serviceInterface;\n        this.service = service;\n    }\n\n    public void validate() {\n        if (!serviceInterface.isInstance(service))\n            throw new Error(format(\"service must impl service interface, serviceInterface={}, instance={}\", serviceInterface.getCanonicalName(), service));\n\n        Class<?> serviceClass = service.getClass();\n\n        if (!Object.class.equals(serviceClass.getSuperclass())) {\n            throw new Error(\"service impl class must not have super class, class=\" + serviceClass.getCanonicalName());\n        }\n\n        for (Method method : serviceInterface.getDeclaredMethods()) {\n            Class<?>[] parameterTypes = method.getParameterTypes();\n            try {\n                Method serviceMethod = serviceClass.getMethod(method.getName(), parameterTypes);\n                validateMethod(serviceMethod);\n            } catch (NoSuchMethodException e) {\n                throw new Error(\"failed to find impl method\", e);\n            }\n        }\n    }\n\n    private void validateMethod(Method method) {\n        Annotation[][] annotations = method.getParameterAnnotations();\n        for (Annotation[] parameterAnnotations : annotations) {\n            PathParam pathParam = Params.annotation(parameterAnnotations, PathParam.class);\n            if (pathParam != null) {\n                throw new Error(\"service impl must not have @PathParam, method=\" + Methods.path(method));\n            }\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebServiceInterfaceValidator.java."}, {"role": "assistant", "content": "The source code of java class WebServiceInterfaceValidator.java:\n```java\npackage core.framework.internal.web.service;\n\nimport core.framework.api.web.service.DELETE;\nimport core.framework.api.web.service.GET;\nimport core.framework.api.web.service.PATCH;\nimport core.framework.api.web.service.POST;\nimport core.framework.api.web.service.PUT;\nimport core.framework.api.web.service.Path;\nimport core.framework.api.web.service.PathParam;\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.bean.BeanClassValidator;\nimport core.framework.internal.json.JSONClassValidator;\nimport core.framework.internal.reflect.GenericTypes;\nimport core.framework.internal.reflect.Methods;\nimport core.framework.internal.reflect.Params;\nimport core.framework.internal.web.bean.RequestBeanReader;\nimport core.framework.internal.web.bean.RequestBeanWriter;\nimport core.framework.internal.web.bean.ResponseBeanReader;\nimport core.framework.internal.web.bean.ResponseBeanWriter;\nimport core.framework.internal.web.route.PathPatternValidator;\nimport core.framework.util.Maps;\nimport core.framework.util.Sets;\nimport core.framework.util.Strings;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class WebServiceInterfaceValidator {\n    private final Class<?> serviceInterface;\n    private final BeanClassValidator validator;\n    public RequestBeanReader requestBeanReader;\n    public RequestBeanWriter requestBeanWriter;\n    public ResponseBeanReader responseBeanReader;\n    public ResponseBeanWriter responseBeanWriter;\n\n    public WebServiceInterfaceValidator(Class<?> serviceInterface, BeanClassValidator validator) {\n        this.serviceInterface = serviceInterface;\n        this.validator = validator;\n    }\n\n    public void validate() {\n        if (!serviceInterface.isInterface())\n            throw new Error(\"service interface must be interface, serviceInterface=\" + serviceInterface.getCanonicalName());\n\n//        validator.beanClassNameValidator.validate(serviceInterface);\n\n        Map<String, Method> methodNames = Maps.newHashMap();\n        for (Method method : serviceInterface.getDeclaredMethods()) {\n            Method previous = methodNames.put(method.getName(), method);\n            if (previous != null) {\n                throw new Error(format(\"found duplicate method name which can be confusing, please use different method name, method={}, previous={}\", Methods.path(method), Methods.path(previous)));\n            }\n            validate(method);\n        }\n    }\n\n    private void validate(Method method) {\n        validateHTTPMethod(method);\n\n        HTTPMethod httpMethod = HTTPMethods.httpMethod(method);\n\n        Path path = method.getDeclaredAnnotation(Path.class);\n        if (path == null) throw new Error(\"service method must have @Path, method=\" + Methods.path(method));\n        new PathPatternValidator(path.value(), false).validate();\n\n        validateResponseBeanType(method.getGenericReturnType(), method);\n\n        Set<String> pathVariables = pathVariables(path.value(), method);\n        Class<?> requestBeanClass = null;\n\n        Annotation[][] annotations = method.getParameterAnnotations();\n        Type[] paramTypes = method.getGenericParameterTypes();\n        Set<String> pathParams = Sets.newHashSet();\n\n        for (int i = 0; i < paramTypes.length; i++) {\n            Type paramType = paramTypes[i];\n            PathParam pathParam = Params.annotation(annotations[i], PathParam.class);\n            if (pathParam != null) {\n                validatePathParamType(paramType, method);\n                pathParams.add(pathParam.value());\n            } else {\n                if (requestBeanClass != null)\n                    throw new Error(format(\"service method must not have more than one bean param, previous={}, current={}, method={}\", requestBeanClass.getTypeName(), paramType.getTypeName(), Methods.path(method)));\n                requestBeanClass = GenericTypes.rawClass(paramType);\n\n                validateRequestBeanClass(requestBeanClass, method);\n\n                if (httpMethod == HTTPMethod.GET || httpMethod == HTTPMethod.DELETE) {\n                    registerQueryParam(requestBeanClass);\n                } else {\n                    registerBean(requestBeanClass);\n                }\n            }\n        }\n\n        if (pathVariables.size() != pathParams.size() || !pathVariables.containsAll(pathParams))\n            throw new Error(format(\"service method @PathParam params must match variable in path pattern, path={}, method={}\", path.value(), Methods.path(method)));\n    }\n\n    private void registerBean(Class<?> requestBeanClass) {\n        if (requestBeanReader != null) requestBeanReader.registerBean(requestBeanClass, validator);\n        if (requestBeanWriter != null) requestBeanWriter.registerBean(requestBeanClass, validator);\n    }\n\n    private void registerQueryParam(Class<?> requestBeanClass) {\n        if (requestBeanReader != null) requestBeanReader.registerQueryParam(requestBeanClass, validator.beanClassNameValidator);\n        if (requestBeanWriter != null) requestBeanWriter.registerQueryParam(requestBeanClass, validator.beanClassNameValidator);\n    }\n\n    void validateRequestBeanClass(Class<?> beanClass, Method method) {    // due to it's common to forget @PathParam in service method param, this is to make error message more friendly\n        boolean isValueType = isValueType(beanClass);\n        if (isValueType)\n            throw new Error(format(\"request bean type must be bean class, if it is path param, please add @PathParam, type={}, method={}\", beanClass.getCanonicalName(), Methods.path(method)));\n    }\n\n    private Set<String> pathVariables(String path, Method method) {\n        Set<String> names = Sets.newHashSet();\n        String[] tokens = Strings.split(path, '/');\n        for (String token : tokens) {\n            if (Strings.startsWith(token, ':')) {\n                int paramIndex = token.indexOf('(');\n                int endIndex = paramIndex > 0 ? paramIndex : token.length();\n                boolean isNew = names.add(token.substring(1, endIndex));\n                if (!isNew) throw new Error(format(\"path must not have duplicate param name, path={}, method={}\", path, Methods.path(method)));\n            }\n        }\n        return names;\n    }\n\n    private void validatePathParamType(Type paramType, Method method) {\n        if (!(paramType instanceof Class<?> paramClass))\n            throw new Error(format(\"path param must be class type, type={}, method={}\", paramType.getTypeName(), Methods.path(method)));\n\n        if (paramClass.isPrimitive())\n            throw new Error(format(\"primitive class is not supported, please use object class, paramClass={}, method={}\", paramClass, Methods.path(method)));\n\n        if (Integer.class.equals(paramClass)) return;\n        if (Long.class.equals(paramClass)) return;\n        if (String.class.equals(paramClass)) return;\n        if (paramClass.isEnum()) {\n            JSONClassValidator.validateEnum(paramClass);\n            return;\n        }\n        throw new Error(format(\"path param class is not supported, paramClass={}, method={}\", paramClass.getCanonicalName(), Methods.path(method)));\n    }\n\n    void validateResponseBeanType(Type beanType, Method method) {\n        if (void.class == beanType) return;\n\n        // due to it is common to return wrong type as response, this is to make error message more friendly\n        boolean isGenericButNotOptional = beanType instanceof ParameterizedType && !GenericTypes.isGenericOptional(beanType);\n        boolean isValueType = beanType instanceof Class<?> classType && isValueType(classType);\n        if (isGenericButNotOptional || isValueType)\n            throw new Error(format(\"response bean type must be bean class or Optional<T>, type={}, method={}\", beanType.getTypeName(), Methods.path(method)));\n\n        if (responseBeanWriter != null) responseBeanWriter.register(beanType, validator);\n        if (responseBeanReader != null) responseBeanReader.register(beanType, validator);\n    }\n\n    private void validateHTTPMethod(Method method) {\n        int count = 0;\n        if (method.isAnnotationPresent(GET.class)) count++;\n        if (method.isAnnotationPresent(POST.class)) count++;\n        if (method.isAnnotationPresent(PUT.class)) count++;\n        if (method.isAnnotationPresent(DELETE.class)) count++;\n        if (method.isAnnotationPresent(PATCH.class)) count++;\n        if (count != 1)\n            throw new Error(\"method must have exact one http method annotation, method=\" + Methods.path(method));\n    }\n\n    private boolean isValueType(Class<?> type) {\n        return type.isPrimitive() || type.getPackageName().startsWith(\"java\") || type.isEnum();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class LocalSessionStore.java."}, {"role": "assistant", "content": "The source code of java class LocalSessionStore.java:\n```java\npackage core.framework.internal.web.session;\n\n\nimport core.framework.util.Maps;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class LocalSessionStore implements SessionStore {\n    final Map<String, SessionValue> values = Maps.newConcurrentHashMap();\n\n    private final Logger logger = LoggerFactory.getLogger(LocalSessionStore.class);\n\n    @Override\n    public Map<String, String> getAndRefresh(String sessionId, String domain, Duration timeout) {\n        SessionValue sessionValue = values.get(sessionId);\n        if (sessionValue == null) return null;\n\n        if (Instant.now().isAfter(sessionValue.expirationTime)) {\n            values.remove(sessionId);\n            return null;\n        }\n\n        Map<String, String> sessionValues = sessionValue.values;\n        values.put(sessionId, new SessionValue(expirationTime(timeout), sessionValues));\n        return sessionValues;\n    }\n\n    @Override\n    public void save(String sessionId, String domain, Map<String, String> values, Set<String> changedFields, Duration timeout) {\n        Map<String, String> updatedValues = Maps.newHashMapWithExpectedSize(values.size());\n        values.forEach((field, value) -> {\n            if (value != null) updatedValues.put(field, value);\n        });\n        this.values.put(sessionId, new SessionValue(expirationTime(timeout), updatedValues));\n    }\n\n    @Override\n    public void invalidate(String sessionId, String domain) {\n        values.remove(sessionId);\n    }\n\n    @Override\n    public void invalidateByKey(String key, String value) {\n        values.values().removeIf(session -> Strings.equals(value, session.values.get(key)));\n    }\n\n    private Instant expirationTime(Duration sessionTimeout) {\n        return Instant.now().plus(sessionTimeout);\n    }\n\n    public void cleanup() {\n        logger.info(\"cleanup local session store\");\n        Instant now = Instant.now();\n        values.values().removeIf(session -> now.isAfter(session.expirationTime));\n    }\n\n    static class SessionValue {\n        final Instant expirationTime;\n        final Map<String, String> values;\n\n        SessionValue(Instant expirationTime, Map<String, String> values) {\n            this.expirationTime = expirationTime;\n            this.values = values;\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class RedisSessionStore.java."}, {"role": "assistant", "content": "The source code of java class RedisSessionStore.java:\n```java\npackage core.framework.internal.web.session;\n\nimport core.framework.crypto.Hash;\nimport core.framework.internal.redis.RedisException;\nimport core.framework.redis.Redis;\nimport core.framework.util.Lists;\nimport core.framework.util.Maps;\nimport core.framework.util.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.log.Markers.errorCode;\n\n/**\n * @author neo\n */\npublic class RedisSessionStore implements SessionStore {\n    private final Logger logger = LoggerFactory.getLogger(RedisSessionStore.class);\n\n    private final Redis redis;\n\n    public RedisSessionStore(Redis redis) {\n        this.redis = redis;\n    }\n\n    @Override\n    public Map<String, String> getAndRefresh(String sessionId, String domain, Duration timeout) {\n        String key = sessionKey(sessionId, domain);\n        try {\n            Map<String, String> sessionValues = redis.hash().getAll(key);\n            if (sessionValues.isEmpty()) return null;\n            redis.expire(key, timeout);\n            return sessionValues;\n        } catch (RedisException e) {\n            // gracefully handle invalid data in redis, either legacy old format value, or invalid value/key type inserted manually,\n            logger.warn(errorCode(\"INVALID_SESSION_VALUE\"), \"failed to get redis session values\", e);\n            return null;\n        }\n    }\n\n    @Override\n    public void save(String sessionId, String domain, Map<String, String> values, Set<String> changedFields, Duration timeout) {\n        String key = sessionKey(sessionId, domain);\n\n        List<String> deletedFields = Lists.newArrayList();\n        Map<String, String> updatedValues = Maps.newHashMap();\n        for (String changedSessionField : changedFields) {\n            String value = values.get(changedSessionField);\n            if (value == null) deletedFields.add(changedSessionField);\n            else updatedValues.put(changedSessionField, value);\n        }\n        if (!deletedFields.isEmpty()) redis.hash().del(key, deletedFields.toArray(new String[0]));\n        if (!updatedValues.isEmpty()) redis.hash().multiSet(key, updatedValues);\n        redis.expire(key, timeout);\n    }\n\n    @Override\n    public void invalidate(String sessionId, String domain) {\n        String key = sessionKey(sessionId, domain);\n        redis.del(key);\n    }\n\n    // use naive solution, generally invalidate by key/value is used to kick out login user, it happens rarely and will be handled by message handler which is in background\n    @Override\n    public void invalidateByKey(String key, String value) {\n        redis.forEach(\"session:*\", sessionKey -> {\n            String valueInSession = redis.hash().get(sessionKey, key);\n            if (Strings.equals(value, valueInSession)) {\n                redis.del(sessionKey);\n            }\n        });\n    }\n\n    // make sure sessionId can only be used for specific domain, as different webapp may share one session redis, this way to prevent session hijacking by manually reuse sessionId from one site to another\n    String sessionKey(String sessionId, String domain) {\n        return \"session:\" + Hash.sha256Hex(domain + \":\" + sessionId);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SessionImpl.java."}, {"role": "assistant", "content": "The source code of java class SessionImpl.java:\n```java\npackage core.framework.internal.web.session;\n\nimport core.framework.crypto.Hash;\nimport core.framework.util.Strings;\nimport core.framework.web.Session;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic class SessionImpl implements Session {\n    final Map<String, String> values = new HashMap<>();\n    final Set<String> changedFields = new HashSet<>();\n    final String domain;\n    String id;\n    // used to track current session, without exposing actual session id value\n    // redis session store use sha256(domain+sessionId) to hash, here to use md5 to make sure not logging actual redis key, and keep reference shorter\n    String hash;\n    boolean invalidated;\n    boolean saved;\n\n    public SessionImpl(String domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public Optional<String> get(String key) {\n        return Optional.ofNullable(values.get(key));\n    }\n\n    @Override\n    public void set(String key, String value) {\n        String previousValue = values.put(key, value);\n        if (!Strings.equals(previousValue, value)) {\n            changedFields.add(key);\n        }\n    }\n\n    @Override\n    public void invalidate() {\n        invalidated = true;\n    }\n\n    void id(String id) {\n        this.id = id;\n        hash = Hash.md5Hex(id);\n    }\n\n    boolean changed() {\n        return !changedFields.isEmpty();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SessionManager.java."}, {"role": "assistant", "content": "The source code of java class SessionManager.java:\n```java\npackage core.framework.internal.web.session;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.web.request.RequestImpl;\nimport core.framework.web.CookieSpec;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport core.framework.web.Session;\nimport core.framework.web.SessionContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\n\n/**\n * @author neo\n */\npublic class SessionManager implements SessionContext {\n    private final Logger logger = LoggerFactory.getLogger(SessionManager.class);\n    private CookieSpec cookieSpec;\n    private String header;\n    private Duration timeout = Duration.ofMinutes(20);\n    private SessionStore store;\n\n    public Session load(Request request, ActionLog actionLog) {\n        if (store == null) return null;  // session store is not initialized\n        if (!\"https\".equals(request.scheme())) return null;  // only load session under https\n\n        String domain = domain(request);\n        var session = new SessionImpl(domain);\n        sessionId(request).ifPresent(sessionId -> {\n            Map<String, String> values = store.getAndRefresh(sessionId, session.domain, timeout);\n            if (values != null) {\n                session.id(sessionId);\n                actionLog.context.put(\"session_hash\", List.of(session.hash));\n                session.values.putAll(values);\n            }\n            logger.debug(\"load session, domain={}, sessionHash={}\", domain, session.hash);  // session.hash can be null if session is not found\n        });\n        return session;\n    }\n\n    public void save(RequestImpl request, Response response, ActionLog actionLog) {\n        // request.session can be null or ReadOnlySession for websocket, only regular http request may generate session\n        if (request.session instanceof SessionImpl session && !session.saved) {\n            save(session, response, actionLog);\n        }\n    }\n\n    private void save(SessionImpl session, Response response, ActionLog actionLog) {\n        session.saved = true;   // it will try to save session on both normal and exception flows, here is to only attempt once in case of store throws exception\n        if (session.invalidated) {\n            if (session.id != null) {\n                logger.debug(\"invalidate session, domain={}, sessionHash={}\", session.domain, session.hash);\n                store.invalidate(session.id, session.domain);\n                putSessionId(response, null);\n            }\n        } else if (session.changed()) {\n            if (session.id == null) {\n                session.id(UUID.randomUUID().toString());\n                actionLog.context.put(\"session_hash\", List.of(session.hash));\n                putSessionId(response, session.id);\n            }\n            logger.debug(\"save session, domain={}, sessionHash={}\", session.domain, session.hash);\n            store.save(session.id, session.domain, session.values, session.changedFields, timeout);\n        }\n    }\n\n    private Optional<String> sessionId(Request request) {\n        if (header != null) return request.header(header);\n        return request.cookie(cookieSpec);\n    }\n\n    String domain(Request request) {\n        // if header is specified, always use current host, otherwise use cookieSpec.domain if specified\n        // for header/api scenario, there is no way to share sessionId across multiple apps, so always use request.host\n        // for cookie/web scenario, only case to share session cookie is to have multiple sub-domain webapps, thus use cookieSpec.domain (usually parent domain)\n        // share sessionId requires multiple webapps decode session key/values consistently, which adds extra complexity for dev/deployment\n        if (header == null && cookieSpec.domain != null)\n            return cookieSpec.domain;\n        return request.hostname();\n    }\n\n    void putSessionId(Response response, String sessionId) {\n        if (header != null) {\n            response.header(header, sessionId == null ? \"\" : sessionId);\n        } else {\n            response.cookie(cookieSpec, sessionId);\n        }\n    }\n\n    public void store(SessionStore store) {\n        if (this.store != null) throw new Error(\"session store is already configured, previous=\" + this.store);\n        this.store = store;\n    }\n\n    public void timeout(Duration timeout) {\n        if (timeout == null) throw new Error(\"timeout must not be null\");\n        this.timeout = timeout;\n    }\n\n    public void cookie(String name, String domain) {\n        if (name == null) throw new Error(\"name must not be null\");\n        // path must be /, refer to https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.2.4\n        cookieSpec = new CookieSpec(name).domain(domain).path(\"/\").sessionScope().httpOnly().secure().sameSite();\n    }\n\n    public void header(String name) {\n        if (name == null) throw new Error(\"name must not be null\");\n        header = name;\n    }\n\n    @Override\n    public void invalidate(String key, String value) {\n        if (store == null) throw new Error(\"site().session() must be configured\");\n        if (key == null || value == null) throw new Error(\"key/value must not be null\");   // to prevent from invalidating all sessions miss this key\n        store.invalidateByKey(key, value);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SessionStore.java."}, {"role": "assistant", "content": "The source code of java class SessionStore.java:\n```java\npackage core.framework.internal.web.session;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author neo\n */\npublic interface SessionStore {\n    Map<String, String> getAndRefresh(String sessionId, String domain, Duration timeout);\n\n    void save(String sessionId, String domain, Map<String, String> values, Set<String> changedFields, Duration timeout);\n\n    void invalidate(String sessionId, String domain);\n\n    void invalidateByKey(String key, String value);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ShutdownHandler.java."}, {"role": "assistant", "content": "The source code of java class ShutdownHandler.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.stat.Counter;\nimport io.undertow.server.ExchangeCompletionListener;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.StatusCodes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author neo\n */\npublic class ShutdownHandler implements ExchangeCompletionListener {\n    final Counter activeRequests = new Counter();\n\n    private final Logger logger = LoggerFactory.getLogger(ShutdownHandler.class);\n    private final Object lock = new Object();\n    private volatile boolean shutdown;\n\n    boolean handle(HttpServerExchange exchange) {\n        activeRequests.increase();\n        exchange.addExchangeCompleteListener(this);\n\n        if (shutdown) {\n            logger.warn(\"reject request due to server is shutting down, requestURL={}\", exchange.getRequestURL());\n            // ask client not set keep alive for current connection, with persistent=false, undertow will send header \"connection: close\",\n            // this does no effect with http/2.0, only for http/1.1\n            // refer to io.undertow.server.protocol.http.HttpTransferEncoding.createSinkConduit\n            exchange.setPersistent(false);\n            exchange.setStatusCode(StatusCodes.SERVICE_UNAVAILABLE);\n            exchange.endExchange();\n            return true;\n        }\n\n        return false;\n    }\n\n    void shutdown() {\n        shutdown = true;\n    }\n\n    boolean awaitTermination(long timeoutInMs) throws InterruptedException {\n        long end = System.currentTimeMillis() + timeoutInMs;\n        synchronized (lock) {\n            while (activeRequests.get() > 0) {\n                long left = end - System.currentTimeMillis();\n                if (left <= 0) {\n                    return false;\n                }\n                lock.wait(left);\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public void exchangeEvent(HttpServerExchange exchange, NextListener next) {\n        try {\n            int count = activeRequests.decrease();\n            if (count <= 0 && shutdown) {\n                synchronized (lock) {\n                    lock.notifyAll();\n                }\n            }\n        } finally {\n            next.proceed();\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MessageImpl.java."}, {"role": "assistant", "content": "The source code of java class MessageImpl.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.log.Markers;\nimport core.framework.util.Maps;\nimport core.framework.util.Properties;\nimport core.framework.util.Sets;\nimport core.framework.util.Strings;\nimport core.framework.web.site.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class MessageImpl implements Message {\n    static final String DEFAULT_LANGUAGE = \"_default\";\n    private static final Pattern MESSAGE_PROPERTY_PATH_PATTERN = Pattern.compile(\"[^_]+((_[a-zA-Z0-9]{2,4})*)\\\\.properties\");\n    final Map<String, List<Properties>> messages = Maps.newHashMap();\n    private final Logger logger = LoggerFactory.getLogger(MessageImpl.class);\n    String[] languages = {DEFAULT_LANGUAGE};\n\n    public void load(List<String> paths, String... languages) {\n        if (!messages.isEmpty()) throw new Error(\"messages must be empty\");\n\n        if (languages.length > 0) this.languages = languages;\n        Map<String, Properties> properties = Maps.newHashMap();\n\n        for (String path : paths) {\n            logger.info(\"load message properties, path={}\", path);\n            String language = language(path);\n            validateLanguage(path, language);\n            properties.computeIfAbsent(language, key -> new Properties())\n                .load(path);\n        }\n\n        for (String language : this.languages) {\n            List<Properties> messages = languageProperties(properties, language);\n            this.messages.put(language, messages);\n        }\n\n        validateMessageKeys();\n    }\n\n    void validateMessageKeys() {\n        Map<String, Set<String>> allLanguageKeys = Maps.newHashMap();\n        Set<String> allKeys = Sets.newHashSet();\n        messages.forEach((language, languageProperties) -> {\n            Set<String> languageKeys = Sets.newHashSet();\n            languageProperties.forEach(properties -> languageKeys.addAll(properties.keys()));\n            allKeys.addAll(languageKeys);\n            allLanguageKeys.put(language, languageKeys);\n        });\n        allLanguageKeys.forEach((language, keys) -> {\n            if (!allKeys.equals(keys)) {\n                Set<String> missingKeys = new HashSet<>(allKeys);\n                missingKeys.removeAll(keys);\n                throw new Error(format(\"message keys are missing for language, language={}, keys={}\", language, missingKeys));\n            }\n        });\n    }\n\n    private void validateLanguage(String path, String language) {\n        if (DEFAULT_LANGUAGE.equals(language)) return;\n\n        if (languages.length == 1 && DEFAULT_LANGUAGE.equals(languages[0])) {\n            throw new Error(format(\"found language specific messages, but only default language is enabled, path={}, language={}\", path, language));\n        }\n\n        if (Arrays.stream(languages).noneMatch(enabledLanguage -> enabledLanguage.startsWith(language))) {\n            throw new Error(format(\"language does not match enabled languages, path={}, language={}\", path, language));\n        }\n    }\n\n    private List<Properties> languageProperties(Map<String, Properties> languageProperties, String language) {\n        List<Properties> messages = new ArrayList<>(languageProperties.size());\n        String currentLanguage = language;\n        while (true) {\n            Properties properties = languageProperties.get(currentLanguage);\n            if (properties != null) messages.add(properties);\n            int index = currentLanguage.lastIndexOf('_');\n            if (index < 0) break;\n            currentLanguage = currentLanguage.substring(0, index);\n        }\n        Properties properties = languageProperties.get(DEFAULT_LANGUAGE);\n        if (properties != null) messages.add(properties);\n        return messages;\n    }\n\n    String language(String path) {\n        Matcher matcher = MESSAGE_PROPERTY_PATH_PATTERN.matcher(path);\n        if (!matcher.matches())\n            throw new Error(\"property path must match 'path/name_language.properties' pattern, path=\" + path);\n        String languagePostfix = matcher.group(1);\n        if (Strings.isBlank(languagePostfix)) return DEFAULT_LANGUAGE;\n        return languagePostfix.substring(1);\n    }\n\n    @Override\n    public String get(String key, String language) {\n        String message = getMessage(key, language).orElse(null);\n        if (message == null) {\n            logger.error(Markers.errorCode(\"INVALID_MESSAGE_KEY\"), \"can not find message, key={}, language={}\", key, language);\n            return key;\n        }\n        return message;\n    }\n\n    Optional<String> getMessage(String key, String language) {\n        String targetLanguage = language == null ? languages[0] : language;\n        List<Properties> properties = messages.get(targetLanguage);\n        if (properties == null) throw new Error(\"language is not defined, please check site().message(), language=\" + targetLanguage);\n        for (Properties property : properties) {\n            Optional<String> message = property.get(key);\n            if (message.isPresent()) return message;\n        }\n        return Optional.empty();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class MimeTypes.java."}, {"role": "assistant", "content": "The source code of java class MimeTypes.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.http.ContentType;\nimport core.framework.util.ASCII;\nimport core.framework.util.Maps;\n\nimport java.util.Map;\n\n/**\n * @author neo\n */\nfinal class MimeTypes {\n    // refer to /etc/nginx/mime.types\n    private static final Map<String, ContentType> MIME_TYPES = Maps.newHashMapWithExpectedSize(40);\n\n    static {\n        MIME_TYPES.put(\"html\", ContentType.TEXT_HTML);\n        MIME_TYPES.put(\"htm\", ContentType.TEXT_HTML);\n        MIME_TYPES.put(\"css\", ContentType.TEXT_CSS);\n        MIME_TYPES.put(\"xml\", ContentType.TEXT_XML);\n        MIME_TYPES.put(\"txt\", ContentType.TEXT_PLAIN);\n\n        MIME_TYPES.put(\"gif\", ContentType.create(\"image/gif\", null));\n        MIME_TYPES.put(\"jpg\", ContentType.create(\"image/jpeg\", null));\n        MIME_TYPES.put(\"jpeg\", ContentType.create(\"image/jpeg\", null));\n        MIME_TYPES.put(\"png\", ContentType.IMAGE_PNG);\n        MIME_TYPES.put(\"tiff\", ContentType.create(\"image/tiff\", null));\n        MIME_TYPES.put(\"tif\", ContentType.create(\"image/tiff\", null));\n        MIME_TYPES.put(\"ico\", ContentType.create(\"image/x-icon\", null));\n\n        MIME_TYPES.put(\"js\", ContentType.APPLICATION_JAVASCRIPT);\n        MIME_TYPES.put(\"json\", ContentType.APPLICATION_JSON);\n\n        MIME_TYPES.put(\"woff\", ContentType.create(\"application/font-woff\", null));\n        MIME_TYPES.put(\"eot\", ContentType.create(\"application/vnd.ms-fontobject\", null));\n        MIME_TYPES.put(\"ttf\", ContentType.create(\"font/ttf\", null));\n        MIME_TYPES.put(\"otf\", ContentType.create(\"font/opentype\", null));\n\n        MIME_TYPES.put(\"pdf\", ContentType.create(\"application/pdf\", null));\n        MIME_TYPES.put(\"rtf\", ContentType.create(\"application/rtf\", null));\n        MIME_TYPES.put(\"doc\", ContentType.create(\"application/msword\", null));\n        MIME_TYPES.put(\"xls\", ContentType.create(\"application/vnd.ms-excel\", null));\n        MIME_TYPES.put(\"ppt\", ContentType.create(\"application/vnd.ms-powerpoint\", null));\n        MIME_TYPES.put(\"docx\", ContentType.create(\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\", null));\n        MIME_TYPES.put(\"xlsx\", ContentType.create(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\", null));\n        MIME_TYPES.put(\"pptx\", ContentType.create(\"application/vnd.openxmlformats-officedocument.presentationml.presentation\", null));\n\n        MIME_TYPES.put(\"swf\", ContentType.create(\"application/x-shockwave-flash\", null));\n        MIME_TYPES.put(\"zip\", ContentType.create(\"application/zip\", null));\n    }\n\n    static ContentType get(String fileName) {\n        int index = fileName.lastIndexOf('.');\n        if (index > 0 && index + 1 < fileName.length()) {\n            String extension = fileName.substring(index + 1);\n            return MIME_TYPES.get(ASCII.toLowerCase(extension));\n        }\n        return null;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SiteManager.java."}, {"role": "assistant", "content": "The source code of java class SiteManager.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.internal.web.session.SessionManager;\nimport core.framework.web.site.WebDirectory;\n\n/**\n * @author neo\n */\npublic class SiteManager {\n    public final WebDirectory webDirectory = new WebDirectory();\n    public final SessionManager sessionManager = new SessionManager();\n    public final MessageImpl message = new MessageImpl();\n    public final TemplateManager templateManager = new TemplateManager(webDirectory, message);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StaticContentController.java."}, {"role": "assistant", "content": "The source code of java class StaticContentController.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.web.Controller;\n\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic interface StaticContentController extends Controller {\n    void cache(Duration maxAge);\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StaticDirectoryController.java."}, {"role": "assistant", "content": "The source code of java class StaticDirectoryController.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPHeaders;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport core.framework.web.exception.NotFoundException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class StaticDirectoryController implements StaticContentController {\n    private final Logger logger = LoggerFactory.getLogger(StaticDirectoryController.class);\n    private final Path contentDirectory;\n    String cacheHeader;\n\n    public StaticDirectoryController(Path contentDirectory) {\n        this.contentDirectory = contentDirectory;\n    }\n\n    @Override\n    public Response execute(Request request) {\n        String path = request.pathParam(\"path\");\n        Path filePath = contentDirectory.resolve(path).normalize();\n        logger.debug(\"requestFile={}\", filePath);\n\n        if (!Files.isRegularFile(filePath, LinkOption.NOFOLLOW_LINKS) || !filePath.startsWith(contentDirectory))\n            throw new NotFoundException(\"not found, path=\" + path, \"PATH_NOT_FOUND\");\n\n        Response response = Response.file(filePath);\n        ContentType contentType = MimeTypes.get(String.valueOf(filePath.getFileName()));\n        if (contentType != null) response.contentType(contentType);\n        if (cacheHeader != null) response.header(HTTPHeaders.CACHE_CONTROL, cacheHeader);\n        return response;\n    }\n\n    @Override\n    public void cache(Duration maxAge) {\n        cacheHeader = \"public, max-age=\" + maxAge.getSeconds();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class StaticFileController.java."}, {"role": "assistant", "content": "The source code of java class StaticFileController.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.http.ContentType;\nimport core.framework.http.HTTPHeaders;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Path;\nimport java.time.Duration;\n\n/**\n * @author neo\n */\npublic final class StaticFileController implements StaticContentController {\n    private final Logger logger = LoggerFactory.getLogger(StaticFileController.class);\n    private final Path contentFile;\n    private final ContentType contentType;\n    private String cacheHeader;\n\n    public StaticFileController(Path contentFile) {\n        this.contentFile = contentFile;\n        contentType = MimeTypes.get(String.valueOf(contentFile.getFileName()));\n    }\n\n    @Override\n    public Response execute(Request request) {\n        logger.debug(\"requestFile={}\", contentFile);\n\n        Response response = Response.file(contentFile);\n        if (contentType != null) response.contentType(contentType);\n        if (cacheHeader != null) response.header(HTTPHeaders.CACHE_CONTROL, cacheHeader);\n        return response;\n    }\n\n    @Override\n    public void cache(Duration maxAge) {\n        cacheHeader = \"public, max-age=\" + maxAge.getSeconds();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class TemplateManager.java."}, {"role": "assistant", "content": "The source code of java class TemplateManager.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.internal.template.CDNManager;\nimport core.framework.internal.template.HTMLTemplate;\nimport core.framework.internal.template.HTMLTemplateBuilder;\nimport core.framework.internal.template.TemplateContext;\nimport core.framework.internal.template.source.FileTemplateSource;\nimport core.framework.util.Files;\nimport core.framework.util.Maps;\nimport core.framework.util.StopWatch;\nimport core.framework.web.site.WebDirectory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.file.Path;\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * @author neo\n */\npublic class TemplateManager {\n    public final CDNManager cdnManager = new CDNManager();\n    private final Logger logger = LoggerFactory.getLogger(TemplateManager.class);\n    private final Map<String, Map<String, HTMLTemplate>> templates = Maps.newConcurrentHashMap();    // path->language->template\n    private final MessageImpl message;\n    private final Map<String, Instant> templateLastModifiedTimes = Maps.newConcurrentHashMap();\n    private final WebDirectory webDirectory;\n\n    TemplateManager(WebDirectory webDirectory, MessageImpl message) {\n        this.webDirectory = webDirectory;\n        this.message = message;\n    }\n\n    public String process(String templatePath, Object model, String language) {\n        var watch = new StopWatch();\n        try {\n            HTMLTemplate template = get(templatePath, model.getClass(), language);\n            TemplateContext context = new TemplateContext(model, cdnManager);\n            return template.process(context);\n        } finally {\n            logger.debug(\"process, templatePath={}, elapsed={}\", templatePath, watch.elapsed());\n        }\n    }\n\n    public void add(String templatePath, Class<?> modelClass) {\n        var watch = new StopWatch();\n        try {\n            Map<String, HTMLTemplate> previous = templates.putIfAbsent(templatePath, load(templatePath, modelClass));\n            if (previous != null) throw new Error(\"template was registered, templatePath=\" + templatePath);\n            if (webDirectory.localEnv) {\n                Path path = webDirectory.path(templatePath);\n                templateLastModifiedTimes.put(templatePath, Files.lastModified(path));\n            }\n        } finally {\n            logger.info(\"add, templatePath={}, modelClass={}, elapsed={}\", templatePath, modelClass.getCanonicalName(), watch.elapsed());\n        }\n    }\n\n    private HTMLTemplate get(String templatePath, Class<?> modelClass, String language) {\n        Map<String, HTMLTemplate> templates = this.templates.get(templatePath);\n        if (templates == null)\n            throw new Error(\"template is not registered, please use site().template() to add template, templatePath=\" + templatePath);\n\n        if (webDirectory.localEnv) {\n            Path path = webDirectory.path(templatePath);\n            if (Files.lastModified(path).isAfter(templateLastModifiedTimes.get(templatePath))) {\n                templateLastModifiedTimes.put(templatePath, Files.lastModified(path)); // put modified time first, then template, for zero cost to handle local threading\n                templates = load(templatePath, modelClass);\n                this.templates.put(templatePath, templates);\n            }\n        }\n\n        String targetLanguage = language == null ? MessageImpl.DEFAULT_LANGUAGE : language;\n        HTMLTemplate template = templates.get(targetLanguage);\n        if (template == null) throw new Error(\"language is not defined, please check site().message(), language=\" + targetLanguage);\n        return template;\n    }\n\n    private Map<String, HTMLTemplate> load(String templatePath, Class<?> modelClass) {\n        var builder = new HTMLTemplateBuilder(new FileTemplateSource(webDirectory.root(), templatePath), modelClass);\n        builder.cdn = cdnManager;\n        Map<String, HTMLTemplate> templates = Maps.newHashMap();\n        for (String language : message.languages) {\n            builder.message = key -> message.getMessage(key, language);\n            HTMLTemplate htmlTemplate = builder.build();\n            templates.put(language, htmlTemplate);\n        }\n        return templates;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSecurityInterceptor.java."}, {"role": "assistant", "content": "The source code of java class WebSecurityInterceptor.java:\n```java\npackage core.framework.internal.web.site;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.internal.http.HTTPRequestHelper;\nimport core.framework.web.Interceptor;\nimport core.framework.web.Invocation;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\n\nimport java.util.Map;\n\nimport static core.framework.http.ContentType.TEXT_HTML;\n\n/**\n * @author neo\n */\npublic final class WebSecurityInterceptor implements Interceptor {  // refer to https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers\n    // example: \"default-src 'self'; img-src 'self' data:; object-src 'none'; frame-src 'none';\"\n    public String contentSecurityPolicy;\n\n    @Override\n    public Response intercept(Invocation invocation) throws Exception {\n        Request request = invocation.context().request();\n        if (!\"https\".equals(request.scheme())) {\n            return Response.redirect(redirectURL(request), HTTPStatus.MOVED_PERMANENTLY);\n        } else {\n            Response response = invocation.proceed();\n            appendSecurityHeaders(response);\n            return response;\n        }\n    }\n\n    void appendSecurityHeaders(Response response) {\n        response.header(\"Strict-Transport-Security\", \"max-age=31536000\");\n        response.contentType().ifPresent(contentType -> {\n            if (TEXT_HTML.mediaType.equals(contentType.mediaType)) {\n                if (contentSecurityPolicy != null) {\n                    response.header(\"Content-Security-Policy\", contentSecurityPolicy);\n                }\n                // refer to https://infosec.mozilla.org/guidelines/web_security\n                response.header(\"X-XSS-Protection\", \"1; mode=block\");\n                response.header(\"X-Frame-Options\", \"DENY\");\n                response.header(\"Referrer-Policy\", \"origin-when-cross-origin\");\n            }\n            response.header(\"X-Content-Type-Options\", \"nosniff\");\n        });\n    }\n\n    String redirectURL(Request request) {   // always assume https site is published on 443 port\n        var builder = new StringBuilder(\"https://\").append(request.hostname()).append(request.path());\n\n        Map<String, String> params = request.queryParams();\n        if (!params.isEmpty()) {\n            builder.append('?');\n            HTTPRequestHelper.urlEncoding(builder, params);\n        }\n        return builder.toString();\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SSLContextBuilder.java."}, {"role": "assistant", "content": "The source code of java class SSLContextBuilder.java:\n```java\npackage core.framework.internal.web;\n\nimport core.framework.internal.http.PEM;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\n\n/**\n * @author neo\n */\npublic class SSLContextBuilder {\n    // generate cert/key by \"openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -nodes -days 3650\"\n    private static final String CERT = \"\"\"\n            -----BEGIN CERTIFICATE-----\n            MIIEoDCCAogCCQC5Kos+icdPjzANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAd1\n            bmtub3duMB4XDTIwMDQwMTE5NTA0NloXDTMwMDMzMDE5NTA0NlowEjEQMA4GA1UE\n            AwwHdW5rbm93bjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOs1QKoL\n            rmz3QcOLlhZl3Wpv2lDaxTt3ZuZalL9ISx9O0MTz5jvXW3uJWbn4ceQTxGQkJ9aL\n            QkIyR73ZK4P0RvGZY9zLzPsM84FS4WXS0UEDYw39TTMAYy/XPs/DmThPZAR1fttG\n            LHtuTyiWZ4IwqXcVKzwPVROiSMVTcfMn/Tf0pSpppnE6HqcicPmoTFK6MwAZ+AAw\n            ewE3c7YpnrPlG8U3ll7WXVnenAEtVO4yu3jpPUEavb9KfuEbyPaXO3hKntGsER7O\n            Y2hQ/2zEozaHLVsXiJ5Chsdgrow7e8fs2VZU5WbuBWE6i3sijjPPqwTYtGP8ABPf\n            vUI6NUhMUXa/Dz00A0W04Yx9DSUd/dekTrm126ewp6zKH3v6RiluvsOC9gTjdjc7\n            qmuoO32M1NWVYx0RhWKL5HmZASWA7nGGmHS7PSqu3csz8I2vNA5SBFh5+WSwtpoh\n            3ta6MVkneETNWH9K5UqVZ9DDNtFGghGgvqcEyoQurPhKrIcq9oj1clR8+B1X7clY\n            bwSHN1iRj0ThlFbFAO5j+5apT+FCbQ3qW1OWrvMI01fqjdzRBlUhVdPfYK6awdOO\n            kfzmozOKgNHCv/83c7PUKpMCQtpJFgljNckctM1TGdn9TAnYMXWrAfxcakUblJ0q\n            HbdDR8Qvubrq8LPE7D9VX5/vIOvdi+Re3f3XAgMBAAEwDQYJKoZIhvcNAQELBQAD\n            ggIBAD1pPUBPDi/QTcFfFwGGBwkwygCaAjaKwPSVEXy1YiMiU8kVKfExzZG8gjGy\n            4sYCsHAmkdHe5DLr0BCPmkTq71zSarsEPeLdlA0D+pIQwX4GWDCZyPzbh7IRPWC8\n            A2DIXvUObsYR/J/umR7W4voWKky88UdHxDnYrzcRLhnKJUfpsfUiF8jOLgwMxIDE\n            3k/+5DqCoVtI2zjmGCahPJ2Rsnz8WKosBRvHCzVWlcytOWFzAyyP3f0LfXGGX04l\n            NvXcqTxcHm2F+k56y2pHGir0IyR0zMMi1m2Hjr1kLCP0aSlrrGilo4bQrD1Qzz9o\n            oxcCbhfVBlVe9BWtVPRAen0/GVKxM2mpO2zZO6ckQqdQYPRoVcmvi9v8Hv4Frwlj\n            8IeXq0ynzklaepu7jLEAuAOZXGQjZm0bTFSNE8HImwTh+Wc0useMGrNo44t03/+x\n            eEN07j16rE8iMyG1TKSr0GzvpZjwgAthPSmCyKvJi1U8fT26ZStQXIFErKZ4Izk5\n            P9hEBzjd6+qe+9CxSWO0fM1hHCu7g2ADYjDUuV5VoUVtkZWpiPnM+CY/rmdfwElK\n            Rc951Uzxq+tSNopgkDbeMLc78oCneiIkG5kRtGSg0cq9F6PvAsSq/wHH2Pt/CeLG\n            T6iN3OqSp9rSOWhhEjIdDLmv47tBBg006TxZdgFHItcYxBj2\n            -----END CERTIFICATE-----\n            \"\"\";\n    private static final String KEY = \"\"\"\n            -----BEGIN PRIVATE KEY-----\n            MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDrNUCqC65s90HD\n            i5YWZd1qb9pQ2sU7d2bmWpS/SEsfTtDE8+Y711t7iVm5+HHkE8RkJCfWi0JCMke9\n            2SuD9EbxmWPcy8z7DPOBUuFl0tFBA2MN/U0zAGMv1z7Pw5k4T2QEdX7bRix7bk8o\n            lmeCMKl3FSs8D1UTokjFU3HzJ/039KUqaaZxOh6nInD5qExSujMAGfgAMHsBN3O2\n            KZ6z5RvFN5Ze1l1Z3pwBLVTuMrt46T1BGr2/Sn7hG8j2lzt4Sp7RrBEezmNoUP9s\n            xKM2hy1bF4ieQobHYK6MO3vH7NlWVOVm7gVhOot7Io4zz6sE2LRj/AAT371COjVI\n            TFF2vw89NANFtOGMfQ0lHf3XpE65tdunsKesyh97+kYpbr7DgvYE43Y3O6prqDt9\n            jNTVlWMdEYVii+R5mQElgO5xhph0uz0qrt3LM/CNrzQOUgRYeflksLaaId7WujFZ\n            J3hEzVh/SuVKlWfQwzbRRoIRoL6nBMqELqz4SqyHKvaI9XJUfPgdV+3JWG8EhzdY\n            kY9E4ZRWxQDuY/uWqU/hQm0N6ltTlq7zCNNX6o3c0QZVIVXT32CumsHTjpH85qMz\n            ioDRwr//N3Oz1CqTAkLaSRYJYzXJHLTNUxnZ/UwJ2DF1qwH8XGpFG5SdKh23Q0fE\n            L7m66vCzxOw/VV+f7yDr3YvkXt391wIDAQABAoICABROYqjLnWF270yMjoacgMMh\n            qP12BbUel9mnVFQ3T5UCXu/CBsx/yTwfHYn6swp30mq63F2fZDcG1D7FswYPXtiY\n            35A+YBIEijlOCHub+cjdG/4nMjUHAYkt0hRp1J6R7BaedjdEFa8KVPcyFPmebeME\n            BtmGkVfCmPnAPIQ7nZbpHiFNQbtgwyi2xn4nU3+I58JIe6q4hMYUHX9KlJL/Yqhi\n            Ji9F3oVVvK41VbHC24CS0mD+iActzUpt9amkYNP/zTpY2pmIQ/jLlWG0kEqy3O2S\n            WI8hOzWXWTpuID+gaRsU9UEvp3M/dK9KynAaq68dbmV7ah5NIK/JCrSVMitIT25U\n            3rOHadi9J9h/tpsHg8UlJ3QUXW4yzn86yHX3RhsBCZZTzDO23A2MajWrindx8Cl3\n            aucAkcG6vIpiUEwGshmamcL4PNpkuYYJVCEGzwjwCocHAX3wNWI4Exr+8BK07lb3\n            6TMX7+MiO9Bp6U1r+gflQ3BGSgrMNuhCtxxQmFh7Upu25c6fFR2eBP81vWkwiFI5\n            3vLsSCHr+K4e0JfLATW5rL0rnHhmX5TWW6V4Fq+pj8OB3dqpEZwe13vAHWMgdNf6\n            ACYsh2HLkGhTddZDq0o+1Fb+b8w5xgMT4BWxnwkcg27OMeqteruGRiEcsX0ZpEen\n            K72M1E06FSNMmamKGXNxAoIBAQD79mcYXh8DC+c/fW3yFmUJ7OQAr1PIcykbbMDj\n            gRlWfI8Z5n/23BEhoPJscXIVRAHXas3jrneTLaoKjLVmHyClvFbavOrN9NubfkFv\n            yzoGYryvoJrUCUXx9MBeDu/J1cTcCyTur01qHfRtn+539jzczabkaaEARa762UtD\n            Uc1OLPKOI1US46ey+L6nfqNnOaQNahhX0EHg/d74/DHTAxTaypvaeVktzG8+FzkV\n            NBlDp/w/h3pFJBnpKbkjCLtcuDAmdSCTHBTIi63XpsZ5VQ5PfdhwsocKBmNScYqN\n            K20pD7dUsEXOnLv2RnBf9ysJJJVrJnRd/lohTnRgvEbRfZttAoIBAQDu+h6sjwDu\n            nyopeA3XjooFCiChVSqS4VmZdNavEnzgWDAjCIs98HNMnBP18Q2yRYBqUavBms0+\n            diKPsEQXJcqYkDr9IQdrU3AR+7vrXCaMC5z8RDIVTs36lJixvq521vrxJu3ERF0+\n            5vkAnzQ0TM8tLQbWgqK/sR3K+S3IW6khzdW/rW2gI1s9RvYXdqm3GJrow2mVTm6/\n            skmd7XBVjrAUXxlcEOCn8YO/QL2WH7/Yd5XHH1vHYYarJTQzecAq2bqq6h3EBIY8\n            gvcPJ1VOQL6v9aE8Ocbjmzd+o4YNEHDQ3+DdZEGqtd+nyJ36LFsTDXw3DShrCNwu\n            5yByXGnkeY/TAoIBAQCn1deQtMmFlv1AHoYJN3+wX9r01dVCdeuQ+B14rjs5kBkm\n            kJL21lqXAwXY1KzAm596ZguluUavhEB7bIU89Ekj/VQBusvRy2QprK1cEYyiSk0T\n            1DCuQ0sTRAyL2vlBgiLyzH2afK1dnXx/NYR85kpebqLYDcCQVNqc//eRbUEL7QbZ\n            RZHa1kiT//vHyKSCEzRDN0Pl4rSvcYyAYEW0IJ5Yq5OrsR+FUWNcgc2lYSHfHlv5\n            2X3J5qVX2lIXky5zMcHpLCY5t//kIp73QoF8uvqgWty9HT60n9KzTSyUorPBIVXm\n            lNC7M05FW2BpnFRPb84UJPZo0hAplYASG/g0fa31AoIBAFhEDbxSfVeldh8m9oXd\n            YeEGopK0MCtcDIn/e6PiQjlimTT3XOadvxhWtZCrXhGwVgPu8m9py9D8NTu5MQ0T\n            qka7Tu5bmq/re4NI5VnDCYHEcFFEpvLzzmR1KgjMkwfV043qgPty/LXU/bdbFh8T\n            F5pp/RKR4abHtmdXra9JG6keq4pGdi0lofd6FD8KVxkHf3/lXUQGWiV3pnUsU8dm\n            EmcT0PwOR8wACldDhELEq0k6shl/3ZhAz0q7TRKOL4okLSwfmKrjuOj0vmfccUeb\n            5lJ7ePgTpwA+PjsKDuMYZXLgnd9nvlFdJ6SDFsZmR6U739s9guY1uY2hVHyo4Xu/\n            4n0CggEAEcsl52ee0QxA+8+njeGduILlVMhJUkfrRFu3x0t8ZKG9DMT6lvAPVZTy\n            Qvhl1XYjcdIHIkuPB+iFJenMMoUJiUwT2oGQTi4MbqoPc85x67K6Yedtti0gnCaP\n            7h2bWCAC4qJFb58+1J6ls2zuDxG4thUKIiPppPbCOyBPGyAgj7gfzq/B5118e5tS\n            CmQ4jdUu6Sq573/yi0yx/NsjTqZDDHHndq+bzi25uyhn9fHkMlNdx+Q9SUP+aN+1\n            jaU94GX4Xv91Q22Kf8qOme1b7Qip2IvIdlqeyAb7rF8entrXu1j65oadkP6mbRq1\n            TrR8UkBExY7UIS0B+fiT0pzlru06BA==\n            -----END PRIVATE KEY-----\n            \"\"\";\n\n    public SSLContext build() {\n        try {\n            PrivateKey privateKey = KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(PEM.decode(KEY)));\n            Certificate certificate = CertificateFactory.getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(PEM.decode(CERT)));\n\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, null);\n            keyStore.setKeyEntry(\"default\", privateKey, new char[0], new Certificate[]{certificate});\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, new char[0]);\n\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(keyManagerFactory.getKeyManagers(), null, null);\n            return context;\n        } catch (KeyStoreException | IOException | CertificateException | UnrecoverableKeyException | NoSuchAlgorithmException | KeyManagementException | InvalidKeySpecException e) {\n            throw new Error(e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class APIController.java."}, {"role": "assistant", "content": "The source code of java class APIController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.http.ContentType;\nimport core.framework.internal.web.api.APIDefinitionBuilder;\nimport core.framework.internal.web.api.APIDefinitionResponse;\nimport core.framework.internal.web.api.MessageAPIDefinitionBuilder;\nimport core.framework.internal.web.api.MessageAPIDefinitionResponse;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.internal.web.service.ErrorResponse;\nimport core.framework.json.JSON;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\n\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @author neo\n */\npublic class APIController {\n    public final IPv4AccessControl accessControl = new IPv4AccessControl();\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public Set<Class<?>> serviceInterfaces = new LinkedHashSet<>();\n    public Set<Class<?>> beanClasses = new LinkedHashSet<>();  // custom bean classes not referred by service interfaces\n    public Map<String, Class<?>> topics = new LinkedHashMap<>();   // topic -> messageClass\n\n    private APIDefinitionResponse serviceDefinition;\n    private MessageAPIDefinitionResponse messageDefinition;\n\n    public APIController() {\n        beanClasses.add(ErrorResponse.class);   // publish default error response\n    }\n\n    public Response service(Request request) {\n        accessControl.validate(request.clientIP());\n        APIDefinitionResponse response = serviceDefinition();\n        return Response.text(JSON.toJSON(response)).contentType(ContentType.APPLICATION_JSON);\n    }\n\n    public Response message(Request request) {\n        accessControl.validate(request.clientIP());\n        MessageAPIDefinitionResponse response = messageDefinition();\n        return Response.text(JSON.toJSON(response)).contentType(ContentType.APPLICATION_JSON);\n    }\n\n    APIDefinitionResponse serviceDefinition() {\n        if (serviceDefinition != null) return serviceDefinition;\n\n        lock.lock();\n        try {\n            if (serviceDefinition == null) {\n                var builder = new APIDefinitionBuilder(serviceInterfaces, beanClasses);\n                serviceDefinition = builder.build();\n                serviceInterfaces = null;   // release memory\n                beanClasses = null;\n            }\n            return serviceDefinition;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    MessageAPIDefinitionResponse messageDefinition() {\n        if (messageDefinition != null) return messageDefinition;\n\n        lock.lock();\n        try {\n            if (messageDefinition == null) {\n                var builder = new MessageAPIDefinitionBuilder(topics);\n                messageDefinition = builder.build();\n                topics = null;    // release memory\n            }\n            return messageDefinition;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class CacheController.java."}, {"role": "assistant", "content": "The source code of java class CacheController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.http.ContentType;\nimport core.framework.internal.cache.CacheImpl;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.json.JSON;\nimport core.framework.util.Strings;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport core.framework.web.exception.NotFoundException;\n\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * @author neo\n */\npublic class CacheController {\n    private final Map<String, CacheImpl<?>> caches;\n    private final IPv4AccessControl accessControl = new IPv4AccessControl();\n\n    public CacheController(Map<String, CacheImpl<?>> caches) {\n        this.caches = caches;\n    }\n\n    public Response get(Request request) {\n        accessControl.validate(request.clientIP());\n        String name = request.pathParam(\"name\");\n        String key = request.pathParam(\"key\");\n        CacheImpl<?> cache = cache(name);\n        Object value = cache.get(key).orElseThrow(() -> new NotFoundException(\"cache key not found, name=\" + name + \", key=\" + key));\n        return Response.text(JSON.toJSON(value)).contentType(ContentType.APPLICATION_JSON);\n    }\n\n    public Response delete(Request request) {\n        accessControl.validate(request.clientIP());\n        String name = request.pathParam(\"name\");\n        String key = request.pathParam(\"key\");\n        CacheImpl<?> cache = cache(name);\n        cache.evict(key);\n        return Response.text(Strings.format(\"cache evicted, name={}, key={}\", name, key));\n    }\n\n    public Response list(Request request) {\n        accessControl.validate(request.clientIP());\n        var response = new ListCacheResponse();\n        response.caches = caches.values().stream().map(this::view).collect(Collectors.toList());\n        return Response.text(JSON.toJSON(response)).contentType(ContentType.APPLICATION_JSON);\n    }\n\n    CacheImpl<?> cache(String name) {\n        CacheImpl<?> cache = caches.get(name);\n        if (cache == null) throw new NotFoundException(\"cache not found, name=\" + name);\n        return cache;\n    }\n\n    private ListCacheResponse.Cache view(CacheImpl<?> cache) {\n        var view = new ListCacheResponse.Cache();\n        view.name = cache.name;\n        view.type = cache.cacheClass.getCanonicalName();\n        view.duration = (int) cache.duration.getSeconds();\n        return view;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class DiagnosticController.java."}, {"role": "assistant", "content": "The source code of java class DiagnosticController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.http.ContentType;\nimport core.framework.internal.stat.Diagnostic;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.util.Files;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\n\nimport java.nio.file.Path;\n\n/**\n * @author neo\n */\npublic class DiagnosticController {\n    private final IPv4AccessControl accessControl = new IPv4AccessControl();\n\n    // add -XX:NativeMemoryTracking=summary or -XX:NativeMemoryTracking=detail to enable native memory tracking, and vmInfo will include NMT summary\n    // enabling NMT will result in a 5-10 percent JVM performance drop\n    public Response vm(Request request) {\n        accessControl.validate(request.clientIP());\n        return Response.text(Diagnostic.vm());\n    }\n\n    public Response thread(Request request) {\n        accessControl.validate(request.clientIP());\n        return Response.text(Diagnostic.thread());\n    }\n\n    public Response virtualThread(Request request) {\n        accessControl.validate(request.clientIP());\n        return Response.text(Diagnostic.virtualThread());\n    }\n\n    public Response heap(Request request) {\n        accessControl.validate(request.clientIP());\n        return Response.text(Diagnostic.heap());\n    }\n\n    public Response proc(Request request) {\n        accessControl.validate(request.clientIP());\n\n        Path procPath = Path.of(\"/proc/self/status\");\n        if (java.nio.file.Files.exists(procPath)) {\n            return Response.bytes(Files.bytes(procPath))\n                    .contentType(ContentType.TEXT_PLAIN);\n        } else {\n            return Response.text(\"/proc/self/status not found\");\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class KafkaController.java."}, {"role": "assistant", "content": "The source code of java class KafkaController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.internal.kafka.KafkaMessage;\nimport core.framework.internal.kafka.MessageListener;\nimport core.framework.internal.kafka.MessageProcess;\nimport core.framework.internal.kafka.MessageProducer;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.log.Trace;\nimport core.framework.internal.log.filter.BytesLogParam;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.json.JSON;\nimport core.framework.kafka.Message;\nimport core.framework.util.Strings;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.header.Headers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport static core.framework.log.Markers.errorCode;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * @author neo\n */\npublic class KafkaController {\n    private final Logger logger = LoggerFactory.getLogger(KafkaController.class);\n    private final IPv4AccessControl accessControl = new IPv4AccessControl();\n    public MessageProducer producer;\n    public MessageListener listener;\n\n    public Response publish(Request request) {\n        accessControl.validate(request.clientIP());\n        String topic = request.pathParam(\"topic\");\n        String key = request.pathParam(\"key\");\n        ActionLog actionLog = initAction(topic, key);\n        byte[] body = request.body().orElseThrow(() -> new Error(\"body must not be null\"));\n\n        logger.warn(errorCode(\"MANUAL_OPERATION\"), \"publish message manually, topic={}\", topic);   // log trace message, due to potential impact\n\n        ProducerRecord<byte[], byte[]> record = record(topic, key, body, actionLog);\n        producer.send(record);\n\n        return Response.text(Strings.format(\"message published, topic={}, key={}, message={}\", topic, key, new String(body, UTF_8)));\n    }\n\n    public Response handle(Request request) throws Exception {\n        accessControl.validate(request.clientIP());\n        String topic = request.pathParam(\"topic\");\n        String key = request.pathParam(\"key\");\n        ActionLog actionLog = initAction(topic, key);\n        byte[] body = request.body().orElseThrow(() -> new Error(\"body must not be null\"));\n\n        logger.warn(errorCode(\"MANUAL_OPERATION\"), \"handle message manually, topic={}\", topic);   // log trace message, due to potential impact\n\n        @SuppressWarnings(\"unchecked\")\n        MessageProcess<Object> process = (MessageProcess<Object>) listener.processes.get(topic);\n        @SuppressWarnings(\"unchecked\")\n        MessageProcess<Object> bulkProcess = (MessageProcess<Object>) listener.bulkProcesses.get(topic);\n        if (process != null) {\n            Object message = message(topic, key, body, process, actionLog);\n            process.handler().handle(key, message);\n        } else if (bulkProcess != null) {\n            Object message = message(topic, key, body, bulkProcess, actionLog);\n            bulkProcess.bulkHandler().handle(List.of(new Message<>(key, message)));\n        } else {\n            throw new Error(\"handler not found, topic=\" + topic);\n        }\n        return Response.text(Strings.format(\"message handled, topic={}, key={}, message={}\", topic, key, new String(body, UTF_8)));\n    }\n\n    private Object message(String topic, String key, byte[] body, MessageProcess<Object> process, ActionLog actionLog) throws IOException {\n        Object message = process.reader.fromJSON(body);\n        process.validator.validate(message, false);\n        logger.debug(\"[message] topic={}, key={}, value={}\", topic, key, new BytesLogParam(Strings.bytes(JSON.toJSON(message))));    // log converted message\n        String handler = process.handler.getClass().getCanonicalName();\n        actionLog.context.put(\"handler\", List.of(handler));\n        logger.debug(\"handler={}\", handler);\n        return message;\n    }\n\n    private ActionLog initAction(String topic, String key) {\n        ActionLog actionLog = LogManager.CURRENT_ACTION_LOG.get();\n        actionLog.context.put(\"topic\", List.of(topic));\n        actionLog.context.put(\"key\", List.of(key));\n        return actionLog;\n    }\n\n    ProducerRecord<byte[], byte[]> record(String topic, String key, byte[] body, ActionLog actionLog) {\n        var record = new ProducerRecord<>(topic, Strings.bytes(key), body);\n        Headers headers = record.headers();\n        headers.add(KafkaMessage.HEADER_CLIENT, Strings.bytes(KafkaController.class.getSimpleName()));\n        headers.add(KafkaMessage.HEADER_TRACE, Strings.bytes(Trace.CASCADE.name()));  // auto trace\n        headers.add(KafkaMessage.HEADER_CORRELATION_ID, Strings.bytes(actionLog.correlationId()));\n        headers.add(KafkaMessage.HEADER_REF_ID, Strings.bytes(actionLog.id));\n        return record;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ListCacheResponse.java."}, {"role": "assistant", "content": "The source code of java class ListCacheResponse.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.api.json.Property;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class ListCacheResponse {\n    @Property(name = \"caches\")\n    public List<Cache> caches;\n\n    public static class Cache {\n        @Property(name = \"name\")\n        public String name;\n        @Property(name = \"type\")\n        public String type;\n        @Property(name = \"duration\")\n        public Integer duration;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ListJobResponse.java."}, {"role": "assistant", "content": "The source code of java class ListJobResponse.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.api.json.Property;\n\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class ListJobResponse {\n    @Property(name = \"jobs\")\n    public List<JobView> jobs;\n\n    public static class JobView {\n        @Property(name = \"name\")\n        public String name;\n        @Property(name = \"jobClass\")\n        public String jobClass;\n        @Property(name = \"trigger\")\n        public String trigger;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class PropertyController.java."}, {"role": "assistant", "content": "The source code of java class PropertyController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.internal.module.PropertyManager;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.web.Controller;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\n\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * @author neo\n */\npublic class PropertyController implements Controller {\n    private final IPv4AccessControl accessControl = new IPv4AccessControl();\n    private final PropertyManager propertyManager;\n\n    public PropertyController(PropertyManager propertyManager) {\n        this.propertyManager = propertyManager;\n    }\n\n    @Override\n    public Response execute(Request request) {\n        accessControl.validate(request.clientIP());\n        return Response.text(properties());\n    }\n\n    String properties() {\n        var builder = new StringBuilder(32768);\n        builder.append(\"# properties\\n\");\n        for (String key : new TreeSet<>(propertyManager.properties.keys())) {   // sort by key\n            String value = propertyManager.property(key).orElse(\"\");\n            builder.append(key).append('=').append(mask(key, value)).append('\\n');\n        }\n        builder.append(\"\\n# system properties\\n\");\n        Properties properties = System.getProperties();\n        for (var key : new TreeSet<>(properties.stringPropertyNames())) { // sort by key\n            String value = properties.getProperty(key);\n            String maskedValue = mask(key, value);\n            builder.append(key).append('=').append(maskedValue).append('\\n');\n        }\n        builder.append(\"\\n# env variables\\n\");\n        Map<String, String> env = new TreeMap<>(System.getenv());   // sort by key\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            builder.append(key).append('=').append(mask(key, value)).append('\\n');\n        }\n        return builder.toString();\n    }\n\n    private String mask(String key, String value) {\n        return propertyManager.maskValue(key, value);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class SchedulerController.java."}, {"role": "assistant", "content": "The source code of java class SchedulerController.java:\n```java\npackage core.framework.internal.web.sys;\n\nimport core.framework.api.http.HTTPStatus;\nimport core.framework.http.ContentType;\nimport core.framework.internal.scheduler.Scheduler;\nimport core.framework.internal.web.http.IPv4AccessControl;\nimport core.framework.json.JSON;\nimport core.framework.log.ActionLogContext;\nimport core.framework.log.Markers;\nimport core.framework.web.Request;\nimport core.framework.web.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author neo\n */\npublic class SchedulerController {\n    private final Logger logger = LoggerFactory.getLogger(SchedulerController.class);\n    private final IPv4AccessControl accessControl = new IPv4AccessControl();\n    private final Scheduler scheduler;\n\n    public SchedulerController(Scheduler scheduler) {\n        this.scheduler = scheduler;\n    }\n\n    public Response jobs(Request request) {\n        accessControl.validate(request.clientIP());\n\n        var response = new ListJobResponse();\n        List<ListJobResponse.JobView> jobs = new ArrayList<>();\n        scheduler.tasks.forEach((name, trigger) -> {\n            var job = new ListJobResponse.JobView();\n            job.name = trigger.name();\n            job.jobClass = trigger.job().getClass().getCanonicalName();\n            job.trigger = trigger.trigger();\n            jobs.add(job);\n        });\n        response.jobs = jobs;\n        return Response.text(JSON.toJSON(response)).contentType(ContentType.APPLICATION_JSON);\n    }\n\n    public Response triggerJob(Request request) {\n        accessControl.validate(request.clientIP());\n\n        String job = request.pathParam(\"job\");\n        logger.warn(Markers.errorCode(\"MANUAL_OPERATION\"), \"trigger job manually, job={}\", job);   // log trace message, due to potential impact\n        scheduler.triggerNow(job, ActionLogContext.id());\n        return Response.text(\"job triggered, job=\" + job).status(HTTPStatus.ACCEPTED);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ChannelCallback.java."}, {"role": "assistant", "content": "The source code of java class ChannelCallback.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport io.undertow.websockets.core.WebSocketCallback;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author neo\n */\npublic class ChannelCallback implements WebSocketCallback<Void> {\n    static final ChannelCallback INSTANCE = new ChannelCallback();\n    private final Logger logger = LoggerFactory.getLogger(ChannelCallback.class);\n\n    @Override\n    public void complete(WebSocketChannel channel, Void context) {\n    }\n\n    @Override\n    public void onError(WebSocketChannel channel, Void context, Throwable exception) {\n        logger.warn(exception.getMessage(), exception);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ChannelHandler.java."}, {"role": "assistant", "content": "The source code of java class ChannelHandler.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.internal.json.JSONMapper;\nimport core.framework.internal.json.JSONReader;\nimport core.framework.internal.json.JSONWriter;\nimport core.framework.internal.validate.ValidationException;\nimport core.framework.internal.validate.Validator;\nimport core.framework.util.Strings;\nimport core.framework.web.exception.BadRequestException;\nimport core.framework.web.rate.LimitRate;\nimport core.framework.web.websocket.Channel;\nimport core.framework.web.websocket.ChannelListener;\n\nimport java.io.IOException;\n\n/**\n * @author neo\n */\npublic class ChannelHandler<T, V> {\n    final ChannelListener<T, V> listener;\n    final LimitRate limitRate;  // only supported annotation currently\n\n    private final JSONReader<T> clientMessageReader;\n    private final Validator<T> clientMessageValidator;\n\n    private final Class<V> serverMessageClass;\n    private final JSONWriter<V> serverMessageWriter;\n    private final Validator<V> serverMessageValidator;\n\n    public ChannelHandler(Class<T> clientMessageClass, Class<V> serverMessageClass, ChannelListener<T, V> listener) {\n        clientMessageReader = JSONMapper.reader(clientMessageClass);\n        clientMessageValidator = Validator.of(clientMessageClass);\n\n        this.serverMessageClass = serverMessageClass;\n        serverMessageWriter = JSONMapper.writer(serverMessageClass);\n        serverMessageValidator = Validator.of(serverMessageClass);\n\n        this.listener = listener;\n        try {\n            limitRate = listener.getClass().getDeclaredMethod(\"onMessage\", Channel.class, Object.class).getDeclaredAnnotation(LimitRate.class);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    String toServerMessage(V message) {\n        if (message == null) throw new Error(\"message must not be null\");\n        if (!serverMessageClass.equals(message.getClass())) {\n            throw new Error(Strings.format(\"message class does not match, expected={}, actual={}\", serverMessageClass.getCanonicalName(), message.getClass().getCanonicalName()));\n        }\n        serverMessageValidator.validate(message, false);\n        return serverMessageWriter.toJSONString(message);\n    }\n\n    T fromClientMessage(String message) {\n        try {\n            T clientMessage = clientMessageReader.fromJSON(message);\n            clientMessageValidator.validate(clientMessage, false);\n            return clientMessage;\n        } catch (ValidationException e) {\n            throw new BadRequestException(e.getMessage(), e.errorCode(), e);\n        } catch (IOException e) {  // for invalid json string\n            throw new BadRequestException(e.getMessage(), \"INVALID_WS_MESSAGE\", e);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ChannelImpl.java."}, {"role": "assistant", "content": "The source code of java class ChannelImpl.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.internal.log.Trace;\nimport core.framework.log.ActionLogContext;\nimport core.framework.util.Sets;\nimport core.framework.util.StopWatch;\nimport core.framework.web.websocket.Channel;\nimport io.undertow.websockets.core.CloseMessage;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport io.undertow.websockets.core.WebSockets;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author neo\n */\npublic class ChannelImpl<T, V> implements Channel<V>, Channel.Context {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelImpl.class);\n    final String id = UUID.randomUUID().toString();\n    final long startTime = System.nanoTime();\n    final Set<String> rooms = Sets.newConcurrentHashSet();\n    final ChannelHandler<T, V> handler;\n    private final WebSocketChannel channel;\n    private final Map<String, Object> context = new ConcurrentHashMap<>();\n    private final WebSocketContextImpl webSocketContext;\n    String action;\n    String clientIP;\n    String refId;\n    Trace trace;\n    @Nullable\n    CloseMessage closeMessage;\n\n    ChannelImpl(WebSocketChannel channel, WebSocketContextImpl webSocketContext, ChannelHandler<T, V> handler) {\n        this.channel = channel;\n        this.webSocketContext = webSocketContext;\n        this.handler = handler;\n    }\n\n    @Override\n    public void send(V message) {\n        var watch = new StopWatch();\n        String text = handler.toServerMessage(message);\n\n        // refer to io.undertow.websockets.core.WebSocketChannel.send(WebSocketFrameType),\n        // in concurrent env, one thread can still get hold of channel from context right before channel close listener removes it from context\n        // this is to reduce chance of triggering WebSocketMessages.MESSAGES.channelClosed() exception\n        // but in theory, there is still small possibility to cause channelClosed()\n        if (channel.isCloseFrameSent() || channel.isCloseFrameReceived()) return;\n\n        try {\n            WebSockets.sendText(text, channel, ChannelCallback.INSTANCE);\n        } finally {\n            long elapsed = watch.elapsed();\n            ActionLogContext.track(\"ws\", elapsed, 0, text.length());\n            LOGGER.debug(\"send ws message, id={}, text={}, elapsed={}\", id, text, elapsed);     // not mask, assume ws message not containing sensitive info, the text can be json or plain text\n        }\n    }\n\n    @Override\n    public void close() {\n        var watch = new StopWatch();\n        try {\n            WebSockets.sendClose(WebSocketCloseCodes.NORMAL_CLOSURE, null, channel, ChannelCallback.INSTANCE);\n        } finally {\n            long elapsed = watch.elapsed();\n            ActionLogContext.track(\"ws\", elapsed, 0, 1);    // close message size = 1\n            LOGGER.debug(\"close ws channel, id={}, elapsed={}\", id, elapsed);\n        }\n    }\n\n    @Override\n    public void join(String room) {\n        webSocketContext.join(this, room);\n    }\n\n    @Override\n    public void leave(String room) {\n        webSocketContext.leave(this, room);\n    }\n\n    @Override\n    public Context context() {\n        return this;\n    }\n\n    @Override\n    public Object get(String key) {\n        return context.get(key);\n    }\n\n    @Override\n    public void put(String key, Object value) {\n        if (value == null) context.remove(key);\n        else context.put(key, value);\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class ReadOnlySession.java."}, {"role": "assistant", "content": "The source code of java class ReadOnlySession.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.web.Session;\n\nimport java.util.Optional;\n\n/**\n * @author neo\n */\npublic class ReadOnlySession implements Session {\n    private final Session session;\n\n    public ReadOnlySession(Session session) {\n        this.session = session;\n    }\n\n    @Override\n    public Optional<String> get(String key) {\n        return session.get(key);\n    }\n\n    @Override\n    public void set(String key, String value) {\n        throw new Error(\"session is readonly for websocket\");\n    }\n\n    @Override\n    public void invalidate() {\n        throw new Error(\"session is readonly for websocket\");\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSocketCloseCodes.java."}, {"role": "assistant", "content": "The source code of java class WebSocketCloseCodes.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.web.exception.BadRequestException;\nimport core.framework.web.exception.TooManyRequestsException;\nimport core.framework.web.exception.UnauthorizedException;\n\n/**\n * @author neo\n */\npublic final class WebSocketCloseCodes {\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n    public static final int NORMAL_CLOSURE = 1000;\n    public static final int ABNORMAL_CLOSURE = 1006;\n    public static final int POLICY_VIOLATION = 1008;\n    public static final int INTERNAL_ERROR = 1011;\n    public static final int SERVICE_RESTART = 1012;\n    public static final int TRY_AGAIN_LATER = 1013;\n\n    // as websocket does not have restful convention, here only supports general cases\n    static int closeCode(Throwable e) {\n        if (e instanceof TooManyRequestsException) return TRY_AGAIN_LATER;\n        if (e instanceof BadRequestException) return POLICY_VIOLATION;\n        if (e instanceof UnauthorizedException) return POLICY_VIOLATION;\n        return INTERNAL_ERROR;\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSocketContextImpl.java."}, {"role": "assistant", "content": "The source code of java class WebSocketContextImpl.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.web.websocket.Channel;\nimport core.framework.web.websocket.WebSocketContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author neo\n */\npublic class WebSocketContextImpl implements WebSocketContext {\n    private final Logger logger = LoggerFactory.getLogger(WebSocketContextImpl.class);\n    private final Map<String, Channel<?>> channels = new ConcurrentHashMap<>();\n    private final Map<String, Map<String, Channel<?>>> rooms = new ConcurrentHashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <V> List<Channel<V>> all() {\n        // \"new ArrayList(Collection)\" doesn't check null element, so it's faster than List.copyOf\n        return (List<Channel<V>>) new ArrayList<>((Collection<?>) channels.values());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <V> List<Channel<V>> room(String name) {\n        Map<String, Channel<?>> channels = rooms.get(name);\n        if (channels == null) return List.of();\n        return (List<Channel<V>>) new ArrayList<>((Collection<?>) channels.values());\n    }\n\n    void join(ChannelImpl<?, ?> channel, String room) {\n        logger.debug(\"join room, channel={}, room={}\", channel.id, room);\n        channel.rooms.add(room);\n        rooms.computeIfAbsent(room, key -> new ConcurrentHashMap<>()).put(channel.id, channel);\n    }\n\n    void leave(ChannelImpl<?, ?> channel, String room) {\n        logger.debug(\"leave room, channel={}, room={}\", channel.id, room);\n        channel.rooms.remove(room);\n        Map<String, Channel<?>> channels = rooms.get(room);\n        if (channels != null) channels.remove(channel.id);\n    }\n\n    void add(ChannelImpl<?, ?> channel) {\n        channels.put(channel.id, channel);\n    }\n\n    void remove(ChannelImpl<?, ?> channel) {\n        channels.remove(channel.id);\n        for (String room : channel.rooms) {\n            Map<String, Channel<?>> roomChannels = rooms.get(room);\n            roomChannels.remove(channel.id);\n            if (roomChannels.isEmpty()) rooms.remove(room); // cleanup room if it has no channels\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSocketHandler.java."}, {"role": "assistant", "content": "The source code of java class WebSocketHandler.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.http.HTTPMethod;\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.web.http.RateControl;\nimport core.framework.internal.web.request.RequestImpl;\nimport core.framework.internal.web.session.SessionManager;\nimport core.framework.util.Sets;\nimport core.framework.web.Session;\nimport core.framework.web.exception.BadRequestException;\nimport core.framework.web.exception.NotFoundException;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport io.undertow.websockets.core.WebSockets;\nimport io.undertow.websockets.core.protocol.Handshake;\nimport io.undertow.websockets.core.protocol.version13.Hybi13Handshake;\nimport io.undertow.websockets.spi.AsyncWebSocketHttpServerExchange;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static core.framework.util.Strings.format;\n\n/**\n * @author neo\n */\npublic class WebSocketHandler {\n    static final String CHANNEL_KEY = \"CHANNEL\";\n    public final WebSocketContextImpl context = new WebSocketContextImpl();\n\n    // passes to AsyncWebSocketHttpServerExchange as peerConnections, channel will remove self on close\n    // refer to io.undertow.websockets.core.WebSocketChannel.WebSocketChannel\n    final Set<WebSocketChannel> channels = Sets.newConcurrentHashSet();\n\n    private final Handshake handshake = new Hybi13Handshake();\n    private final Map<String, ChannelHandler<?, ?>> handlers = new HashMap<>();\n\n    private final WebSocketListener listener;\n    private final SessionManager sessionManager;\n    private final LogManager logManager;\n\n    public WebSocketHandler(LogManager logManager, SessionManager sessionManager, RateControl rateControl) {\n        this.logManager = logManager;\n        this.sessionManager = sessionManager;\n        listener = new WebSocketListener(logManager, context, rateControl);\n    }\n\n    public boolean checkWebSocket(HTTPMethod method, HeaderMap headers) {\n        if (method == HTTPMethod.GET && headers.getFirst(Headers.SEC_WEB_SOCKET_KEY) != null) {\n            String version = headers.getFirst(Headers.SEC_WEB_SOCKET_VERSION);\n            if (\"13\".equals(version)) return true;  // only support latest ws version\n            throw new BadRequestException(\"only support web socket version 13, version=\" + version, \"INVALID_HTTP_REQUEST\");\n        }\n        return false;\n    }\n\n    // refer to io.undertow.websockets.WebSocketProtocolHandshakeHandler\n    public void handle(HttpServerExchange exchange, RequestImpl request, ActionLog actionLog) {\n        String path = exchange.getRequestPath();\n        String action = \"ws:\" + path;\n        actionLog.action(action + \":open\");\n\n        @SuppressWarnings(\"unchecked\")\n        ChannelHandler<Object, Object> handler = (ChannelHandler<Object, Object>) handlers.get(path);\n        if (handler == null) throw new NotFoundException(\"not found, path=\" + path, \"PATH_NOT_FOUND\");\n\n        request.session = loadSession(request, actionLog);  // load session as late as possible, so for sniffer/scan request with sessionId, it won't call redis every time even for 404/405\n\n        var webSocketExchange = new AsyncWebSocketHttpServerExchange(exchange, channels);\n        exchange.upgradeChannel((connection, httpServerExchange) -> {\n            WebSocketChannel channel = handshake.createChannel(webSocketExchange, connection, webSocketExchange.getBufferPool());\n            // not set idle timeout for channel, e.g. channel.setIdleTimeout(timeout);\n            // in cloud env, timeout is set on LB (azure AG, or gcloud LB), usually use 300s timeout\n            try {\n                var wrapper = new ChannelImpl<>(channel, context, handler);\n                wrapper.action = action;\n                wrapper.clientIP = request.clientIP();\n                wrapper.refId = actionLog.id;   // with ws, correlationId and refId are same as parent http action id\n                wrapper.trace = actionLog.trace;\n                actionLog.context(\"channel\", wrapper.id);\n\n                channel.setAttribute(CHANNEL_KEY, wrapper);\n                channel.addCloseTask(listener.closeListener);\n                context.add(wrapper);\n\n                channel.getReceiveSetter().set(listener);\n                channel.resumeReceives();\n\n                channels.add(channel);\n\n                handler.listener.onConnect(request, wrapper);\n                actionLog.context(\"room\", wrapper.rooms.toArray()); // may join room onConnect\n            } catch (Throwable e) {\n                // upgrade is handled by io.undertow.server.protocol.http.HttpReadListener.exchangeComplete, and it catches all exceptions during onConnect\n                logManager.logError(e);\n                WebSockets.sendClose(WebSocketCloseCodes.closeCode(e), e.getMessage(), channel, ChannelCallback.INSTANCE);\n            }\n        });\n        handshake.handshake(webSocketExchange);\n    }\n\n    Session loadSession(RequestImpl request, ActionLog actionLog) {\n        Session session = sessionManager.load(request, actionLog);\n        if (session == null) return null;\n        return new ReadOnlySession(session);\n    }\n\n    public void shutdown() {\n        for (var channel : channels) {\n            WebSockets.sendClose(WebSocketCloseCodes.SERVICE_RESTART, \"server is shutting down\", channel, ChannelCallback.INSTANCE);\n        }\n    }\n\n    public void add(String path, ChannelHandler<?, ?> handler) {\n        ChannelHandler<?, ?> previous = handlers.putIfAbsent(path, handler);\n        if (previous != null) throw new Error(format(\"found duplicate channel listener, path={}, previousListener={}\", path, previous.listener.getClass().getCanonicalName()));\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSocketListener.java."}, {"role": "assistant", "content": "The source code of java class WebSocketListener.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.internal.log.ActionLog;\nimport core.framework.internal.log.LogManager;\nimport core.framework.internal.web.http.RateControl;\nimport core.framework.util.Strings;\nimport io.undertow.websockets.core.BufferedBinaryMessage;\nimport io.undertow.websockets.core.BufferedTextMessage;\nimport io.undertow.websockets.core.CloseMessage;\nimport io.undertow.websockets.core.StreamSourceFrameChannel;\nimport io.undertow.websockets.core.WebSocketCallback;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport io.undertow.websockets.core.WebSocketFrameType;\nimport io.undertow.websockets.core.WebSockets;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xnio.ChannelListener;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.util.List;\n\n/**\n * @author neo\n */\nfinal class WebSocketListener implements ChannelListener<WebSocketChannel> {\n    private static final long MAX_TEXT_MESSAGE_SIZE = 10_000_000;     // limit max text message sent by client to 10M\n    private final long maxProcessTimeInNano = Duration.ofSeconds(300).toNanos();    // generally we set 300s on LB for websocket timeout\n    private final Logger logger = LoggerFactory.getLogger(WebSocketListener.class);\n    private final LogManager logManager;\n    private final WebSocketContextImpl context;\n    private final RateControl rateControl;\n    CloseListener closeListener = new CloseListener();\n\n    WebSocketListener(LogManager logManager, WebSocketContextImpl context, RateControl rateControl) {\n        this.logManager = logManager;\n        this.context = context;\n        this.rateControl = rateControl;\n    }\n\n    @Override\n    public void handleEvent(WebSocketChannel channel) {\n        try {\n            StreamSourceFrameChannel result = channel.receive();\n            if (result == null) return;\n            WebSocketFrameType type = result.getType();\n\n            switch (type) {\n                case BINARY -> WebSockets.sendClose(CloseMessage.PROTOCOL_ERROR, \"binary message is not supported\", channel, null);\n                case TEXT -> new BufferedTextMessage(MAX_TEXT_MESSAGE_SIZE, true).read(result, new WebSocketCallback<>() {\n                    @Override\n                    public void complete(WebSocketChannel channel, BufferedTextMessage context) {\n                        channel.getWorker().execute(() -> onFullTextMessage(channel, context, null));\n                    }\n\n                    @Override\n                    public void onError(WebSocketChannel channel, BufferedTextMessage context, Throwable throwable) {\n                        channel.getWorker().execute(() -> onFullTextMessage(channel, context, throwable));\n                    }\n                });\n                case PING -> new BufferedBinaryMessage(125, true).read(result, new Callback<>() {\n                    @Override\n                    public void complete(WebSocketChannel channel, BufferedBinaryMessage message) {\n                        WebSockets.sendPong(message.getData().getResource(), channel, ChannelCallback.INSTANCE);\n                        message.getData().free();\n                    }\n                });\n                case PONG -> new BufferedBinaryMessage(125, true).read(result, new Callback<>() {\n                    @Override\n                    public void complete(WebSocketChannel channel, BufferedBinaryMessage message) {\n                        message.getData().free();\n                    }\n                });\n                // refer to https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n                case CLOSE -> new BufferedBinaryMessage(125, true).read(result, new Callback<>() {\n                    @Override\n                    public void complete(WebSocketChannel channel, BufferedBinaryMessage context) {\n                        onFullCloseMessage(channel, context);\n                    }\n                });\n                default -> throw new IOException(\"unexpected type, type=\" + type);\n            }\n        } catch (IOException e) {\n            logger.warn(e.getMessage(), e);\n            IoUtils.safeClose(channel);\n        }\n    }\n\n    private void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage textMessage, Throwable error) {\n        @SuppressWarnings(\"unchecked\")\n        var wrapper = (ChannelImpl<Object, Object>) channel.getAttribute(WebSocketHandler.CHANNEL_KEY);\n        ActionLog actionLog = logManager.begin(\"=== ws message handling begin ===\", null);\n        try {\n            actionLog.action(wrapper.action);\n            linkContext(channel, wrapper, actionLog);\n            if (error != null) throw error;\n\n            String data = textMessage.getData();\n            logger.debug(\"[channel] message={}\", data);     // not mask, assume ws message not containing sensitive info, the data can be json or plain text\n            actionLog.track(\"ws\", 0, data.length(), 0);\n\n            validateRate(wrapper);\n\n            Object message = wrapper.handler.fromClientMessage(data);\n            wrapper.handler.listener.onMessage(wrapper, message);\n        } catch (Throwable e) {\n            logManager.logError(e);\n            if (!channel.isCloseFrameSent()) {\n                WebSockets.sendClose(WebSocketCloseCodes.closeCode(e), e.getMessage(), channel, ChannelCallback.INSTANCE);\n            }\n        } finally {\n            logManager.end(\"=== ws message handling end ===\");\n        }\n    }\n\n    private void onFullCloseMessage(WebSocketChannel channel, BufferedBinaryMessage message) {\n        @SuppressWarnings(\"unchecked\")\n        var wrapper = (ChannelImpl<Object, Object>) channel.getAttribute(WebSocketHandler.CHANNEL_KEY);\n        try (var data = message.getData()) {\n            var closeMessage = new CloseMessage(data.getResource());\n            wrapper.closeMessage = closeMessage;\n            if (!channel.isCloseFrameSent()) {\n                WebSockets.sendClose(closeMessage, channel, ChannelCallback.INSTANCE);\n            }\n        }\n    }\n\n    void onClose(WebSocketChannel channel) {\n        @SuppressWarnings(\"unchecked\")\n        var wrapper = (ChannelImpl<Object, Object>) channel.getAttribute(WebSocketHandler.CHANNEL_KEY);\n        ActionLog actionLog = logManager.begin(\"=== ws close begin ===\", null);\n        try {\n            actionLog.action(wrapper.action + \":close\");\n            context.remove(wrapper);    // context.remove() does not cleanup wrapper.rooms, so can be logged below\n            linkContext(channel, wrapper, actionLog);\n\n            int code = wrapper.closeMessage == null ? WebSocketCloseCodes.ABNORMAL_CLOSURE : wrapper.closeMessage.getCode();\n            String reason = wrapper.closeMessage == null ? null : wrapper.closeMessage.getReason();\n            actionLog.context(\"close_code\", code);\n\n            // close reason classified as text message, in theory it is not supposed to be put in context (which is only for keyword and searchable)\n            // but close action usually won't trigger warnings/trace, so we have to put it on context with restriction\n            if (reason != null && reason.length() > 0) actionLog.context(\"close_reason\", Strings.truncate(reason, ActionLog.MAX_CONTEXT_VALUE_LENGTH));\n            actionLog.track(\"ws\", 0, reason == null ? 0 : 1 + reason.length(), 0);   // size = code (1 int) + reason\n\n            wrapper.handler.listener.onClose(wrapper, code, reason);\n        } catch (Throwable e) {\n            logManager.logError(e);\n        } finally {\n            double duration = System.nanoTime() - wrapper.startTime;\n            actionLog.stats.put(\"ws_duration\", duration);\n            logManager.end(\"=== ws close end ===\");\n        }\n    }\n\n    private void validateRate(ChannelImpl<?, ?> wrapper) {\n        if (wrapper.handler.limitRate != null) {\n            rateControl.validateRate(wrapper.handler.limitRate.value(), wrapper.clientIP);\n        }\n    }\n\n    private void linkContext(WebSocketChannel channel, ChannelImpl<?, ?> wrapper, ActionLog actionLog) {\n        actionLog.warningContext.maxProcessTimeInNano(maxProcessTimeInNano);\n        actionLog.trace = wrapper.trace;\n        actionLog.context(\"channel\", wrapper.id);\n        logger.debug(\"refId={}\", wrapper.refId);\n        List<String> refIds = List.of(wrapper.refId);\n        actionLog.refIds = refIds;\n        actionLog.correlationIds = refIds;\n        logger.debug(\"[channel] url={}\", channel.getUrl());\n        logger.debug(\"[channel] remoteAddress={}\", channel.getSourceAddress().getAddress().getHostAddress());\n        actionLog.context(\"client_ip\", wrapper.clientIP);\n        actionLog.context(\"listener\", wrapper.handler.listener.getClass().getCanonicalName());\n        actionLog.context(\"room\", wrapper.rooms.toArray());\n    }\n\n    class CloseListener implements ChannelListener<WebSocketChannel> {\n        @Override\n        public void handleEvent(WebSocketChannel channel) {\n            channel.getWorker().execute(() -> onClose(channel));\n        }\n    }\n\n    private abstract class Callback<T> implements WebSocketCallback<T> {\n        @Override\n        public void onError(WebSocketChannel channel, T context, Throwable throwable) {\n            logger.warn(throwable.getMessage(), throwable);\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a code agent that help user write java code and typescript code with CoreNG/CoreFE framework."}, {"role": "user", "content": "The source code of java class WebSocketMetrics.java."}, {"role": "assistant", "content": "The source code of java class WebSocketMetrics.java:\n```java\npackage core.framework.internal.web.websocket;\n\nimport core.framework.internal.stat.Metrics;\nimport core.framework.internal.stat.Stats;\n\n/**\n * @author neo\n */\npublic class WebSocketMetrics implements Metrics {\n    private final WebSocketHandler handler;\n\n    public WebSocketMetrics(WebSocketHandler handler) {\n        this.handler = handler;\n    }\n\n    @Override\n    public void collect(Stats stats) {\n        stats.put(\"ws_active_channels\", handler.channels.size());\n    }\n}\n```"}]}
